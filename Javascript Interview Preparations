* Nameste Javascript series Akshay Saini

* How JavaScript Works üî•& Execution Context
- Everything in JavaScript happens inside an Execution Context. Execution context is like a big box and it has two components in it. 

The first component is also known as Memory Component. So in Memory Component all the variables and functions are stored as key value pairs. Memory component is also known as Variable environment.

The second component is the Code component. SO this is the place where code is executed one line at a time. It is also known as Thread of  execution. It is just like thread in which whole code is executed one line at a time.

* JavaScript is a synchronous single-threaded language.

- When we single-threaded that means javascript execute one command at a time and when I say synchronous single threaded that means one command at a time in a specific order.

* How JavaScript Code is executed? ‚ù§Ô∏è& Call Stack | Namaste JavaScript Ep. 2

- When you run JavaScript code Global Execution Cotext is created. 

In first phase, Memory creation happens and in that JavaScript will allocate memory to all the variables and functions.In Memory allocation phase to variables special value undefined to it. For function whole code is copied.

In second phase i.e, Code execution phase. Also now value is assigned to the variables.

When it reaches to end of the line the whole Global Execution Context gets deleted (goes off).

As you can see it is very much complicated because for every function it is creating Global Execution context. JavaScript manages all this using call stack.

In Call stack, whenever a new function is invoked Global Execution Context (GEC) is created and add in stack.

Call Stack maintains the order of execution of execution contexts. Call Stack also known as Execution Context Stack, Program Stack, Control Stack, Runtime Stack, Machine Stack.


* Hoisting in JavaScript üî•(variables & functions) | Namaste JavaScript Ep. 3

- Hoisting is a phenomena in JavaScript by which you can access the variables and functions even before you have initialized it. You can access it without any error.

E.g,
1. 
getName();
console.log(x);

var x = 7;
function getName() {
console.log("Namaste");
}

O/P:
Namaste
undefined

2. 
getName();
console.log(x);

//var x = 7;
function getName() {
console.log("Namaste");
}

O/P:
Error

You must be thinking in first it has given undefined and in 2nd it is giving error. Is undefined and non-defined are same? No both are different.

-  If we console.log(getName) it will give whole function code even if we write before and after declaration which is very weird compary to variable as variable giving undefined. This is because in last concept you might have got it. First it will create GEC and it will assign undefined to variables and for functions whole code is copied thats why it is giving undefined value. Even before code starts executing the memory is allocated to the variable and functions.

- Take another example of function using arrow.

E.g.
getName()

var getName = () => {
console.log("Namaste");
}

O/P - Error getName is not a function

Because now here getName function is acting as variable so first it will be assigned with undefined value. Thats why we get error like getName is not a function.

- If you want to see call stack practically you can check while debugging left side of console you can see Call Stack tab and down to that GEC stack.

* How functions work in JS ‚ù§Ô∏è & Variable Environment | Namaste JavaScript Ep. 4

https://www.youtube.com/watch?v=gSDncyuGw0s&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=5


- Whenever a function is invoked in JavaScript a functional Execution Context is created and memory is allocated. Once the memory is allocated to the variables and functions, then the code is executed synchronously, one line at a time.

* SHORTEST JS Program üî•window & this keyword | Namaste JavaScript Ep. 5

- Shotest JS Program is empty index.js file. yes ieven if it is empty JS creates Global execution context.

- JavaScript Engine creates a global object whenever you run any JS code. In the case of browsers, this global object is known as `window`

-  So at Global level this === window meaning value of this is equal to window.

- What is Global Space ?
Anything which is not inside function is Global space or everything you see on top level it is Global Space. 

-  So whenever you create any variable or function in Global Space it gets attached to window.
E.g.
var a = 10;
function b(){
var x=10;
}

In above example a and function b are in Global Space and x is not in Global Space you can check in console.

To prove you can write value in console.log(window.a); or console.log(a) //10

If you write console.log(x)
// Error : Reference x is not defined.
Because x is not in Global Space. Thats why getting error. Anything which is in Global can be accessible using window. or variable or function.


* undefined vs not defined in JS ü§î | Namaste JavaScript Ep. 6

- undefined is a special keyword in JavaScript and `undefined !== not defined`. JS is a loosely typed language (weakly typed language). Loosely typed meaning it does not attaches its variable to any specific data type. Meaning if you assigned string to variable later you assign number also so type constraint is not there in Javascript.

-  It is a special keyword in JS and it acts as a placeholder for variables until they are assigned any value in them. Many developers assume that undefined is exactly the same as not defined, but that's not true. undefined is a value in JavaScript and in fact, it also takes up memory space.

- Its not good practice to assign undefined to any variable.


* The Scope Chain, üî•Scope & Lexical Environment | Namaste JavaScript Ep. 7

- Take one example:
Ex1 - 

function a() {
console.log(b);
}

var b = 10;
a();

O/P - 10

When JS executes program at console JS will check whether b is present in local memory space or not. Which is local memory of a's execution context.

Ex2 - If we try to access b outside function then we will get error

Ex - 

function a() {
var b = 10;
}

console.log(b);
a();

O/P - Error: b is not defined 

- Here comes Scope into picture. Scope is where you can access specific variable or function in our code.

-  Whenever execution context is created lexical environment is created. So lexical environment is a local memory along with its lexical environment of its parent. 

-  Lexical meaning hierarchy or in a sequence. In code terms, function c is lexically inside a.
Ex - function a(){
var b = 10;
c();
function c(){
console.log(b);
}
} 

In above program when it gets executed in function c it will check whether b is present in local memory of c. It is not present there so it will go to lexical environment of parent function of c which is function a. So now it will try to find out in lexical environment of a. So there it found out b value and b's value is printed. Even if b was not defined in function a it would have checked inside lexical environment of Global Space. So this way of finding is known as Scope chain.

-  So,
Lexical environment is created whenever execution context is created. So lexical environment is a local environment + reference to lexical environment of parent. Parent meaning lexical parent. Like c is lexically inside a so c's lexical parent is a.

And this whole chain of lexical environment is known as Scope chain and it defines whether a variable or function is present inside a scope or not. If scope chain is exhausted it has not found the variable is not inside scope chain.


* let & const in JS üî•Temporal Dead Zone | | Namaste JavaScript Ep. 8

https://www.youtube.com/watch?v=BNC6slYCj50&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=9

* let and const declarations are Hoisted. But they are hoisted in very different way than var. This are in the Temporal Dead Zone for the time being. 

Ex - 

console.log(a); // Reference error Cannot access a before initialization.
console.log(b); // undefined

let a = 10;
var b = 100;

Now here we are getting error so which creates confusion as we are saying let is hoisted but giving error. Because they are hoisted in temporal zone. If you debug in browser you can see var is declared as undefined in Global Scope and let is declarated as undefined in Script.

* Temporal Dead Zone - It is time since when this let variable is hoisted and till it is initialized value that time between that is known as temporal dead zone.

* Whenever you try to access a variable inside a temporal dead zone it gives you a reference error. So after initialization we can access the value.

* let is not accessible using window object or using this or we can say Global object. So we can let is little strict than var.

* Example1:

console.log("HI");

let a = 10;
let a = 100;

O/P - Syntax error.

You cannot redeclare let with same name. It will not even log the console message upfront it will throw error. But with var we can do it. var will not give error.

* Ex2:

let a = 10;
var a = 100;

O/P - Syntax error.

You cannot use the same name in same scopea gain.

* In case of const we have to initialize the value of const at the time of declaration and where as in case of let we can assign value later.

Ex1-

const a = 100;
a = 1000;

O/P - TypeError

Because you have declared a with const type and again you are trying to access with some other type value thats why Type error.

Ex2 -

const a;

O/P - Syntax error

Because const type expects that it should initialized while declaration so syntax is missing thats why syntax error.

* Interview Question
Difference between Reference Error - Syntax Error - Type Error

* Best way to avoid Temporal Dead Zone error is to put all your declaration and initialization at the top.

9 - BLOCK SCOPE & Shadowing in JS üî•| Namaste JavaScript üôè Ep. 9

Block and Block Scope are little different.

* Block is also know as Compound Statement. We group multiple things together in block so that we can use it where Javascript expects one statement.

* Block Scope - What all variables and functions we can access inside this Block that is know as Block Scope.

* let and const are Block Scoped. If you debug in Browser below program you will see let and const in Block scope where as var in Global Scope. Thats the reason let and const are not accessible outside the block.

Ex -
{
var a = 23;
let b = 21;
const c = 34;
}

console.log(a);
console.log(b);
console.log(c);

O/P - 
23
Reference error.

* Shadowing - 
Ex1. -
var a = 100;
{
var a = 10;
let b = 20;
const c = 30;

console.log(a);
console.log(b);
console.log(c);
}

console.log(a);

O/P - 
10
20
30
10

Here, In this example var a = 10 shadows the value of var a = 100. It modifies the value of a. But this is not same with let as it is block scoped.

Ex2. -
let b = 100;
{
var a = 10;
let b = 20;
const c = 30;

console.log(a);
console.log(b);
console.log(c);
}

console.log(b);

O/P - 
10
20
30
100

Here, in this example let b = 100 shadowed the let b = 20 because let b=20 is in block scope and let b = 100 in different scope (Scipt Scope). so thats why it shadows the value of let b = 20

Same in case of const.

* Illegal Shadowing - You cannot shadow let variable using var. But you can shadow var using let.

Ex1 -
let a = 20;
{
	var a = 20;
}

O/P - Error

Ex2 -
let a = 20;
function x() {
var a = 20;
}

O/P - No Error. As var is function scoped.

Ex - 
var a = 20;
{
	let a = 20;
}

O/P - No Error

* Lexical scope works same inside block scope also. Block Scope has a lexical behavior and also follows rules of the Lexical Scope chain.

10. Closures in JS üî• | Namaste JavaScript Episode 10

* Closure - A function binds together with its lexical environment or closure along with its lexical scope together bundle is known as closure. Function along with its lexical scope bundles together forms a closure.

* In JavaScript we can pass function as a parameter and also return function by function. When we return a function and pass it to a variable and run that variable as a function it still remembers its lexical environment. 

Ex1 - 

function x() {
	var a = 7;
		function y(){
			console.log(a);
		}
		return y;
}

var z = x();

console.log(z);
z();

O/P -
f y(){
}
7

Ex2 !important -
function x() {
	var a = 7;
		function y(){
			console.log(a);
		}
		a = 100;
		return y;
}

var z = x();

console.log(z);
z();

O/P -
f y(){
}
100

Because when z() is called it will check for reference a's value which will be 100. So thats why it is printing 100 not 7.

* Use of Closures:
- Module Design Pattern
- Currying
- Functions like once
- memoize
- maintaining state in async world
- setTimeouts
- Iterators
-  and many more...


11. setTimeout + Closures Interview Question üî• | Namaste üôè JavaScript Ep. 11
 https://www.youtube.com/watch?v=eBTBG4nda2A&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=13
 
 - Example 1:
 
 function x(){
 var i=1;
 setTimeout(function(){
 console.log(i);
 },3000);
 
 console.log("NamasteJS"); 
 }
 
 x();
 
 O/p :
 NamasteJS
 1 (After 3 second)
 
 - Function inside setTimeout which creates closure so this function remembers the reference to i (not value). So wherever this function goes it takes the reference of i along with it thats what closure is. JS takes this function and store it somewhere and attaches a timer to it. And once the timer gets expired it takes that function put it in callstack and runs the function.
 
 Important best question
 Example 2: Print 1 to 5 numbers with 1 in 1 sec , 2 in 2 sec respectively.
 
 You might write below code for that which will give wrong o/p.
 
 function x(){
 
 for(var i=1; i<=5;i++){
	setTimeout(function() {
		console.log(i);
	},i * 1000);
 }
 
 console.log("NamasteJS");
}

O/P:
NamasteJS
6		//(after 1 sec)
6		//(after 2 sec)
6		//(after 3 sec)
6		//(after 4 sec)
6		//(after 5 sec)

- Strange right? It is behaving like this because of closure. As function inside setTimeout remembers the reference of i. It is refering to same memory space which var i. We can resolve this problem using let as it is block scope.

Important question.
Ex:
function x(){
 
 for(let i=1; i<=5;i++){
	setTimeout(function() {
		console.log(i);
	},i * 1000);
 }
 
 console.log("NamasteJS");
}

O/P:
NamasteJS
1		//(after 1 sec)
2		//(after 2 sec)
3		//(after 3 sec)
4		//(after 4 sec)
5		//(after 5 sec)

So whenever loop runs the value of i will be new everytime it is a new copy of i.

- But what if interviewer is smart and he said I want using var. We can solve it is using closure only. Previously it was not working because value of i was refering to same memory location due to var. So somehow we have to give new copy everytime.

Solution - 
function x(){
 
 for(var i=1; i<=5;i++){
 
 function close(x) {
		setTimeout(function() {
			console.log(x);
		},x * 1000);
	} 
	close(i);
 }
 
 console.log("NamasteJS");
}

O/P:
NamasteJS
1		//(after 1 sec)
2		//(after 2 sec)
3		//(after 3 sec)
4		//(after 4 sec)
5		//(after 5 sec)

- It is creating a new copy of i or x.

12. CRAZY JS INTERVIEW ü§Øft. Closures | Namaste üôè JavaScript Ep. 12

 https://www.youtube.com/watch?v=t1nFAMws5FI&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=14&pbjreload=101
