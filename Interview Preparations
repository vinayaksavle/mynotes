* Nameste Javascript series Akshay Saini

* How JavaScript Works üî•& Execution Context
- Everything in JavaScript happens inside an Execution Context. Execution context is like a big box and it has two components in it. 

The first component is also known as Memory Component. So in Memory Component all the variables and functions are stored as key value pairs. Memory component is also known as Variable environment.

The second component is the Code component. SO this is the place where code is executed one line at a time. It is also known as Thread of  execution. It is just like thread in which whole code is executed one line at a time.

* JavaScript is a synchronous single-threaded language.

- When we single-threaded that means javascript execute one command at a time and when I say synchronous single threaded that means one command at a time in a specific order.

* How JavaScript Code is executed? ‚ù§Ô∏è& Call Stack | Namaste JavaScript Ep. 2

- When you run JavaScript code Global Execution Cotext is created. 

In first phase, Memory creation happens and in that JavaScript will allocate memory to all the variables and functions.In Memory allocation phase to variables special value undefined to it. For function whole code is copied.

In second phase i.e, Code execution phase. Also now value is assigned to the variables.

When it reaches to end of the line the whole Global Execution Context gets deleted (goes off).

As you can see it is very much complicated because for every function it is creating Global Execution context. JavaScript manages all this using call stack.

In Call stack, whenever a new function is invoked Global Execution Context (GEC) is created and add in stack.

Call Stack maintains the order of execution of execution contexts. Call Stack also known as Execution Context Stack, Program Stack, Control Stack, Runtime Stack, Machine Stack.


* Hoisting in JavaScript üî•(variables & functions) | Namaste JavaScript Ep. 3

- Hoisting is a phenomena in JavaScript by which you can access the variables and functions even before you have initialized it. You can access it without any error.

E.g,
1. 
getName();
console.log(x);

var x = 7;
function getName() {
console.log("Namaste");
}

O/P:
Namaste
undefined

2. 
getName();
console.log(x);

//var x = 7;
function getName() {
console.log("Namaste");
}

O/P:
Error

You must be thinking in first it has given undefined and in 2nd it is giving error. Is undefined and non-defined are same? No both are different.

-  If we console.log(getName) it will give whole function code even if we write before and after declaration which is very weird compary to variable as variable giving undefined. This is because in last concept you might have got it. First it will create GEC and it will assign undefined to variables and for functions whole code is copied thats why it is giving undefined value. Even before code starts executing the memory is allocated to the variable and functions.

- Take another example of function using arrow.

E.g.
getName()

var getName = () => {
console.log("Namaste");
}

O/P - Error getName is not a function

Because now here getName function is acting as variable so first it will be assigned with undefined value. Thats why we get error like getName is not a function.

- If you want to see call stack practically you can check while debugging left side of console you can see Call Stack tab and down to that GEC stack.

* How functions work in JS ‚ù§Ô∏è & Variable Environment | Namaste JavaScript Ep. 4

https://www.youtube.com/watch?v=gSDncyuGw0s&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=5


- Whenever a function is invoked in JavaScript a functional Execution Context is created and memory is allocated. Once the memory is allocated to the variables and functions, then the code is executed synchronously, one line at a time.

* SHORTEST JS Program üî•window & this keyword | Namaste JavaScript Ep. 5

- Shotest JS Program is empty index.js file. yes ieven if it is empty JS creates Global execution context.

- JavaScript Engine creates a global object whenever you run any JS code. In the case of browsers, this global object is known as `window`

-  So at Global level this === window meaning value of this is equal to window.

- What is Global Space ?
Anything which is not inside function is Global space or everything you see on top level it is Global Space. 

-  So whenever you create any variable or function in Global Space it gets attached to window.
E.g.
var a = 10;
function b(){
var x=10;
}

In above example a and function b are in Global Space and x is not in Global Space you can check in console.

To prove you can write value in console.log(window.a); or console.log(a) //10

If you write console.log(x)
// Error : Reference x is not defined.
Because x is not in Global Space. Thats why getting error. Anything which is in Global can be accessible using window. or variable or function.


* undefined vs not defined in JS ü§î | Namaste JavaScript Ep. 6

- undefined is a special keyword in JavaScript and `undefined !== not defined`. JS is a loosely typed language (weakly typed language). Loosely typed meaning it does not attaches its variable to any specific data type. Meaning if you assigned string to variable later you assign number also so type constraint is not there in Javascript.

-  It is a special keyword in JS and it acts as a placeholder for variables until they are assigned any value in them. Many developers assume that undefined is exactly the same as not defined, but that's not true. undefined is a value in JavaScript and in fact, it also takes up memory space.

- Its not good practice to assign undefined to any variable.


* The Scope Chain, üî•Scope & Lexical Environment | Namaste JavaScript Ep. 7

- Take one example:
Ex1 - 

function a() {
console.log(b);
}

var b = 10;
a();

O/P - 10

When JS executes program at console JS will check whether b is present in local memory space or not. Which is local memory of a's execution context.

Ex2 - If we try to access b outside function then we will get error

Ex - 

function a() {
var b = 10;
}

console.log(b);
a();

O/P - Error: b is not defined 

- Here comes Scope into picture. Scope is where you can access specific variable or function in our code.

-  Whenever execution context is created lexical environment is created. So lexical environment is a local memory along with its lexical environment of its parent. 

-  Lexical meaning hierarchy or in a sequence. In code terms, function c is lexically inside a.
Ex - function a(){
var b = 10;
c();
function c(){
console.log(b);
}
} 

In above program when it gets executed in function c it will check whether b is present in local memory of c. It is not present there so it will go to lexical environment of parent function of c which is function a. So now it will try to find out in lexical environment of a. So there it found out b value and b's value is printed. Even if b was not defined in function a it would have checked inside lexical environment of Global Space. So this way of finding is known as Scope chain.

-  So,
Lexical environment is created whenever execution context is created. So lexical environment is a local environment + reference to lexical environment of parent. Parent meaning lexical parent. Like c is lexically inside a so c's lexical parent is a.

And this whole chain of lexical environment is known as Scope chain and it defines whether a variable or function is present inside a scope or not. If scope chain is exhausted it has not found the variable is not inside scope chain.


* let & const in JS üî•Temporal Dead Zone | | Namaste JavaScript Ep. 8

https://www.youtube.com/watch?v=BNC6slYCj50&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=9
