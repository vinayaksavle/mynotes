Angular Revision Notes

* Angular Versions

Angular 9
- The Angular 9 is released on 06.02.2020. The Angular 9 is a major release. This release switches to ivy compiler and runtime by default. The ivy brings smaller bundle sizes, faster & better testing debugging, Improved type checking, build times, etc
- The Ivy compiler: The default use of the Ivy compiler is the most important feature of Angular 9, Ivy is what actually designed to solve the major problems of Angular i.e the performance and large file size

* Components
- The Component is the main building block of an Angular Application. A Component contains the definition of the View and the data that defines how the View looks and behaves.  The Angular Components are plain javascript classes and defined using @component Decorator. This Decorator provides the component with the View to display & Metadata about the class

- The Component passes the data to the view using a process called Data Binding. This is done by Binding the DOM Elements to component properties. Binding can be used to display component class property values to the user, change element styles, respond to a user event, etc.

1. Introduction to Angular Components

	* Features of Angular
	- Two-Way Data Binding
	- Powerful Routing Support
	- Expressive HTML (Enables us to use programming constructs like if conditions, for loops, etc.(*ngIf,*ngFor) to render and control how the HTML pages)
	- Modular by Design
	- Built-in Back End Support
	- Active Community
	
	* Key differences between AngularJs & Angular
	- Support for ES6
	- Components are new controllers
	- Directives (Replaced ng-repeat & ng-if with *ngFor & *ngIf * indicates as a structural directive )
	- $scopes are out (AngularJS used to run a dirty checking on the scope objects to see if any changes occurred. The Angular is using zone.js to detect changes. Zone.js apply patches on all the global asynchronous operations like click event, timer events, HTTP requests, etc. It then intimates the Angular, whenever the changes occur in Angular Application. The Angular then runs the change detection for the entire application)
	- Filters are renamed to Pipes
	- Mobile Support (AngularJS was not built with mobile support in mind. Angular designed with mobile development in mind.)

- Angular currently has following class decorators
1.@Component
2.@Directive
3.@Injectable
4.@NgModule
5.@Pipe

- Module Loaders (The later versions of Angular comes bundled with the Webpack module loader. Module loader takes a group of modules with their dependencies and merges them into a single file in the correct order. This process is called as Module bundling.)

- .editorconfig: This is the configuration file for the Visual Studio code editor. EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs.
- .gitignore: Git configuration to make sure autogenerated files are not committed to source control.
- angular.json: This is the configuration file for Angular CLI. The older versions of the Angular used the file angular-cli.json
- browserslist: Ensures the compatibility of the Angular app with different browsers.
- karma.conf.js: The Configuration file for the karma test runner.
- package.json: The package.json is an npm configuration file, that lists the third-party packages that your project depends on. We also have package-lock.json
- README.md: The Read me file
- tsconfig.json, tsconfig.app.json & tsconfig.spec.json are Typescript configuration files. The tsconfig.json is the Typescript compiler configuration file. This file specifies the compiler options required for the Typescript to compile (transpile) the project. The tsconfig.app.json is used for compiling the code, while tsconfig.spec.json for compiling the tests
- tslint.json: tslint is a static code analysis tool. We use this to check Typescript code quality. To check if TypeScript source code complies with coding rules. TSLint checks your TypeScript code for readability, maintainability, and functionality errors
- e2e: This folder contains the files required for end to end tests by protractor. Protractor allows us to test our application against a real browser.
- node_modules: All our external dependencies are downloaded and copied here by NPM Package Manager.
- src: This where our application lives.
- polyfills.ts: Different browsers have different levels of support of the web standards. Polyfills help normalize those differences. 
- test.ts: This is the main entry point for your unit tests. 

- Webpack is a bundler. it scans our application looking for javascript files and merges them into one ( or more) big file. Webpack has the ability to bundle any kind of file like JavaScript, CSS, SASS, LESS, images, HTML, & fonts, etc.
- angular.json: The Angular finds out the entry point from the configuration file angular.json. This file is located in the root folder of the project. 
- platformBrowserDynamic is the module, which is responsible for loading the Angular application in the desktop browser.

- We use ng build to build our app. Open the command prompt and run the command. This will build and copy the output files to the dist folder
- Use ng build --prod to build and distribute the app for production. For testing/debugging use ng build. The production build optimizes, minimize and uglify the code.
- Now open the dist and open the index.html. You can see that the compiler included five script files. They are runtime, polyfills, styles, vendor, & main. All these files have two versions one is es5 & the other one es2015. Since the Angular 7, we have new feature called conditional polyfill loading. Now Angular builds two script files, one for es2015 & another for es5. The es2015 (es6) is for modern browser and es5 is older browsers, which do not support the new features of es2015.

Note the nomodule attribute, which tells the modern browser to ignore the script and do not load it. Hence es5 scripts are not loaded in the modern browsers. These files are added by the Webpack module loader.
- runtime.js: Webpack runtime file
- polyfills.js – Polyfill scripts for supporting the variety of the latest modern browsers
- styles.js – This file contains the global style rules bundled as javascript file.
- vendor.js – contains the scripts from the Angular core library and any other 3rd party library.
- main.js – code of the application.

* What is Webpack?
Webpack is a bundler. it scans our application looking for javascript files and merges them into one ( or more) big file. Webpack has the ability to bundle any kind of file like JavaScript, CSS, SASS, LESS, images, HTML, & fonts, etc.

- The entry point of our application is main.ts. You will find it under the src folder.

* What is platformBrowserDynamic
platformBrowserDynamic is the module, which is responsible for loading the Angular application in the desktop browser.

* Building blocks of the Angular Component
- Template (View) - The template defines the layout of the View and defines what is rendered on the page.  Without the template,  there is nothing for Angular to render to the DOM.

- Class
The class is the code associated with Template (View). The Class is created with the Typescript, but you can also use javascript directly in the class. Class Contains the Properties & Methods. The Properties of a class can be bind to the view using Data Binding.

- Metadata
Metadata Provides additional information about the component to the Angular. Angular uses this information to process the class. The Metadata is defined with a decorator.

- @Component decorator
A class becomes a Component when Component Decorator is used. A Decorator is always prefixed with @. The Decorator must be positioned immediately before the class definition. We can also build our own decorators. The decorators are Similar to attributes in C#

2. Data Binding in Angular

- Data binding is a technique, where the data stays in sync between the component and the view. Whenever the user updates the data in the view, Angular updates the component. When the component gets new data, the Angular updates the view.

- The data binding in Angular can be broadly classified into two groups.
i) One way binding
- In one way binding data flows from one direction. Either from view to component or from component to view.

* From Component to View
To bind data from component to view, we make use of Interpolation & Property Binding.

- Interpolation - Interpolation allows us to include expressions as part of any string literal, which we use in our HTML. The Angular uses the {{ }} (double curly braces) in the template to denote the interpolation. The content inside the double braces is called Template Expression.
Syntax: {{ templateExpression }}

- Property binding - The Property binding allows us to bind HTML element property to a property in the component. You can set the properties such as class, href, src, textContent, etc using property binding. You can also use it to set the properties of custom components or directives (properties decorated with @Input).
Syntax: [binding-target]=”binding-source”
<button [disabled]="isDisabled">I am disabled</button>

- Attribute binding
Sometimes there is no HTML element property to bind to. The examples are aria (accessibility) Attributes & SVG. In such cases, you can make use of attribute binding.
Syntax: <button [attr.aria-label]="closeLabel" (onclick)="closeMe()">X</button>
Accessible Rich Internet Applications (ARIA) is a set of attributes that define ways to make web content and web applications (especially those developed with JavaScript) more accessible to people with disabilities.
MDN — Mozilla Developer Network

* From View to Component
- Event Binding - Event binding allows us to bind events such as keystroke, clicks, hover, touch, etc to a method in component. 
Syntax: (target-event)="TemplateStatement"

- Two Way binding
Two-way binding means that changes made to our model in the component are propagated to the view and that any changes made in the view are immediately updated in the underlying component. The two-way binding uses the special syntax known as a banana in a box [()]
Syntax: <someElement [(someProperty)]="value"></someElement>.

- ngModel
The Angular uses the ngModel directive to achieve the two-way binding on HTML Form elements. It binds to a form element like input, select, selectarea. etc. The ngModel directive is not part of the Angular Core library. It is part of the @angular/forms. You need to import the FormsModule package into your Angular module.

3. Interpolation in Angular
- Interpolation allows us to include expressions as part of any string literal, which we use in our HTML. The Angular uses the {{ }} (double curly braces) in the template to denote the interpolation. The syntax is as shown below.
Ex - {{ templateExpression }}

- The content inside the double braces is called Template Expression.

- The Template expression should not change the state of the application. The Angular uses it to read the values from the component and populate the view. If the Template expression changes the component values, then the rendered view would be inconsistent with the model

It means that you cannot make use of the following

Assignments (=, +=, -=, …)
Keywords like new, typeof, instanceof, etc
Chaining expressions with ; or ,
The increment and decrement operators ++ and --
bitwise operators such as | and &

- If you want to bind the expression that is other than a string (for example – boolean), then Property Binding is the best option.

- Interpolation and property binding can set only properties, not attributes. For Attributes use attribute binding.

- You can use interpolation to invoke a method in the component, Concatenate two string, perform some mathematical operations or change the property of the DOM element like color, etc.

Ex - 
{{getTitle()}}
<p>{{ 'Hello & Welcome to '+ ' Angular Interpolation '}}</p>
<p>Welcome {{firstName}}, {{lastName}}</p>

- You can also use the template reference variable. The following example creates a template variable #name to an input box. You can use it get the value of the input field {{name.value}}
Ex - 
<label>Enter Your Name</label>
<input (keyup)="0" #name>
<p>Welcome {{name.value}} </p>

- The Angular updates the view, when it runs the change detection. The change detection runs only in response to asynchronous events, such as the arrival of HTTP responses, raising of events, etc. In the example above whenever you type on the input box, it raises the keyup event. It forces the angular run the change detection, hence the view gets the latest values.

- You can make use of Angular Pipes to transform the expression result. Like converting to an uppercase, date formats, adding currency symbols, etc
Ex - <p>uppercase pipe: {{title | uppercase}}</p>

- The Safe Navigation Operator is also known as the "Elvis Operator". This operator is very useful to protect against null and undefined values in property paths. 

Ex - 
In the first case, I am trying to retrieve the data from the object path "data.firstName" using interpolation. Here, I am not defining the data so Angular parsing throws runtime null-reference exceptions. Here, our application crashes when the data is null.
<div> Hi, This Text will generate error!!! {{data.firstName}} </div>  

Now, Using the Safe Navigation Operator. So, it is protecting against the null exception.
<div> Hi, This Text will not generating error Console!!! {{data?.firstName}} </div> 

- Alternative of Safe Navigation Operator
1. The same behavior can be achieved using *ngIf Directive. In the following example, I have hidden the text when the "data" is null. 
<div *ngIf="data"> Hi, This Text will not generating error Console!!! {{data.firstName.text}} - *ngIf Example </div> 

2. The second alternative is to use "&& operator". Here, we first check for "data". When it is not null, then Angular will populate the data.firstname, else null.
<div> Hi, This Text will not generating error Console!!! {{ data && data.firstName.text}} </div>  

- The non-null assertion operator
Typescript enforces the strict null checking if you enable the --strictNullChecks flag in your tsconfig.json. Under strict null check any variable not defined or null results in a compiler error. The type checker also throws an error if it can’t determine whether a variable will be null or undefined at runtime.

- You can use the non-null assertion operator to inform typescript not to throw any compile errors. Note that it is a compile-time feature & not runtime.
Ex - The item's name is: {{item!.name}}

4. Property Binding in Angular
https://www.tektutorialshub.com/angular/property-binding-in-angular/

- Property binding is one way from component to view. It lets you set a property of an element in the view to property in the component. You can set the properties such as class, href, src, textContent, etc using property binding. You can also use it to set the properties of custom components or directives (properties decorated with @Input).

- The Property Binding uses the following Syntax

[binding-target]=”binding-source”
 
The binding-target (or target property) is enclosed in a square bracket []. It should match the name of the property of the enclosing element.

Binding-source is enclosed in quotes and we assign it to the binding-target. The Binding source must be a template expression. It can be property in the component, method in component, a template reference variable or an expression containing all of them.

Whenever the value of Binding-source changes, the view is updated by the Angular.

Ex - 
<h1 [innerText]="title"></h1>
<h2>Example 1</h2>
<button [disabled]="isDisabled">I am disabled</button>
 
import { Component } from '@angular/core';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title="Angular Property Binding Example"
  
  //Example 1
  isDisabled= true;
}

- Property Binding is one way
Property binding is one way as values go from the component to the template. When the component values change, the Angular updates the view. But if the values changes in the view, the Angular does not update the component.

- The brackets, [], tell Angular to evaluate the template expression. If you omit the brackets, Angular treats the expression as a constant string and initializes the target property with that string:

- The property binding binds to the properties of DOM elements, components, and directives and not to HTML attributes. The angular has a special syntax for attribute binding.

- The Angular has a special syntax for class, styles & attribute binding.The classes & styles are special because they contain a list of classes or styles. The bindings need to be more flexible in managing them. Hence we have a class & style binding.

The Property bindings cover all the properties, but there are certain HTML attributes that do not have any corresponding HTML property. Hence we have attribute binding

* Class binding
You can set the class in the following ways. Click on the links to find out more

i) ClassName Property binding
Ex -You can also add more than one class by separating them using the
<div [className]="'red size20'">Test</div>

ii) Set the Class attribute with class binding
Ex - To dynamically or conditionally bind a class, First create a variable in the component class as shown below.
<div [class.red]="hasError" [class.size20]="hasError">Test</div>

iii) ngClass directive
You can also use the ngClass without a square bracket. In that case, the expression is not evaluated but assigned directly to the class attribute. We also need to remove the double quote around the expression as shown below.

Ex - 
<div class="row">     
    <div ngClass='red size20'>Red Text with Size 20px </div> 
</div>

NgClass with Array
<element [ngClass]="['cssClass1', 'cssClass2']">...</element>

* Style Binding
i) Style Property Binding
Ex - 
<p [style.color]="getColor()" 
   [style.font-size.px]="'20'"      
   [style.background-color]="status=='error' ? 'red': 'blue'">
   paragraph with multiple styles
</p>

ii) ngStyle directive
Ex - 
<input [(ngModel)]="size" /> 
<div [ngStyle]="{'font-size.px': size}">Change my size</div>

* Attribute Binding
Sometimes there is no HTML element property to bind to. The examples are aria (accessibility) Attributes & SVG. In such cases, you can make use of attribute binding. The attribute syntax starts with attr followed by a dot and then the name of the attribute as shown below.

Ex - 

<button [attr.aria-label]="closeLabel" (onclick)="closeMe()">X</button>

<td [attr.colspan]="2">Col 1 & 2</td> 
<td bind-attr.colspan = "getColspan()">Col 2 & 3 </td>

// component TS
closeLabel="close";
getColspan() {
   return "2"
}

* Property Binding Vs Interpolation

- Everything that can be done from interpolation can also be done using the Property binding. Interpolation is actually a shorthand for binding to the textContent property of an element.
Ex - 
For example the following interpolation
<h1> {{ title }} </h1>
Is same as the following Property binding
<h1 [innerText]="title"></h1>


- Interpolation requires the expression to return a string. If you want to set an element property to a non-string data value, you must use property binding.

5. Event Binding in Angular
https://www.tektutorialshub.com/angular/event-binding-in-angular/

- Event binding allows us to bind events such as keystroke, clicks, hover, touche, etc to a method in component. It is one way from view to component. By tracking the user events in the view and responding to it, we can keep our component in sync with the view. For Example, when the user changes to an input in a text box, we can update the model in the component, run some validations, etc. When the user submits the button, we can then save the model to the backend server.

Ex - 
Angular event binding syntax consists of a target event name within parentheses on the left of an equal sign, and a quoted template statement on the right.

The following event binding listens for the button’s click events, calling the component’s onSave() method whenever a click occurs

<button (click)="onSave()">Save</button>

click - Target Event
onSave - Template Statement

- Unlike the Property Binding & Interpolation, where we use the template expression is used, in case of event binding we use template statement.

The Template statement can change the state of the component. Angular runs the change detection and updates the view so as to keep it in sync with the component.

- Instead of parentheses, you can also use the on- syntax as shown below.
Ex - 
<button on-click="clickMe()">Click Me</button>

- $event Payload
DOM Events carries the event payload. I.e the information about the event. We can access the event payload by using $event as an argument to the handler function.

Ex - 
<input (input)="handleInput($event)">
<p>You have entered {{value}}</p>

value=""
handleInput(event) {
  this.value=event.target.value;
}

- The properties of a $event object vary depending on the type of DOM event. For example, a mouse event includes different information than an input box editing event.

Remember you need to use the variable as $event in the Template statement. Example handleInput($event). Otherwise, it will result in an error

- We can also make use of the template reference variable to pass the value instead of $event.

Ex -
<h2>Template Reference Variable</h2>
<input #el (input)="handleInput1(el)">
<p>You have entered {{val}}</p>
 
val="";
handleInput1(element) {
  this.val=element.value;
}

- We use keyup/keydown events to listen for keystrokes. The following example does that
Ex-
<input (keyup)="value1=$event.target.value">
<p>You entered {{value1}}</p>

But Angular also offers a feature, where it helps to filter out certain keys. For Example, if you want to listen only to the enter keys you can do it easily
Ex-
<input (keyup.enter)="value2=$event.target.value">
<p>You entered {{value2}}</p>

On pressing enter key it updates the value3 variable and on escape clears the variable.
Ex - 
<input (keyup.enter)="value3=$event.target.value" (keyup.escape)="$event.target.value='';value3=''">
<p>You entered {{value3}}</p>

You can also listen for the key combination
Ex -
<input (keyup.control.shift.enter)="value4=$event.target.value">
<p>You entered {{value4}}</p>

6. Two way Binding & ngModel in Angular
https://www.tektutorialshub.com/angular/ngmodel-two-way-data-binding-in-angular/

- Two way data binding means that changes made to our model in the component are propagated to the view and that any changes made in the view are immediately updated in the underlying component data.

- The two way data binding nothing but both property binding & event binding applied together. Property Binding is one way from view to component. The event binding is one way from component to view. If we combine both we will get the Two-way binding.

- The ngModel directive is not part of the Angular Core library. It is part of the FormsModule library. You need to import the FormsModule package into your Angular module.

7. ngModelChange & Change Event

- NgModelChange is an Angular specific event, which we can use to listen for changes to the user input. It is the @Output property of the ngModel directive, Hence we need to use it along with it. ngModle raises the NgModelChange event, whenever the model changes. Another way to listen for change is to use the change DOM event.

Ex -
Name:
<input type="text" name="name" ngModel (ngModelChange)="nameChanged($event)">

nameChanged is the handler function, which we need to define in the component class. We can access the new value by using the $event as an argument to the handler function.

//Component
nameChanged(arg) {
  console.log("modelchanged " + arg);
}

* Change Event
-The (change) is a DOM event fires when changes to the form fields like <input>, <select>, and <textarea> is committed by the user.

This event fires when

- user changes the input & moves the focus away from the text box (blur event)
- On <select> it fires when the user selects a new option either by a mouse click or using a keyboard.
- Fires when the state of a check box or radio button change due to users action

* NgModelChange Vs Change
- NgModelChange is Angular specific event. Change is a DOM Event and has nothing to do with the Angular.

- We must use the ngModelChange along with the ngModel directive. You can use change event on <input>, <select>, and <textarea> form elements.

- ngModelChange event passes new value. Change event passes event parameter, Use the target.value to access the new value.

- ngModelChange will trigger with each input change. Change event fires when you remove the focus from input text after changing the content.


8. Adding Child Component in Angular
https://www.tektutorialshub.com/angular/angular-adding-child-component/

- A Component, directive, pipes cannot be part of more than one module.


* Directives
https://www.tektutorialshub.com/angular/angular-directives/
- The Angular directive helps us to manipulate the DOM. You can change the appearance, behavior, or layout of a DOM element using the directives. They help you to extend HTML.

1.Angular Directives
- The Angular directives are classified into three categories based on how they behave.  
1. Component, 
- Components are special directives in Angular.

2. Structural (ngFor, ngIf, ngSwitch) and 
- Structural directives can change the DOM layout by adding and removing DOM elements. All structural Directives are preceded by Asterix symbol.

3. Attribute Directives (ngModel, ngClass, ngStyle)
i) ngModel - The ngModel directive is used the achieve the two-way data binding.
ii) ngClass - The ngClass is used to add or remove the CSS classes from an HTML element. Using the ngClass one can create dynamic styles in HTML pages
iii) ngStyle - ngStyle is used to change the multiple style properties of our HTML elements. We can also bind these properties to values that can be updated by the user or our components.

2.ngFor 
https://www.tektutorialshub.com/angular/angular-ngfor-directive/

----incomplete-----

3.ngSwitch
4.ngIf
5.ngClass
6.ngStyle
7.ngFor Trackby
8.Custom Directive

* Pipes
- The Angular pipes are used to Transform the Data. For Example, the Date pipe formats the date according to locale rules. We can pass arguments to pipe and chain pipes. The Angular also allows us to create the Custom Pipe

1. Angular Pipes
2. Angular Custom Pipes
3. Date Pipe
4. Async Pipe
5. KeyValue Pipe
6. Using Pipes in Components & Services

* Component Communication
- Parent Component communicates with the child component using the @Input Annotation. The child components detect changes to these Input properties using OnChanges life Cycle hook or with a Property Setter.

1.Passing data to child component 
2.Passing Data to Parent Component

* Component Life Cycle Hook
- The life cycle hooks are the methods that angular invokes on directives and components as it creates, changes, and destroys them. Using life-cycle hooks we can fine-tune the behavior of our components during creation, update, and destruction.

1.Component Life Cycle
2.OnInit & OnDestroy
3.Onchanges
4.DoCheck

* Angular Forms

1.Angular Forms Tutorial: Fundamental & Concepts
2.Template Driven Forms in Angular
3.Set Value in Template Driven forms in Angular
4.Reactive Forms in Angular
5.FormBuilder in Reactive Forms
6.SetValue & PatchValue in Angular
7.StatusChanges in Angular Forms
8.ValueChanges in Angular Forms
9.FormControl
10.FormGroup
11.FormArray Example
12.Build Dynamic or Nested Forms using FormArray
13.SetValue & PatchValue in FormArray
14.Select Options Dropdown

* Services & Dependency Injection
- Services allow us to create reusable code and use it every component that needs it. The Services can be injected into components and other services using the dependency injection system. The dependencies are declared in the Module using the Provider’s metadata. The Angular creates a tree of injector & Providers that resembles the Component Tree. This is called the hierarchical pattern.

1.Services
2.Dependency injection
3.Injector, @Injectable & @Inject
4.Providers
5.Hierarchical Dependency Injection

* Angular Forms Validation

1.Validations in Reactive Forms in Angular
2.Custom Validator in Reactive Forms
3.Passing Parameter to Custom Validator in Reactive Forms
4.Inject Service into Custom Validator
5.Validation in Template Driven Forms
6.Custom Validator in Template Driven Forms
7.Angular Async Validator
8.Cross Field Validation
9.Adding Validators Using SetValidators

*  HTTP 
- The newly designed HttpClient Module allows us to query the Remote API source to get data into our Application. It requires us to Subscribe to the returned response using RxJs observables.

1.Angular HTTP Client Tutorial
2.HTTP GET Example
3.HTTP POST Example
4.Passing URL Parameters (Query strings)
5.HTTP Headers Example
6.HTTP Interceptor


* Angular Router
- The Router module handles the navigation & Routing in Angular. The Routing allows you to move from one part of the application to another part or one View to another View. 

1. Routing and Navigation in Angular
2. Location Strategies in Angular Router
3. Passing Parameters to Route
4. Child Routes / Nested Routes
5.Passing Optional (Query) Parameters to a route
6.Navigation between Routes
7.Angular Route Guards
8.CanActivate Guard
9.CanActivateChild Guard
10.CanDeactivate Guard
11.Angular Resolve Guard
12.Angular Pass data to route
13.RouterLinkActive
14.Router Events

* Angular Module
- The Angular Modules help us to organize our code into manageable parts or block. Each block implements a specific feature. The Components, Templates, Directives, Pipes, and Services, which implements that feature become part of the module.

1.Introduction to Angular Modules
2.Routing Between Angular Modules
3.Angular folder structure: Best Practices
4.Lazy Loading in Angular
5.Preloading Strategy
6.CanLoad Guard

* Advanced Components

1.Ng-Content & Content Projection in Angular
2.Angular @input, @output & EventEmitter
3.Template Reference Variable in Angular
4.ng-container in Angular
5.ng-template & TemplateRef in angular
6.ngtemplateoutlet in angular
7.HostBinding & HostListener
8.ViewChild, ViewChildren & QueryList
9.ElementRef
10.Renderer2
11.ContentChild & ContentChildren
12.AfterViewInit, AfterViewChecked, AfterContentInit & AfterContentChecked

* Observable in Angular

1.Angular Observable Tutorial
2.Create Observable from a string, array. object, collection
3.Observable from events using fromEvent
4.Observable pipe
5.Map Operator
6.Filter Operator
7.Tap Operator
8.SwitchMap
9.MergeMap
10.ConcatMap
11.ExhaustMap
12.take, takeUntil, takeWhile, takeLast
13.First, last & Single
14.Skip, SkipWhile, SkipUntil & SkipLast
15.Scan & Reduce
16.DebounceTime & Debounce
17.Delay & DelayWhen
18.ThrowError
19.CatchError
20.ReTry & ReTryWhen
21.Unsubscribe from an observable

* Styling the Application

- The Angular uses several different ways to style the Application. You can style the app globally and then override it locally in the component very easily. The component styles have local scope, which is achieved using the various View Encapsulation strategies. Learn all these in the section

1.Angular Global Styles
2.View Encapsulation
3.Style binding in Angular
4.Class Binding in Angular
5.Component Styles
6.How to Install & Use Angular FontAwesome
7.How to Add Bootstrap to Angular

* Others
1.Location Service

* Configuration
- The apps usually need some sort of Run-time configuration information like URL endpoint etc, which it needs to load at startup. Also, different environments like development, production & testing require different environments, etc.

1.How to use APP_INITIALIZER
2.Run time configuration
3.Environment Variables

*  Handling Errors
- We handle errors by setting up a Global Error handler or custom error handler. Also,.whenever the error occurs in an HTTP operation, the Angular wraps it in an httpErrorResponse Object. Learn how to handle the HTTP Errors also.

1.Error Handling in Angular
2.HTTP Error Handling

* Angular CLI

1.Angular CLI Tutorial
2.Upgrading Angular App to the latest version
3.Multiple App in One Project

* SEO & Angular

- You need to set up Title & Meta Tags for each page. Ensure that the search engines can crawl and read your page. Set the correct Canonical URL for each page etc.

1.Title Service Example
2.Dynamic Title based on Route
3.Meta Service
4.Dynamic Meta Tags
5.Canonical URL
6.Lazy Load Images in Angular

* Angular Universal

The following Angular Universal Tutorial explains how to achieve Server Side Rendering using Angular Universal. The rendering the App on the server side makes it load quickly and also ensures that the search engines can crawl the content

1. Server-Side Rendering Angular Universal Tutorial

* Building & Hosting

1. Requested URL Not found on this server

* Angular Resources

1.Angular Examples & Projects
2.The Angular Learning Resources

* Angular how-to guides

1.How to get the current Route
2.ExpressionChangedAfterItHasBeenCheckedError in Angular
3.Angular CLI Check Version

* Module Loaders

The Angular application can use either SystemJs or Webpack module loader. We will demonstrate how to make use of both the Loader by building a small application.

1.Create Angular Application using SystemJS
2.Create Angular Application using Webpack
