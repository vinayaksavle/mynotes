Angular Revision Notes

* Angular Versions

Angular 9
- The Angular 9 is released on 06.02.2020. The Angular 9 is a major release. This release switches to ivy compiler and runtime by default. The ivy brings smaller bundle sizes, faster & better testing debugging, Improved type checking, build times, etc
- The Ivy compiler: The default use of the Ivy compiler is the most important feature of Angular 9, Ivy is what actually designed to solve the major problems of Angular i.e the performance and large file size

* Components
- The Component is the main building block of an Angular Application. A Component contains the definition of the View and the data that defines how the View looks and behaves.  The Angular Components are plain javascript classes and defined using @component Decorator. This Decorator provides the component with the View to display & Metadata about the class

- The Component passes the data to the view using a process called Data Binding. This is done by Binding the DOM Elements to component properties. Binding can be used to display component class property values to the user, change element styles, respond to a user event, etc.

1. Introduction to Angular Components

	* Features of Angular
	- Two-Way Data Binding
	- Powerful Routing Support
	- Expressive HTML (Enables us to use programming constructs like if conditions, for loops, etc.(*ngIf,*ngFor) to render and control how the HTML pages)
	- Modular by Design
	- Built-in Back End Support
	- Active Community
	
	* Key differences between AngularJs & Angular
	- Support for ES6
	- Components are new controllers
	- Directives (Replaced ng-repeat & ng-if with *ngFor & *ngIf * indicates as a structural directive )
	- $scopes are out (AngularJS used to run a dirty checking on the scope objects to see if any changes occurred. The Angular is using zone.js to detect changes. Zone.js apply patches on all the global asynchronous operations like click event, timer events, HTTP requests, etc. It then intimates the Angular, whenever the changes occur in Angular Application. The Angular then runs the change detection for the entire application)
	- Filters are renamed to Pipes
	- Mobile Support (AngularJS was not built with mobile support in mind. Angular designed with mobile development in mind.)

- Angular currently has following class decorators
1.@Component
2.@Directive
3.@Injectable
4.@NgModule
5.@Pipe

- Module Loaders (The later versions of Angular comes bundled with the Webpack module loader. Module loader takes a group of modules with their dependencies and merges them into a single file in the correct order. This process is called as Module bundling.)

- .editorconfig: This is the configuration file for the Visual Studio code editor. EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs.
- .gitignore: Git configuration to make sure autogenerated files are not committed to source control.
- angular.json: This is the configuration file for Angular CLI. The older versions of the Angular used the file angular-cli.json
- browserslist: Ensures the compatibility of the Angular app with different browsers.
- karma.conf.js: The Configuration file for the karma test runner.
- package.json: The package.json is an npm configuration file, that lists the third-party packages that your project depends on. We also have package-lock.json
- README.md: The Read me file
- tsconfig.json, tsconfig.app.json & tsconfig.spec.json are Typescript configuration files. The tsconfig.json is the Typescript compiler configuration file. This file specifies the compiler options required for the Typescript to compile (transpile) the project. The tsconfig.app.json is used for compiling the code, while tsconfig.spec.json for compiling the tests
- tslint.json: tslint is a static code analysis tool. We use this to check Typescript code quality. To check if TypeScript source code complies with coding rules. TSLint checks your TypeScript code for readability, maintainability, and functionality errors
- e2e: This folder contains the files required for end to end tests by protractor. Protractor allows us to test our application against a real browser.
- node_modules: All our external dependencies are downloaded and copied here by NPM Package Manager.
- src: This where our application lives.
- polyfills.ts: Different browsers have different levels of support of the web standards. Polyfills help normalize those differences. 
- test.ts: This is the main entry point for your unit tests. 

- Webpack is a bundler. it scans our application looking for javascript files and merges them into one ( or more) big file. Webpack has the ability to bundle any kind of file like JavaScript, CSS, SASS, LESS, images, HTML, & fonts, etc.
- angular.json: The Angular finds out the entry point from the configuration file angular.json. This file is located in the root folder of the project. 
- platformBrowserDynamic is the module, which is responsible for loading the Angular application in the desktop browser.

- We use ng build to build our app. Open the command prompt and run the command. This will build and copy the output files to the dist folder
- Use ng build --prod to build and distribute the app for production. For testing/debugging use ng build. The production build optimizes, minimize and uglify the code.
- Now open the dist and open the index.html. You can see that the compiler included five script files. They are runtime, polyfills, styles, vendor, & main. All these files have two versions one is es5 & the other one es2015. Since the Angular 7, we have new feature called conditional polyfill loading. Now Angular builds two script files, one for es2015 & another for es5. The es2015 (es6) is for modern browser and es5 is older browsers, which do not support the new features of es2015.

Note the nomodule attribute, which tells the modern browser to ignore the script and do not load it. Hence es5 scripts are not loaded in the modern browsers. These files are added by the Webpack module loader.
- runtime.js: Webpack runtime file
- polyfills.js – Polyfill scripts for supporting the variety of the latest modern browsers
- styles.js – This file contains the global style rules bundled as javascript file.
- vendor.js – contains the scripts from the Angular core library and any other 3rd party library.
- main.js – code of the application.

* What is Webpack?
Webpack is a bundler. it scans our application looking for javascript files and merges them into one ( or more) big file. Webpack has the ability to bundle any kind of file like JavaScript, CSS, SASS, LESS, images, HTML, & fonts, etc.

- The entry point of our application is main.ts. You will find it under the src folder.

* What is platformBrowserDynamic
platformBrowserDynamic is the module, which is responsible for loading the Angular application in the desktop browser.

* Building blocks of the Angular Component
- Template (View) - The template defines the layout of the View and defines what is rendered on the page.  Without the template,  there is nothing for Angular to render to the DOM.

- Class
The class is the code associated with Template (View). The Class is created with the Typescript, but you can also use javascript directly in the class. Class Contains the Properties & Methods. The Properties of a class can be bind to the view using Data Binding.

- Metadata
Metadata Provides additional information about the component to the Angular. Angular uses this information to process the class. The Metadata is defined with a decorator.

- @Component decorator
A class becomes a Component when Component Decorator is used. A Decorator is always prefixed with @. The Decorator must be positioned immediately before the class definition. We can also build our own decorators. The decorators are Similar to attributes in C#

2. Data Binding in Angular

- Data binding is a technique, where the data stays in sync between the component and the view. Whenever the user updates the data in the view, Angular updates the component. When the component gets new data, the Angular updates the view.

- The data binding in Angular can be broadly classified into two groups.
i) One way binding
- In one way binding data flows from one direction. Either from view to component or from component to view.

* From Component to View
To bind data from component to view, we make use of Interpolation & Property Binding.

- Interpolation - Interpolation allows us to include expressions as part of any string literal, which we use in our HTML. The Angular uses the {{ }} (double curly braces) in the template to denote the interpolation. The content inside the double braces is called Template Expression.
Syntax: {{ templateExpression }}

- Property binding - The Property binding allows us to bind HTML element property to a property in the component. You can set the properties such as class, href, src, textContent, etc using property binding. You can also use it to set the properties of custom components or directives (properties decorated with @Input).
Syntax: [binding-target]=”binding-source”
<button [disabled]="isDisabled">I am disabled</button>

- Attribute binding
Sometimes there is no HTML element property to bind to. The examples are aria (accessibility) Attributes & SVG. In such cases, you can make use of attribute binding.
Syntax: <button [attr.aria-label]="closeLabel" (onclick)="closeMe()">X</button>
Accessible Rich Internet Applications (ARIA) is a set of attributes that define ways to make web content and web applications (especially those developed with JavaScript) more accessible to people with disabilities.
MDN — Mozilla Developer Network

* From View to Component
- Event Binding - Event binding allows us to bind events such as keystroke, clicks, hover, touch, etc to a method in component. 
Syntax: (target-event)="TemplateStatement"

- Two Way binding
Two-way binding means that changes made to our model in the component are propagated to the view and that any changes made in the view are immediately updated in the underlying component. The two-way binding uses the special syntax known as a banana in a box [()]
Syntax: <someElement [(someProperty)]="value"></someElement>.

- ngModel
The Angular uses the ngModel directive to achieve the two-way binding on HTML Form elements. It binds to a form element like input, select, selectarea. etc. The ngModel directive is not part of the Angular Core library. It is part of the @angular/forms. You need to import the FormsModule package into your Angular module.

3. Interpolation in Angular
- Interpolation allows us to include expressions as part of any string literal, which we use in our HTML. The Angular uses the {{ }} (double curly braces) in the template to denote the interpolation. The syntax is as shown below.
Ex - {{ templateExpression }}

- The content inside the double braces is called Template Expression.

- The Template expression should not change the state of the application. The Angular uses it to read the values from the component and populate the view. If the Template expression changes the component values, then the rendered view would be inconsistent with the model

It means that you cannot make use of the following

Assignments (=, +=, -=, …)
Keywords like new, typeof, instanceof, etc
Chaining expressions with ; or ,
The increment and decrement operators ++ and --
bitwise operators such as | and &

- If you want to bind the expression that is other than a string (for example – boolean), then Property Binding is the best option.

- Interpolation and property binding can set only properties, not attributes. For Attributes use attribute binding.

- You can use interpolation to invoke a method in the component, Concatenate two string, perform some mathematical operations or change the property of the DOM element like color, etc.

Ex - 
{{getTitle()}}
<p>{{ 'Hello & Welcome to '+ ' Angular Interpolation '}}</p>
<p>Welcome {{firstName}}, {{lastName}}</p>

- You can also use the template reference variable. The following example creates a template variable #name to an input box. You can use it get the value of the input field {{name.value}}
Ex - 
<label>Enter Your Name</label>
<input (keyup)="0" #name>
<p>Welcome {{name.value}} </p>

- The Angular updates the view, when it runs the change detection. The change detection runs only in response to asynchronous events, such as the arrival of HTTP responses, raising of events, etc. In the example above whenever you type on the input box, it raises the keyup event. It forces the angular run the change detection, hence the view gets the latest values.

- You can make use of Angular Pipes to transform the expression result. Like converting to an uppercase, date formats, adding currency symbols, etc
Ex - <p>uppercase pipe: {{title | uppercase}}</p>

- The Safe Navigation Operator is also known as the "Elvis Operator". This operator is very useful to protect against null and undefined values in property paths. 

Ex - 
In the first case, I am trying to retrieve the data from the object path "data.firstName" using interpolation. Here, I am not defining the data so Angular parsing throws runtime null-reference exceptions. Here, our application crashes when the data is null.
<div> Hi, This Text will generate error!!! {{data.firstName}} </div>  

Now, Using the Safe Navigation Operator. So, it is protecting against the null exception.
<div> Hi, This Text will not generating error Console!!! {{data?.firstName}} </div> 

- Alternative of Safe Navigation Operator
1. The same behavior can be achieved using *ngIf Directive. In the following example, I have hidden the text when the "data" is null. 
<div *ngIf="data"> Hi, This Text will not generating error Console!!! {{data.firstName.text}} - *ngIf Example </div> 

2. The second alternative is to use "&& operator". Here, we first check for "data". When it is not null, then Angular will populate the data.firstname, else null.
<div> Hi, This Text will not generating error Console!!! {{ data && data.firstName.text}} </div>  

- The non-null assertion operator
Typescript enforces the strict null checking if you enable the --strictNullChecks flag in your tsconfig.json. Under strict null check any variable not defined or null results in a compiler error. The type checker also throws an error if it can’t determine whether a variable will be null or undefined at runtime.

- You can use the non-null assertion operator to inform typescript not to throw any compile errors. Note that it is a compile-time feature & not runtime.
Ex - The item's name is: {{item!.name}}

4. Property Binding in Angular
https://www.tektutorialshub.com/angular/property-binding-in-angular/

- Property binding is one way from component to view. It lets you set a property of an element in the view to property in the component. You can set the properties such as class, href, src, textContent, etc using property binding. You can also use it to set the properties of custom components or directives (properties decorated with @Input).

- The Property Binding uses the following Syntax

[binding-target]=”binding-source”
 
The binding-target (or target property) is enclosed in a square bracket []. It should match the name of the property of the enclosing element.

Binding-source is enclosed in quotes and we assign it to the binding-target. The Binding source must be a template expression. It can be property in the component, method in component, a template reference variable or an expression containing all of them.

Whenever the value of Binding-source changes, the view is updated by the Angular.

Ex - 
<h1 [innerText]="title"></h1>
<h2>Example 1</h2>
<button [disabled]="isDisabled">I am disabled</button>
 
import { Component } from '@angular/core';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title="Angular Property Binding Example"
  
  //Example 1
  isDisabled= true;
}

- Property Binding is one way
Property binding is one way as values go from the component to the template. When the component values change, the Angular updates the view. But if the values changes in the view, the Angular does not update the component.

- The brackets, [], tell Angular to evaluate the template expression. If you omit the brackets, Angular treats the expression as a constant string and initializes the target property with that string:

- The property binding binds to the properties of DOM elements, components, and directives and not to HTML attributes. The angular has a special syntax for attribute binding.

- The Angular has a special syntax for class, styles & attribute binding.The classes & styles are special because they contain a list of classes or styles. The bindings need to be more flexible in managing them. Hence we have a class & style binding.

The Property bindings cover all the properties, but there are certain HTML attributes that do not have any corresponding HTML property. Hence we have attribute binding

* Class binding
You can set the class in the following ways. Click on the links to find out more

i) ClassName Property binding
Ex -You can also add more than one class by separating them using the
<div [className]="'red size20'">Test</div>

ii) Set the Class attribute with class binding
Ex - To dynamically or conditionally bind a class, First create a variable in the component class as shown below.
<div [class.red]="hasError" [class.size20]="hasError">Test</div>

iii) ngClass directive
You can also use the ngClass without a square bracket. In that case, the expression is not evaluated but assigned directly to the class attribute. We also need to remove the double quote around the expression as shown below.

Ex - 
<div class="row">     
    <div ngClass='red size20'>Red Text with Size 20px </div> 
</div>

NgClass with Array
<element [ngClass]="['cssClass1', 'cssClass2']">...</element>

* Style Binding
i) Style Property Binding
Ex - 
<p [style.color]="getColor()" 
   [style.font-size.px]="'20'"      
   [style.background-color]="status=='error' ? 'red': 'blue'">
   paragraph with multiple styles
</p>

ii) ngStyle directive
Ex - 
<input [(ngModel)]="size" /> 
<div [ngStyle]="{'font-size.px': size}">Change my size</div>

* Attribute Binding
Sometimes there is no HTML element property to bind to. The examples are aria (accessibility) Attributes & SVG. In such cases, you can make use of attribute binding. The attribute syntax starts with attr followed by a dot and then the name of the attribute as shown below.

Ex - 

<button [attr.aria-label]="closeLabel" (onclick)="closeMe()">X</button>

<td [attr.colspan]="2">Col 1 & 2</td> 
<td bind-attr.colspan = "getColspan()">Col 2 & 3 </td>

// component TS
closeLabel="close";
getColspan() {
   return "2"
}

* Property Binding Vs Interpolation

- Everything that can be done from interpolation can also be done using the Property binding. Interpolation is actually a shorthand for binding to the textContent property of an element.
Ex - 
For example the following interpolation
<h1> {{ title }} </h1>
Is same as the following Property binding
<h1 [innerText]="title"></h1>


- Interpolation requires the expression to return a string. If you want to set an element property to a non-string data value, you must use property binding.

5. Event Binding in Angular
https://www.tektutorialshub.com/angular/event-binding-in-angular/

- Event binding allows us to bind events such as keystroke, clicks, hover, touche, etc to a method in component. It is one way from view to component. By tracking the user events in the view and responding to it, we can keep our component in sync with the view. For Example, when the user changes to an input in a text box, we can update the model in the component, run some validations, etc. When the user submits the button, we can then save the model to the backend server.

Ex - 
Angular event binding syntax consists of a target event name within parentheses on the left of an equal sign, and a quoted template statement on the right.

The following event binding listens for the button’s click events, calling the component’s onSave() method whenever a click occurs

<button (click)="onSave()">Save</button>

click - Target Event
onSave - Template Statement

- Unlike the Property Binding & Interpolation, where we use the template expression is used, in case of event binding we use template statement.

The Template statement can change the state of the component. Angular runs the change detection and updates the view so as to keep it in sync with the component.

- Instead of parentheses, you can also use the on- syntax as shown below.
Ex - 
<button on-click="clickMe()">Click Me</button>

- $event Payload
DOM Events carries the event payload. I.e the information about the event. We can access the event payload by using $event as an argument to the handler function.

Ex - 
<input (input)="handleInput($event)">
<p>You have entered {{value}}</p>

value=""
handleInput(event) {
  this.value=event.target.value;
}

- The properties of a $event object vary depending on the type of DOM event. For example, a mouse event includes different information than an input box editing event.

Remember you need to use the variable as $event in the Template statement. Example handleInput($event). Otherwise, it will result in an error

- We can also make use of the template reference variable to pass the value instead of $event.

Ex -
<h2>Template Reference Variable</h2>
<input #el (input)="handleInput1(el)">
<p>You have entered {{val}}</p>
 
val="";
handleInput1(element) {
  this.val=element.value;
}

- We use keyup/keydown events to listen for keystrokes. The following example does that
Ex-
<input (keyup)="value1=$event.target.value">
<p>You entered {{value1}}</p>

But Angular also offers a feature, where it helps to filter out certain keys. For Example, if you want to listen only to the enter keys you can do it easily
Ex-
<input (keyup.enter)="value2=$event.target.value">
<p>You entered {{value2}}</p>

On pressing enter key it updates the value3 variable and on escape clears the variable.
Ex - 
<input (keyup.enter)="value3=$event.target.value" (keyup.escape)="$event.target.value='';value3=''">
<p>You entered {{value3}}</p>

You can also listen for the key combination
Ex -
<input (keyup.control.shift.enter)="value4=$event.target.value">
<p>You entered {{value4}}</p>

6. Two way Binding & ngModel in Angular
https://www.tektutorialshub.com/angular/ngmodel-two-way-data-binding-in-angular/

- Two way data binding means that changes made to our model in the component are propagated to the view and that any changes made in the view are immediately updated in the underlying component data.

- The two way data binding nothing but both property binding & event binding applied together. Property Binding is one way from view to component. The event binding is one way from component to view. If we combine both we will get the Two-way binding.

- The ngModel directive is not part of the Angular Core library. It is part of the FormsModule library. You need to import the FormsModule package into your Angular module.

7. ngModelChange & Change Event

- NgModelChange is an Angular specific event, which we can use to listen for changes to the user input. It is the @Output property of the ngModel directive, Hence we need to use it along with it. ngModle raises the NgModelChange event, whenever the model changes. Another way to listen for change is to use the change DOM event.

Ex -
Name:
<input type="text" name="name" ngModel (ngModelChange)="nameChanged($event)">

nameChanged is the handler function, which we need to define in the component class. We can access the new value by using the $event as an argument to the handler function.

//Component
nameChanged(arg) {
  console.log("modelchanged " + arg);
}

* Change Event
-The (change) is a DOM event fires when changes to the form fields like <input>, <select>, and <textarea> is committed by the user.

This event fires when

- user changes the input & moves the focus away from the text box (blur event)
- On <select> it fires when the user selects a new option either by a mouse click or using a keyboard.
- Fires when the state of a check box or radio button change due to users action

* NgModelChange Vs Change
- NgModelChange is Angular specific event. Change is a DOM Event and has nothing to do with the Angular.

- We must use the ngModelChange along with the ngModel directive. You can use change event on <input>, <select>, and <textarea> form elements.

- ngModelChange event passes new value. Change event passes event parameter, Use the target.value to access the new value.

- ngModelChange will trigger with each input change. Change event fires when you remove the focus from input text after changing the content.


8. Adding Child Component in Angular
https://www.tektutorialshub.com/angular/angular-adding-child-component/

- A Component, directive, pipes cannot be part of more than one module.


* Directives
https://www.tektutorialshub.com/angular/angular-directives/
- The Angular directive helps us to manipulate the DOM. You can change the appearance, behavior, or layout of a DOM element using the directives. They help you to extend HTML.

1.Angular Directives
- The Angular directives are classified into three categories based on how they behave.  
1. Component, 
- Components are special directives in Angular.

2. Structural (ngFor, ngIf, ngSwitch) and 
- Structural directives can change the DOM layout by adding and removing DOM elements. All structural Directives are preceded by Asterix symbol.

3. Attribute Directives (ngModel, ngClass, ngStyle)
i) ngModel - The ngModel directive is used the achieve the two-way data binding.
ii) ngClass - The ngClass is used to add or remove the CSS classes from an HTML element. Using the ngClass one can create dynamic styles in HTML pages
iii) ngStyle - ngStyle is used to change the multiple style properties of our HTML elements. We can also bind these properties to values that can be updated by the user or our components.

2.ngFor 
https://www.tektutorialshub.com/angular/angular-ngfor-directive/

- ngFor exposes several values, which help us to fine-tune display. We assign these values to the local variable and use it in our template

The list of exported values provided by ngFor directive

i)index: number: The zero-based index of the current element in the collection.
Ex -

<tr *ngFor="let movie of movies; let i=index;">
    <td> {{i}} </td>
</tr>

ii) count: number: The total no of items in the collection
first: boolean: True when the item is the first item in the collection.
last: boolean: Is set to True, when the item is the last item in the collection.
even: boolean: True when the item has an even index in the collection.
odd: boolean: is set to True when the item has an odd index in the collection.
Ex -

<tr *ngFor="let movie of movies; let i=index; let o= odd; let e=even;"
[ngClass]="{ odd: o, even: e }">

- Track By clause allows you to specify your own key to identify objects.
Angular uses the object identity to compare the elements in the collection to the DOM nodes. Hence when you add an item or remove an item, the Angular will track it and update only the modified items in the DOM. It does not render the entire list.

But this fails if we update the list from the back end server. That is because the retrieved objects cannot be compared with the existing objects in the list as the reference has changed. The Angular to simply remove these elements from DOM and recreates the new elements from the new data. This has a huge performance implication.

Ex -
In our movie list example, let us make the title of the movie as the identifier.

<tr *ngFor="let movie of movies; trackBy:trackByFn;">
    <td>{{movie.title}}</td>
    <td>{{movie.director}}</td>
    <td>{{movie.cast}}</td>
    <td>{{movie.releaseDate}}</td>
</tr>

  trackByFn(index, item) {
    return item.title;
  }

3.ngSwitch
https://www.tektutorialshub.com/angular/angular-ngswitch-directive/

- ngSwitchCase is bound to an inner_element, which we must place inside the container_element. We use * (Asterix symbol), because it is a structural directive. We also assign a match_expression, which Angular evaluates at runtime. The Angular displays the inner_element only when the value of the match_expression matches the value of the switch_expression else it is removed from the DOM.

- If there is more than one match, then it displays all of them.
Note that the ngSwitchCase does not hide the element, but removes them from the DOM.

-  If none of the ngSwitchCase match_expression matches the switch_expression, then the angular displays the element attached to the ngSwitchDefault

- You are free to add more than one ngSwitchDefault directive. Angular displays all of them.

- Angular uses loose equality checks to compare the ngSwitchCase expression with the ngSwitch expression. This means that the empty string "" matches 0.

Ex -
<div class="card-body">
    Input string : <input type='text' [(ngModel)]="num" />
 
    <div [ngSwitch]="num">
      <div *ngSwitchCase="'1'">One</div>
      <div *ngSwitchCase="'2'">Two</div>
      <div *ngSwitchCase="'3'">Three</div>
      <div *ngSwitchCase="'4'">Four</div>
      <div *ngSwitchCase="'5'">Five</div>
      <div *ngSwitchDefault>This is Default</div>
    </div>
</div>

4.ngIf

- We bind the *ngIf to an expression (a condition in the above example). The expression is then evaluated by the ngIf directive. The expression must return either true or false.

- If the expression evaluates to false then the Angular removes the entire element from the DOM. If true it will insert the element into the DOM.

* Hidden attribute Vs ngIf

- ngIf does not hide the DOM element. It removes the entire element along with its subtree from the DOM. It also removes the corresponding state freeing up the resources attached to the element. hidden attribute does not remove the element from the DOM. But just hides it.

- ngIf else
When the condition evaluates to false, then the ng-template with the name #elseBlock is rendered by the ngIf Directive.
Ex - 
<div *ngIf="condition; else elseBlock">
    content to render, when the condition is true 
</div>
 
<ng-template #elseBlock>
    content to render, when the condition is false 
</ng-template>

- ngIf then else
Ex - 
<div *ngIf="condition; then thenBlock else elseBlock"> 
    This content is not shown
</div>
 
<ng-template #thenBlock>
    content to render when the condition is true.
</ng-template>
 
<ng-template #elseBlock>
    content to render when condition is false.
</ng-template>


5.ngClass
- The ngClass directive adds and removes CSS classes on an HTML element. The syntax of the ngClass is as shown below.

- NgClass with a String
If you want to assign multiple classes, then separate each class with space as shown below.
Ex -
<element [ngClass]="'cssClass1 cssClass2'">...</element>

- You can also use the ngClass without a square bracket. In that case, the expression is not evaluated but assigned directly to the class attribute. We also need to remove the double quote around the expression as shown below.

<div class="row">     
    <div ngClass='red size20'>Red Text with Size 20px </div> 
</div>

- NgClass with Array
You can achieve the same result by using an array instead of a string as shown below.
Ex -
<element [ngClass]="['cssClass1', 'cssClass2']">...</element>

- NgClass with Object
You can also bind the ngClass to an object. Each property name of the object acts as a class name and is applied to the element if it is true.
Ex -
<element [ngClass]="{'cssClass1': true, 'cssClass2': true}">...</element>


6.ngStyle
-The Angular ngStyle directive allows us to set the many inline style of a HTML element using an expression. The expression can be evaluated at run time allowing us to dynamically change the style of our HTML element.
Ex - <some-element[ngStyle]="{'font-size.em': '3'}">...</some-element>

<div> [ngStyle]="{'background-color':status === 'error' ? 'red' : 'blue' }"></<div>


7.ngFor Trackby
- Angular Trackby option improves the Performance of the ngFor if the collection has a large no of items and keeps changing.

- The ngFor will use the unique id returned by the trackBy function to track the items. Hence even if we refresh the data from the back end, the unique id will remain the same and the list will not be rendered again.

- The trackBy takes a function that has two arguments: index and the current item. It must return a id that uniquely identifies the item. The following example returns the title as the unique id.
Ex - 
trackByFn(index, item) {
    return item.title;
  }
  
  <li *ngFor="let movie of movies; let i=index;trackBy: trackByFn;">
  
- Trackby multiple fields
Ex: 
<li *ngFor="let movie of movies; let i=index;trackBy: trackByFnMultipleFields;">

trackByFnMultipleFields(index, item) {
    return item.title + item.director;
  }

8.Custom Directive
-Components are directives with Template (or view). We know how to build Angular Components. Structural & Attribute directives do not have an associated view.

-Structural directives change the DOM layout by adding and removing DOM elements. All structural Directives are preceded by the Asterix (*) symbol.

-The Attribute directives can change the appearance or behavior of an element.

* Custom Attribute Directive
- We attach the attribute directive to an element, which we call the parent element. To change the properties of the parent element, we need to get the reference. Angular injects the parent element when we ask for the instance of the ElementRef in its constructor.

- ElementRef is a wrapper for the Parent DOM element. We can access the DOM element via the property nativeElement. The classList method allows us to add the class to the element.

Ex -
ttClass.directive.ts

import { Directive, ElementRef, Input, OnInit } from '@angular/core'
 
@Directive({
  selector: '[ttClass]',
})
export class ttClassDirective implements OnInit {
 
  @Input() ttClass: string;
 
  constructor(private el: ElementRef) {
  }
 
  ngOnInit() {
    this.el.nativeElement.classList.add(this.ttClass);
  }
 
}

.html
<button [ttClass]="'blue'">Click Me</button>

.css
.blue {
  background-color: lightblue;
}

* Custom Structural Directive
- Since, we are manipulating the DOM, we need ViewContainerRef and TemplateRef instances.

- We use the createEmbeddedView method of the ViewContainerRef to insert the template if the condition is true. The clear removes the template from the DOM.

Ex - 
import { Directive, ViewContainerRef, TemplateRef, Input } from '@angular/core';
 
@Directive({ 
  selector: '[ttIf]' 
})
export class ttIfDirective  {
 
  _ttif: boolean;
 
  constructor(private _viewContainer: ViewContainerRef,
            private templateRef: TemplateRef<any>) {
  }
 
 
  @Input()
  set ttIf(condition) {
    this._ttif = condition
    this._updateView();
  }
 
  _updateView() {
    if (this._ttif) {
      this._viewContainer.createEmbeddedView(this.templateRef);
    }
    else {
      this._viewContainer.clear();
    }
  }
 
}

import { Component } from '@angular/core';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title: string = "Custom Directives in Angular";
  show=true;
}

.html
<h1> {{title}} </h1>
 
Show Me
<input type="checkbox" [(ngModel)]="show">
 
<div *ttIf="show">
  Using the ttIf directive
</div>
 
<div *ngIf="show">
  Using the ngIf directive
</div>

- We use the * notation to tell Angular that we have a structural directive and we will be manipulating the DOM. It basically tells angular to inject the TemplateRef. To inject the templateRef, the Angular needs to locate the template. The * tells the Angular to locate the template and inject its reference as templateRef

https://www.tektutorialshub.com/angular/custom-directive-in-angular/

* Pipes
https://www.tektutorialshub.com/angular/angular-pipes/
- The Angular pipes are used to Transform the Data. For Example, the Date pipe formats the date according to locale rules. We can pass arguments to pipe and chain pipes. The Angular also allows us to create the Custom Pipe

1. Angular Pipes

- Angular Pipes takes data as input and formats or transform the data to display in the template. We use them to change the appearance of the data before presenting it to the user. The most common use case of pipes is displaying the dates in the correct format as per the user’s locale.
Ex -
toDate | date | uppercase
<p>medium : {{toDate | date:'medium'}} </p>


2. Angular Custom Pipes

- To create a Custom Pipe, first, You need to follow these steps

1. Create a pipe class
2. Decorate the class with @pipe decorator.
3. Give a name to the pipe in the name meta data of the @pipe decorator. We will use this name in the template.
4. The pipe class must implement the PipeTransform interface. The interfaces contain only one method transform.
5. The first parameter to the transform method is the value to be transferred. The transform method must transform the value and return the result. You can add any number of additional arguments to the transform method.
6. Declare the pipe class in the Angular Module (app.module.ts)
7. Use the custom pipe just as you use other pipes.

- import {Pipe, PipeTransform} from '@angular/core';
 
@pipe({
    name: 'tempConverter'
})
export class TempConverterPipe implements PipeTransform {
    transform(value: number, unit: string) {
        if(value && !isNaN(value)) {
            if (unit === 'C') {
                var temperature = (value - 32) /1.8 ;
                return temperature.toFixed(2);
            } else if (unit === 'F'){
                var temperature = (value * 1.8 ) + 32
                return temperature.toFixed(2);
            }
        }
        return;
    }
}

.html
<p> celsius : <input type="text" [(ngModel)]="celcius" /> 
       Fahrenheit : {{celcius | tempConverter:'F'}} </p>

3. Date Pipe

* There are two types formats options available

i) Pre defined Format
Ex - 
{{toDate | date:'short'}}	5/24/20, 3:40 PM

ii) Custom Format string
Ex - 
{{toDate | date:'dd/MM/yy HH:mm'}}         //May 24, 2020, 7:17:26 PM

4. Async Pipe
https://www.tektutorialshub.com/angular/angular-async-pipe/

- The async pipe allows us to subscribe to an Observable or Promise from the template and returns the value emitted. The async pipes subscribe to the observable when the component loads. It unsubscribes when the component gets destroyed. 

- ShareReplay - We use the shareReplay when you want subscribers to share the observable and access previously emitted values. i.e. the observable is subscribed only once and for every subsequent subscription, the previously received value is used.

---Read this article from somewhere else--- 


5. KeyValue Pipe
- The KeyValue Pipe converts given Object or Map into an array of key-value pairs. We can use this with the ngFor to loop through the object keys. The keyValue accepts the one argument compareFn, which we can use to set the custom sort to the pipe. 

Ex -
obj = [
    { key:a, value:789 },
    { key:b, value:446 },
    { key:c, value:123 },
  ];
  
<ul>
  <li *ngFor="let item of obj | keyvalue">
    {{item.key}} ---> {{item.value}}</li>
</ul>

- KeyValue pipe uses the key to sort the results array. You can see it from the above example. Even though our object was c,b & a it was sorts it as a,b,c. The keyValue pipe uses the defaultComparator to sort the result. It uses

i. Ascending Order if the keys are number
ii. Alphabetical Order if keys are strings
if keys are are of different types. then covert them to to their string values and use Alphabetical Order
iii. If key is a either Null or undefined, put then at the end of the sort.

- You can customize it by providing a custom sort function (compareFn) as the first argument to the keyValue pipe.

Syntax: compareFn (a: KeyValue, b: KeyValue) => number 

orderOriginal = (a: KeyValue<number,string>, b: KeyValue<number,string>): number => {
  return 0
}
  
orderbyValueAsc = (a: KeyValue<number,string>, b: KeyValue<number,string>): number => {
   return a.value > b.value ? -1 : (a.value > b.value) ? 0 : 1  
}
 
orderbyValueDsc = (a: KeyValue<number,string>, b: KeyValue<number,string>): number => {
  return a.value > b.value ? 1 : (a.value > b.value) ? 0 : -1  
}

<ul>
  <li *ngFor="let item of obj | keyvalue : orderbyValueAsc ">
    {{item.key}} ---> {{item.value}}</li>
</ul>



6. Using Pipes in Components & Services
- We usually use Angular Pipes in the template. But a pipe is nothing but a class with a method transform. Whether it is a built-in pipe or custom pipe, we can easily use it in an angular component or service.

- Using pipes in your code involves three simple steps

Import the pipe in Module
Inject pipe in the constructor
Use the transform method of the pipe

- constructor(private datePipe:DatePipe) {
  }
 
  ngOnInit() {
     this.toDate = this.datePipe.transform(new Date());
  }


* Component Communication
- Parent Component communicates with the child component using the @Input Annotation. The child components detect changes to these Input properties using OnChanges life Cycle hook or with a Property Setter.

1.Passing data to child component 

- In Angular, the Parent Component can communicate with the child component by setting its Property. To do that the Child component must expose its properties to the parent component. The Child Component does this by using the @Input decorator

In the Child Component

i) Import the @Input module from @angular/Core Library
ii) Mark those property, which you need data from parent as input property using @Input decorator

In the Parent Component

i) Bind the Child component property in the Parent Component when instantiating the Child

- The @Input Decorator is used to configure the input properties of the component. This decorator as also supports change tracking.

When you mark a property as input property, then the Angular injects values into the component property using Property Binding. The Property Binding uses the [] brackets. The Binding Target (Property of the child component) is placed inside the square brackets. The Binding source is enclosed in quotes. Property binding is one way from Component to the Target in the template

- Various ways to use @Input Decorator
i) Using the @Input decorator to decorate the class property

Ex - @Input() count: number;

ii) Using the input array meta data of the component decorator

Ex - @Component({
    selector: 'child-component',
    inputs: ['count'],
    template: `<h2>Child Component</h2>
    current count is {{ count }}`
	})
	
- Detecting the Input changes
assing the data to child component is not sufficient, the child Component needs to know when the input changes so that it can act upon it.

There are two ways of detecting when input changes in the child component in Angular

i) Using OnChanges LifeCycle Hook
- ngOnChanges is a lifecycle hook, which angular fires when it detects changes to data bound input property. This method receives a SimpeChanges object, which contains the current and previous property values. We can Intercept input property changes in the child component using this hook.

Ex -
import { Component, Input, OnChanges, SimpleChanges, SimpleChange  } from '@angular/core';
 
@Component({
    selector: 'child-component',
    template: `<h2>Child Component</h2>
               current count is {{ count }}
    `
})
export class ChildComponent implements OnChanges {
    @Input() count: number;
 
    ngOnChanges(changes: SimpleChanges) {
 
        for (let property in changes) {
            if (property === 'count') {
              console.log('Previous:', changes[property].previousValue);
              console.log('Current:', changes[property].currentValue);
              console.log('firstChange:', changes[property].firstChange);
            } 
        }
    }
}


ii) Using Input Setter
- We can use the property getter and setter to detect the changes made to the input property as shown below
Ex -
private _count = 0;

@Input()
set count(count: number) {
    this._count = count;
    console.log(count);
}
get count(): number { return this._count; }


2.Passing Data to Parent Component
There are three ways in which parent component can interact with the child component

i) Parent Listens to Child Event
ii) Parent uses Local Variable to access the child
iii) Parent uses a @ViewChild to get reference to the child component

- The Child Component exposes an EventEmitter Property. This Property is adorned with the @Output decorator. When Child Component needs to communicate with the parent it raises the event. The Parent Component listens to that event and reacts to it.

- To Raise an event, the component must declare an EventEmmitter Property. The Event can be emitted by calling the .emit() method

- Using the EventEmitter Property gives the components ability to raise an event. But to make that event accessible from parent component, you must decorate the property with @Output decorator


-In the child component

i) Declare a property of type EventEmitter and instantiate it
ii) Mark it with a @Output annotation
iii) Raise the event passing it with the desired data

-In the Parent Component

i) Bind to the Child Component using Event Binding and listen to the child events
ii) Define the event handler function

Ex - 
import { Component} from '@angular/core';
 
@Component({
  selector: 'app-root',
  template: `
        <h1>Welcome to {{title}}!</h1>
        <p> current count is {{ClickCounter}} </p>
        <child-component [count]=Counter (countChanged)="countChangedHandler($event)"></child-component>` ,
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Component Interaction';
  Counter = 5;
 
  countChangedHandler(count: number) {
    this.Counter = count;
    console.log(count);
  }
}
 
Child component
import { Component, Input, Output, EventEmitter  } from '@angular/core';
 
@Component({
    selector: 'child-component',
    template: `<h2>Child Component</h2>
               <button (click)="increment()">Increment</button>
               <button (click)="decrement()">decrement</button>
               current count is {{ count }}
    `
})
export class ChildComponent {
    @Input() count: number;
 
    @Output() countChanged: EventEmitter<number> =   new EventEmitter();
 
    increment() {
        this.count++;
        this.countChanged.emit(this.count);
      }
    decrement() {
        this.count--;
        this.countChanged.emit(this.count);
    }
}
 
- Parent Template can access the child component properties and methods by creating the template reference variable
Ex - 
<p> current count is {{child.count}} </p>
        <button (click)="child.increment()">Increment</button>
        <button (click)="child.decrement()">decrement</button>
        <child-component #child></child-component>

- The local variable approach is simple and easy. But it is limited because the parent-child wiring must be done entirely within the parent template. The parent component itself has no access to the child.

You can’t use the local variable technique if an instance of the parent component class must read or write child component values or must call child component methods.

- Injecting an instance of the child component into the parent as a @ViewChild is the another technique used by the parent to access the property and method of the child component
Ex - @ViewChild(ChildComponent) child: ChildComponent;


* Component Life Cycle Hook
- The life cycle hooks are the methods that angular invokes on directives and components as it creates, changes, and destroys them. Using life-cycle hooks we can fine-tune the behavior of our components during creation, update, and destruction.

https://www.tektutorialshub.com/angular/angular-component-life-cycle-hooks/

-

1.Component Life Cycle
2.OnInit & OnDestroy
3.Onchanges
4.DoCheck

* Angular Forms

1.Angular Forms Tutorial: Fundamental & Concepts
2.Template Driven Forms in Angular
3.Set Value in Template Driven forms in Angular
4.Reactive Forms in Angular
5.FormBuilder in Reactive Forms
6.SetValue & PatchValue in Angular
7.StatusChanges in Angular Forms
8.ValueChanges in Angular Forms
9.FormControl
10.FormGroup
11.FormArray Example
12.Build Dynamic or Nested Forms using FormArray
13.SetValue & PatchValue in FormArray
14.Select Options Dropdown

* Services & Dependency Injection
- Services allow us to create reusable code and use it every component that needs it. The Services can be injected into components and other services using the dependency injection system. The dependencies are declared in the Module using the Provider’s metadata. The Angular creates a tree of injector & Providers that resembles the Component Tree. This is called the hierarchical pattern.

1.Services
2.Dependency injection
3.Injector, @Injectable & @Inject
4.Providers
5.Hierarchical Dependency Injection

* Angular Forms Validation

1.Validations in Reactive Forms in Angular
2.Custom Validator in Reactive Forms
3.Passing Parameter to Custom Validator in Reactive Forms
4.Inject Service into Custom Validator
5.Validation in Template Driven Forms
6.Custom Validator in Template Driven Forms
7.Angular Async Validator
8.Cross Field Validation
9.Adding Validators Using SetValidators

*  HTTP 
- The newly designed HttpClient Module allows us to query the Remote API source to get data into our Application. It requires us to Subscribe to the returned response using RxJs observables.

1.Angular HTTP Client Tutorial
2.HTTP GET Example
3.HTTP POST Example
4.Passing URL Parameters (Query strings)
5.HTTP Headers Example
6.HTTP Interceptor


* Angular Router
- The Router module handles the navigation & Routing in Angular. The Routing allows you to move from one part of the application to another part or one View to another View. 

1. Routing and Navigation in Angular
2. Location Strategies in Angular Router
3. Passing Parameters to Route
4. Child Routes / Nested Routes
5.Passing Optional (Query) Parameters to a route
6.Navigation between Routes
7.Angular Route Guards
8.CanActivate Guard
9.CanActivateChild Guard
10.CanDeactivate Guard
11.Angular Resolve Guard
12.Angular Pass data to route
13.RouterLinkActive
14.Router Events

* Angular Module
- The Angular Modules help us to organize our code into manageable parts or block. Each block implements a specific feature. The Components, Templates, Directives, Pipes, and Services, which implements that feature become part of the module.

1.Introduction to Angular Modules
2.Routing Between Angular Modules
3.Angular folder structure: Best Practices
4.Lazy Loading in Angular
5.Preloading Strategy
6.CanLoad Guard

* Advanced Components

1.Ng-Content & Content Projection in Angular
2.Angular @input, @output & EventEmitter
3.Template Reference Variable in Angular
4.ng-container in Angular
5.ng-template & TemplateRef in angular
6.ngtemplateoutlet in angular
7.HostBinding & HostListener
8.ViewChild, ViewChildren & QueryList
9.ElementRef
10.Renderer2
11.ContentChild & ContentChildren
12.AfterViewInit, AfterViewChecked, AfterContentInit & AfterContentChecked

* Observable in Angular

1.Angular Observable Tutorial
2.Create Observable from a string, array. object, collection
3.Observable from events using fromEvent
4.Observable pipe
5.Map Operator
6.Filter Operator
7.Tap Operator
8.SwitchMap
9.MergeMap
10.ConcatMap
11.ExhaustMap
12.take, takeUntil, takeWhile, takeLast
13.First, last & Single
14.Skip, SkipWhile, SkipUntil & SkipLast
15.Scan & Reduce
16.DebounceTime & Debounce
17.Delay & DelayWhen
18.ThrowError
19.CatchError
20.ReTry & ReTryWhen
21.Unsubscribe from an observable

* Styling the Application

- The Angular uses several different ways to style the Application. You can style the app globally and then override it locally in the component very easily. The component styles have local scope, which is achieved using the various View Encapsulation strategies. Learn all these in the section

1.Angular Global Styles
2.View Encapsulation
3.Style binding in Angular
4.Class Binding in Angular
5.Component Styles
6.How to Install & Use Angular FontAwesome
7.How to Add Bootstrap to Angular

* Others
1.Location Service

* Configuration
- The apps usually need some sort of Run-time configuration information like URL endpoint etc, which it needs to load at startup. Also, different environments like development, production & testing require different environments, etc.

1.How to use APP_INITIALIZER
2.Run time configuration
3.Environment Variables

*  Handling Errors
- We handle errors by setting up a Global Error handler or custom error handler. Also,.whenever the error occurs in an HTTP operation, the Angular wraps it in an httpErrorResponse Object. Learn how to handle the HTTP Errors also.

1.Error Handling in Angular
2.HTTP Error Handling

* Angular CLI

1.Angular CLI Tutorial
2.Upgrading Angular App to the latest version
3.Multiple App in One Project

* SEO & Angular

- You need to set up Title & Meta Tags for each page. Ensure that the search engines can crawl and read your page. Set the correct Canonical URL for each page etc.

1.Title Service Example
2.Dynamic Title based on Route
3.Meta Service
4.Dynamic Meta Tags
5.Canonical URL
6.Lazy Load Images in Angular

* Angular Universal

The following Angular Universal Tutorial explains how to achieve Server Side Rendering using Angular Universal. The rendering the App on the server side makes it load quickly and also ensures that the search engines can crawl the content

1. Server-Side Rendering Angular Universal Tutorial

* Building & Hosting

1. Requested URL Not found on this server

* Angular Resources

1.Angular Examples & Projects
2.The Angular Learning Resources

* Angular how-to guides

1.How to get the current Route
2.ExpressionChangedAfterItHasBeenCheckedError in Angular
3.Angular CLI Check Version

* Module Loaders

The Angular application can use either SystemJs or Webpack module loader. We will demonstrate how to make use of both the Loader by building a small application.

1.Create Angular Application using SystemJS
2.Create Angular Application using Webpack
