Angular Revision Notes

* Angular Versions

Angular 9
- The Angular 9 is released on 06.02.2020. The Angular 9 is a major release. This release switches to ivy compiler and runtime by default. The ivy brings smaller bundle sizes, faster & better testing debugging, Improved type checking, build times, etc
- The Ivy compiler: The default use of the Ivy compiler is the most important feature of Angular 9, Ivy is what actually designed to solve the major problems of Angular i.e the performance and large file size

* Components
- The Component is the main building block of an Angular Application. A Component contains the definition of the View and the data that defines how the View looks and behaves.  The Angular Components are plain javascript classes and defined using @component Decorator. This Decorator provides the component with the View to display & Metadata about the class

- The Component passes the data to the view using a process called Data Binding. This is done by Binding the DOM Elements to component properties. Binding can be used to display component class property values to the user, change element styles, respond to a user event, etc.

1. Introduction to Angular Components

	* Features of Angular
	- Two-Way Data Binding
	- Powerful Routing Support
	- Expressive HTML (Enables us to use programming constructs like if conditions, for loops, etc.(*ngIf,*ngFor) to render and control how the HTML pages)
	- Modular by Design
	- Built-in Back End Support
	- Active Community
	
	* Key differences between AngularJs & Angular
	- Support for ES6
	- Components are new controllers
	- Directives (Replaced ng-repeat & ng-if with *ngFor & *ngIf * indicates as a structural directive )
	- $scopes are out (AngularJS used to run a dirty checking on the scope objects to see if any changes occurred. The Angular is using zone.js to detect changes. Zone.js apply patches on all the global asynchronous operations like click event, timer events, HTTP requests, etc. It then intimates the Angular, whenever the changes occur in Angular Application. The Angular then runs the change detection for the entire application)
	- Filters are renamed to Pipes
	- Mobile Support (AngularJS was not built with mobile support in mind. Angular designed with mobile development in mind.)

- Angular currently has following class decorators
1.@Component
2.@Directive
3.@Injectable
4.@NgModule
5.@Pipe

- Module Loaders (The later versions of Angular comes bundled with the Webpack module loader. Module loader takes a group of modules with their dependencies and merges them into a single file in the correct order. This process is called as Module bundling.)

- .editorconfig: This is the configuration file for the Visual Studio code editor. EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs.
- .gitignore: Git configuration to make sure autogenerated files are not committed to source control.
- angular.json: This is the configuration file for Angular CLI. The older versions of the Angular used the file angular-cli.json
- browserslist: Ensures the compatibility of the Angular app with different browsers.
- karma.conf.js: The Configuration file for the karma test runner.
- package.json: The package.json is an npm configuration file, that lists the third-party packages that your project depends on. We also have package-lock.json
- README.md: The Read me file
- tsconfig.json, tsconfig.app.json & tsconfig.spec.json are Typescript configuration files. The tsconfig.json is the Typescript compiler configuration file. This file specifies the compiler options required for the Typescript to compile (transpile) the project. The tsconfig.app.json is used for compiling the code, while tsconfig.spec.json for compiling the tests
- tslint.json: tslint is a static code analysis tool. We use this to check Typescript code quality. To check if TypeScript source code complies with coding rules. TSLint checks your TypeScript code for readability, maintainability, and functionality errors
- e2e: This folder contains the files required for end to end tests by protractor. Protractor allows us to test our application against a real browser.
- node_modules: All our external dependencies are downloaded and copied here by NPM Package Manager.
- src: This where our application lives.
- polyfills.ts: Different browsers have different levels of support of the web standards. Polyfills help normalize those differences. 
- test.ts: This is the main entry point for your unit tests. 

- Webpack is a bundler. it scans our application looking for javascript files and merges them into one ( or more) big file. Webpack has the ability to bundle any kind of file like JavaScript, CSS, SASS, LESS, images, HTML, & fonts, etc.
- angular.json: The Angular finds out the entry point from the configuration file angular.json. This file is located in the root folder of the project. 
- platformBrowserDynamic is the module, which is responsible for loading the Angular application in the desktop browser.

- We use ng build to build our app. Open the command prompt and run the command. This will build and copy the output files to the dist folder
- Use ng build --prod to build and distribute the app for production. For testing/debugging use ng build. The production build optimizes, minimize and uglify the code.
- Now open the dist and open the index.html. You can see that the compiler included five script files. They are runtime, polyfills, styles, vendor, & main. All these files have two versions one is es5 & the other one es2015. Since the Angular 7, we have new feature called conditional polyfill loading. Now Angular builds two script files, one for es2015 & another for es5. The es2015 (es6) is for modern browser and es5 is older browsers, which do not support the new features of es2015.

Note the nomodule attribute, which tells the modern browser to ignore the script and do not load it. Hence es5 scripts are not loaded in the modern browsers. These files are added by the Webpack module loader.
- runtime.js: Webpack runtime file
- polyfills.js – Polyfill scripts for supporting the variety of the latest modern browsers
- styles.js – This file contains the global style rules bundled as javascript file.
- vendor.js – contains the scripts from the Angular core library and any other 3rd party library.
- main.js – code of the application.

* What is Webpack?
Webpack is a bundler. it scans our application looking for javascript files and merges them into one ( or more) big file. Webpack has the ability to bundle any kind of file like JavaScript, CSS, SASS, LESS, images, HTML, & fonts, etc.

- The entry point of our application is main.ts. You will find it under the src folder.

* What is platformBrowserDynamic
platformBrowserDynamic is the module, which is responsible for loading the Angular application in the desktop browser.

* Building blocks of the Angular Component
- Template (View) - The template defines the layout of the View and defines what is rendered on the page.  Without the template,  there is nothing for Angular to render to the DOM.

- Class
The class is the code associated with Template (View). The Class is created with the Typescript, but you can also use javascript directly in the class. Class Contains the Properties & Methods. The Properties of a class can be bind to the view using Data Binding.

- Metadata
Metadata Provides additional information about the component to the Angular. Angular uses this information to process the class. The Metadata is defined with a decorator.

- @Component decorator
A class becomes a Component when Component Decorator is used. A Decorator is always prefixed with @. The Decorator must be positioned immediately before the class definition. We can also build our own decorators. The decorators are Similar to attributes in C#

2. Data Binding in Angular

- Data binding is a technique, where the data stays in sync between the component and the view. Whenever the user updates the data in the view, Angular updates the component. When the component gets new data, the Angular updates the view.

- The data binding in Angular can be broadly classified into two groups.
i) One way binding
- In one way binding data flows from one direction. Either from view to component or from component to view.

* From Component to View
To bind data from component to view, we make use of Interpolation & Property Binding.

- Interpolation - Interpolation allows us to include expressions as part of any string literal, which we use in our HTML. The Angular uses the {{ }} (double curly braces) in the template to denote the interpolation. The content inside the double braces is called Template Expression.
Syntax: {{ templateExpression }}

- Property binding - The Property binding allows us to bind HTML element property to a property in the component. You can set the properties such as class, href, src, textContent, etc using property binding. You can also use it to set the properties of custom components or directives (properties decorated with @Input).
Syntax: [binding-target]=”binding-source”
<button [disabled]="isDisabled">I am disabled</button>

- Attribute binding
Sometimes there is no HTML element property to bind to. The examples are aria (accessibility) Attributes & SVG. In such cases, you can make use of attribute binding.
Syntax: <button [attr.aria-label]="closeLabel" (onclick)="closeMe()">X</button>
Accessible Rich Internet Applications (ARIA) is a set of attributes that define ways to make web content and web applications (especially those developed with JavaScript) more accessible to people with disabilities.
MDN — Mozilla Developer Network

* From View to Component
- Event Binding - Event binding allows us to bind events such as keystroke, clicks, hover, touch, etc to a method in component. 
Syntax: (target-event)="TemplateStatement"

- Two Way binding
Two-way binding means that changes made to our model in the component are propagated to the view and that any changes made in the view are immediately updated in the underlying component. The two-way binding uses the special syntax known as a banana in a box [()]
Syntax: <someElement [(someProperty)]="value"></someElement>.

- ngModel
The Angular uses the ngModel directive to achieve the two-way binding on HTML Form elements. It binds to a form element like input, select, selectarea. etc. The ngModel directive is not part of the Angular Core library. It is part of the @angular/forms. You need to import the FormsModule package into your Angular module.

3. Interpolation in Angular
- Interpolation allows us to include expressions as part of any string literal, which we use in our HTML. The Angular uses the {{ }} (double curly braces) in the template to denote the interpolation. The syntax is as shown below.
Ex - {{ templateExpression }}

- The content inside the double braces is called Template Expression.

- The Template expression should not change the state of the application. The Angular uses it to read the values from the component and populate the view. If the Template expression changes the component values, then the rendered view would be inconsistent with the model

It means that you cannot make use of the following

Assignments (=, +=, -=, …)
Keywords like new, typeof, instanceof, etc
Chaining expressions with ; or ,
The increment and decrement operators ++ and --
bitwise operators such as | and &

- If you want to bind the expression that is other than a string (for example – boolean), then Property Binding is the best option.

- Interpolation and property binding can set only properties, not attributes. For Attributes use attribute binding.

- You can use interpolation to invoke a method in the component, Concatenate two string, perform some mathematical operations or change the property of the DOM element like color, etc.

Ex - 
{{getTitle()}}
<p>{{ 'Hello & Welcome to '+ ' Angular Interpolation '}}</p>
<p>Welcome {{firstName}}, {{lastName}}</p>

- You can also use the template reference variable. The following example creates a template variable #name to an input box. You can use it get the value of the input field {{name.value}}
Ex - 
<label>Enter Your Name</label>
<input (keyup)="0" #name>
<p>Welcome {{name.value}} </p>

- The Angular updates the view, when it runs the change detection. The change detection runs only in response to asynchronous events, such as the arrival of HTTP responses, raising of events, etc. In the example above whenever you type on the input box, it raises the keyup event. It forces the angular run the change detection, hence the view gets the latest values.

- You can make use of Angular Pipes to transform the expression result. Like converting to an uppercase, date formats, adding currency symbols, etc
Ex - <p>uppercase pipe: {{title | uppercase}}</p>

- The Safe Navigation Operator is also known as the "Elvis Operator". This operator is very useful to protect against null and undefined values in property paths. 

Ex - 
In the first case, I am trying to retrieve the data from the object path "data.firstName" using interpolation. Here, I am not defining the data so Angular parsing throws runtime null-reference exceptions. Here, our application crashes when the data is null.
<div> Hi, This Text will generate error!!! {{data.firstName}} </div>  

Now, Using the Safe Navigation Operator. So, it is protecting against the null exception.
<div> Hi, This Text will not generating error Console!!! {{data?.firstName}} </div> 

- Alternative of Safe Navigation Operator
1. The same behavior can be achieved using *ngIf Directive. In the following example, I have hidden the text when the "data" is null. 
<div *ngIf="data"> Hi, This Text will not generating error Console!!! {{data.firstName.text}} - *ngIf Example </div> 

2. The second alternative is to use "&& operator". Here, we first check for "data". When it is not null, then Angular will populate the data.firstname, else null.
<div> Hi, This Text will not generating error Console!!! {{ data && data.firstName.text}} </div>  

- The non-null assertion operator
Typescript enforces the strict null checking if you enable the --strictNullChecks flag in your tsconfig.json. Under strict null check any variable not defined or null results in a compiler error. The type checker also throws an error if it can’t determine whether a variable will be null or undefined at runtime.

- You can use the non-null assertion operator to inform typescript not to throw any compile errors. Note that it is a compile-time feature & not runtime.
Ex - The item's name is: {{item!.name}}

4. Property Binding in Angular
https://www.tektutorialshub.com/angular/property-binding-in-angular/

- Property binding is one way from component to view. It lets you set a property of an element in the view to property in the component. You can set the properties such as class, href, src, textContent, etc using property binding. You can also use it to set the properties of custom components or directives (properties decorated with @Input).

- The Property Binding uses the following Syntax

[binding-target]=”binding-source”
 
The binding-target (or target property) is enclosed in a square bracket []. It should match the name of the property of the enclosing element.

Binding-source is enclosed in quotes and we assign it to the binding-target. The Binding source must be a template expression. It can be property in the component, method in component, a template reference variable or an expression containing all of them.

Whenever the value of Binding-source changes, the view is updated by the Angular.

Ex - 
<h1 [innerText]="title"></h1>
<h2>Example 1</h2>
<button [disabled]="isDisabled">I am disabled</button>
 
import { Component } from '@angular/core';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title="Angular Property Binding Example"
  
  //Example 1
  isDisabled= true;
}

- Property Binding is one way
Property binding is one way as values go from the component to the template. When the component values change, the Angular updates the view. But if the values changes in the view, the Angular does not update the component.

- The brackets, [], tell Angular to evaluate the template expression. If you omit the brackets, Angular treats the expression as a constant string and initializes the target property with that string:

- The property binding binds to the properties of DOM elements, components, and directives and not to HTML attributes. The angular has a special syntax for attribute binding.

- The Angular has a special syntax for class, styles & attribute binding.The classes & styles are special because they contain a list of classes or styles. The bindings need to be more flexible in managing them. Hence we have a class & style binding.

The Property bindings cover all the properties, but there are certain HTML attributes that do not have any corresponding HTML property. Hence we have attribute binding

* Class binding
You can set the class in the following ways. Click on the links to find out more

i) ClassName Property binding
Ex -You can also add more than one class by separating them using the
<div [className]="'red size20'">Test</div>

ii) Set the Class attribute with class binding
Ex - To dynamically or conditionally bind a class, First create a variable in the component class as shown below.
<div [class.red]="hasError" [class.size20]="hasError">Test</div>

iii) ngClass directive
You can also use the ngClass without a square bracket. In that case, the expression is not evaluated but assigned directly to the class attribute. We also need to remove the double quote around the expression as shown below.

Ex - 
<div class="row">     
    <div ngClass='red size20'>Red Text with Size 20px </div> 
</div>

NgClass with Array
<element [ngClass]="['cssClass1', 'cssClass2']">...</element>

* Style Binding
i) Style Property Binding
Ex - 
<p [style.color]="getColor()" 
   [style.font-size.px]="'20'"      
   [style.background-color]="status=='error' ? 'red': 'blue'">
   paragraph with multiple styles
</p>

ii) ngStyle directive
Ex - 
<input [(ngModel)]="size" /> 
<div [ngStyle]="{'font-size.px': size}">Change my size</div>

* Attribute Binding
Sometimes there is no HTML element property to bind to. The examples are aria (accessibility) Attributes & SVG. In such cases, you can make use of attribute binding. The attribute syntax starts with attr followed by a dot and then the name of the attribute as shown below.

Ex - 

<button [attr.aria-label]="closeLabel" (onclick)="closeMe()">X</button>

<td [attr.colspan]="2">Col 1 & 2</td> 
<td bind-attr.colspan = "getColspan()">Col 2 & 3 </td>

// component TS
closeLabel="close";
getColspan() {
   return "2"
}

* Property Binding Vs Interpolation

- Everything that can be done from interpolation can also be done using the Property binding. Interpolation is actually a shorthand for binding to the textContent property of an element.
Ex - 
For example the following interpolation
<h1> {{ title }} </h1>
Is same as the following Property binding
<h1 [innerText]="title"></h1>


- Interpolation requires the expression to return a string. If you want to set an element property to a non-string data value, you must use property binding.

5. Event Binding in Angular
https://www.tektutorialshub.com/angular/event-binding-in-angular/

- Event binding allows us to bind events such as keystroke, clicks, hover, touche, etc to a method in component. It is one way from view to component. By tracking the user events in the view and responding to it, we can keep our component in sync with the view. For Example, when the user changes to an input in a text box, we can update the model in the component, run some validations, etc. When the user submits the button, we can then save the model to the backend server.

Ex - 
Angular event binding syntax consists of a target event name within parentheses on the left of an equal sign, and a quoted template statement on the right.

The following event binding listens for the button’s click events, calling the component’s onSave() method whenever a click occurs

<button (click)="onSave()">Save</button>

click - Target Event
onSave - Template Statement

- Unlike the Property Binding & Interpolation, where we use the template expression is used, in case of event binding we use template statement.

The Template statement can change the state of the component. Angular runs the change detection and updates the view so as to keep it in sync with the component.

- Instead of parentheses, you can also use the on- syntax as shown below.
Ex - 
<button on-click="clickMe()">Click Me</button>

- $event Payload
DOM Events carries the event payload. I.e the information about the event. We can access the event payload by using $event as an argument to the handler function.

Ex - 
<input (input)="handleInput($event)">
<p>You have entered {{value}}</p>

value=""
handleInput(event) {
  this.value=event.target.value;
}

- The properties of a $event object vary depending on the type of DOM event. For example, a mouse event includes different information than an input box editing event.

Remember you need to use the variable as $event in the Template statement. Example handleInput($event). Otherwise, it will result in an error

- We can also make use of the template reference variable to pass the value instead of $event.

Ex -
<h2>Template Reference Variable</h2>
<input #el (input)="handleInput1(el)">
<p>You have entered {{val}}</p>
 
val="";
handleInput1(element) {
  this.val=element.value;
}

- We use keyup/keydown events to listen for keystrokes. The following example does that
Ex-
<input (keyup)="value1=$event.target.value">
<p>You entered {{value1}}</p>

But Angular also offers a feature, where it helps to filter out certain keys. For Example, if you want to listen only to the enter keys you can do it easily
Ex-
<input (keyup.enter)="value2=$event.target.value">
<p>You entered {{value2}}</p>

On pressing enter key it updates the value3 variable and on escape clears the variable.
Ex - 
<input (keyup.enter)="value3=$event.target.value" (keyup.escape)="$event.target.value='';value3=''">
<p>You entered {{value3}}</p>

You can also listen for the key combination
Ex -
<input (keyup.control.shift.enter)="value4=$event.target.value">
<p>You entered {{value4}}</p>

6. Two way Binding & ngModel in Angular
https://www.tektutorialshub.com/angular/ngmodel-two-way-data-binding-in-angular/

- Two way data binding means that changes made to our model in the component are propagated to the view and that any changes made in the view are immediately updated in the underlying component data.

- The two way data binding nothing but both property binding & event binding applied together. Property Binding is one way from view to component. The event binding is one way from component to view. If we combine both we will get the Two-way binding.

- The ngModel directive is not part of the Angular Core library. It is part of the FormsModule library. You need to import the FormsModule package into your Angular module.

7. ngModelChange & Change Event

- NgModelChange is an Angular specific event, which we can use to listen for changes to the user input. It is the @Output property of the ngModel directive, Hence we need to use it along with it. ngModle raises the NgModelChange event, whenever the model changes. Another way to listen for change is to use the change DOM event.

Ex -
Name:
<input type="text" name="name" ngModel (ngModelChange)="nameChanged($event)">

nameChanged is the handler function, which we need to define in the component class. We can access the new value by using the $event as an argument to the handler function.

//Component
nameChanged(arg) {
  console.log("modelchanged " + arg);
}

* Change Event
-The (change) is a DOM event fires when changes to the form fields like <input>, <select>, and <textarea> is committed by the user.

This event fires when

- user changes the input & moves the focus away from the text box (blur event)
- On <select> it fires when the user selects a new option either by a mouse click or using a keyboard.
- Fires when the state of a check box or radio button change due to users action

* NgModelChange Vs Change
- NgModelChange is Angular specific event. Change is a DOM Event and has nothing to do with the Angular.

- We must use the ngModelChange along with the ngModel directive. You can use change event on <input>, <select>, and <textarea> form elements.

- ngModelChange event passes new value. Change event passes event parameter, Use the target.value to access the new value.

- ngModelChange will trigger with each input change. Change event fires when you remove the focus from input text after changing the content.


8. Adding Child Component in Angular
https://www.tektutorialshub.com/angular/angular-adding-child-component/

- A Component, directive, pipes cannot be part of more than one module.


* Directives
https://www.tektutorialshub.com/angular/angular-directives/
- The Angular directive helps us to manipulate the DOM. You can change the appearance, behavior, or layout of a DOM element using the directives. They help you to extend HTML.

1.Angular Directives
- The Angular directives are classified into three categories based on how they behave.  
1. Component, 
- Components are special directives in Angular.

2. Structural (ngFor, ngIf, ngSwitch) and 
- Structural directives can change the DOM layout by adding and removing DOM elements. All structural Directives are preceded by Asterix symbol.

3. Attribute Directives (ngModel, ngClass, ngStyle)
i) ngModel - The ngModel directive is used the achieve the two-way data binding.
ii) ngClass - The ngClass is used to add or remove the CSS classes from an HTML element. Using the ngClass one can create dynamic styles in HTML pages
iii) ngStyle - ngStyle is used to change the multiple style properties of our HTML elements. We can also bind these properties to values that can be updated by the user or our components.

2.ngFor 
https://www.tektutorialshub.com/angular/angular-ngfor-directive/

- ngFor exposes several values, which help us to fine-tune display. We assign these values to the local variable and use it in our template

The list of exported values provided by ngFor directive

i)index: number: The zero-based index of the current element in the collection.
Ex -

<tr *ngFor="let movie of movies; let i=index;">
    <td> {{i}} </td>
</tr>

ii) count: number: The total no of items in the collection
first: boolean: True when the item is the first item in the collection.
last: boolean: Is set to True, when the item is the last item in the collection.
even: boolean: True when the item has an even index in the collection.
odd: boolean: is set to True when the item has an odd index in the collection.
Ex -

<tr *ngFor="let movie of movies; let i=index; let o= odd; let e=even;"
[ngClass]="{ odd: o, even: e }">

- Track By clause allows you to specify your own key to identify objects.
Angular uses the object identity to compare the elements in the collection to the DOM nodes. Hence when you add an item or remove an item, the Angular will track it and update only the modified items in the DOM. It does not render the entire list.

But this fails if we update the list from the back end server. That is because the retrieved objects cannot be compared with the existing objects in the list as the reference has changed. The Angular to simply remove these elements from DOM and recreates the new elements from the new data. This has a huge performance implication.

Ex -
In our movie list example, let us make the title of the movie as the identifier.

<tr *ngFor="let movie of movies; trackBy:trackByFn;">
    <td>{{movie.title}}</td>
    <td>{{movie.director}}</td>
    <td>{{movie.cast}}</td>
    <td>{{movie.releaseDate}}</td>
</tr>

  trackByFn(index, item) {
    return item.title;
  }

3.ngSwitch
https://www.tektutorialshub.com/angular/angular-ngswitch-directive/

- ngSwitchCase is bound to an inner_element, which we must place inside the container_element. We use * (Asterix symbol), because it is a structural directive. We also assign a match_expression, which Angular evaluates at runtime. The Angular displays the inner_element only when the value of the match_expression matches the value of the switch_expression else it is removed from the DOM.

- If there is more than one match, then it displays all of them.
Note that the ngSwitchCase does not hide the element, but removes them from the DOM.

-  If none of the ngSwitchCase match_expression matches the switch_expression, then the angular displays the element attached to the ngSwitchDefault

- You are free to add more than one ngSwitchDefault directive. Angular displays all of them.

- Angular uses loose equality checks to compare the ngSwitchCase expression with the ngSwitch expression. This means that the empty string "" matches 0.

Ex -
<div class="card-body">
    Input string : <input type='text' [(ngModel)]="num" />
 
    <div [ngSwitch]="num">
      <div *ngSwitchCase="'1'">One</div>
      <div *ngSwitchCase="'2'">Two</div>
      <div *ngSwitchCase="'3'">Three</div>
      <div *ngSwitchCase="'4'">Four</div>
      <div *ngSwitchCase="'5'">Five</div>
      <div *ngSwitchDefault>This is Default</div>
    </div>
</div>

4.ngIf

- We bind the *ngIf to an expression (a condition in the above example). The expression is then evaluated by the ngIf directive. The expression must return either true or false.

- If the expression evaluates to false then the Angular removes the entire element from the DOM. If true it will insert the element into the DOM.

* Hidden attribute Vs ngIf

- ngIf does not hide the DOM element. It removes the entire element along with its subtree from the DOM. It also removes the corresponding state freeing up the resources attached to the element. hidden attribute does not remove the element from the DOM. But just hides it.

- ngIf else
When the condition evaluates to false, then the ng-template with the name #elseBlock is rendered by the ngIf Directive.
Ex - 
<div *ngIf="condition; else elseBlock">
    content to render, when the condition is true 
</div>
 
<ng-template #elseBlock>
    content to render, when the condition is false 
</ng-template>

- ngIf then else
Ex - 
<div *ngIf="condition; then thenBlock else elseBlock"> 
    This content is not shown
</div>
 
<ng-template #thenBlock>
    content to render when the condition is true.
</ng-template>
 
<ng-template #elseBlock>
    content to render when condition is false.
</ng-template>


5.ngClass
- The ngClass directive adds and removes CSS classes on an HTML element. The syntax of the ngClass is as shown below.

- NgClass with a String
If you want to assign multiple classes, then separate each class with space as shown below.
Ex -
<element [ngClass]="'cssClass1 cssClass2'">...</element>

- You can also use the ngClass without a square bracket. In that case, the expression is not evaluated but assigned directly to the class attribute. We also need to remove the double quote around the expression as shown below.

<div class="row">     
    <div ngClass='red size20'>Red Text with Size 20px </div> 
</div>

- NgClass with Array
You can achieve the same result by using an array instead of a string as shown below.
Ex -
<element [ngClass]="['cssClass1', 'cssClass2']">...</element>

- NgClass with Object
You can also bind the ngClass to an object. Each property name of the object acts as a class name and is applied to the element if it is true.
Ex -
<element [ngClass]="{'cssClass1': true, 'cssClass2': true}">...</element>


6.ngStyle
-The Angular ngStyle directive allows us to set the many inline style of a HTML element using an expression. The expression can be evaluated at run time allowing us to dynamically change the style of our HTML element.
Ex - <some-element[ngStyle]="{'font-size.em': '3'}">...</some-element>

<div> [ngStyle]="{'background-color':status === 'error' ? 'red' : 'blue' }"></<div>


7.ngFor Trackby
- Angular Trackby option improves the Performance of the ngFor if the collection has a large no of items and keeps changing.

- The ngFor will use the unique id returned by the trackBy function to track the items. Hence even if we refresh the data from the back end, the unique id will remain the same and the list will not be rendered again.

- The trackBy takes a function that has two arguments: index and the current item. It must return a id that uniquely identifies the item. The following example returns the title as the unique id.
Ex - 
trackByFn(index, item) {
    return item.title;
  }
  
  <li *ngFor="let movie of movies; let i=index;trackBy: trackByFn;">
  
- Trackby multiple fields
Ex: 
<li *ngFor="let movie of movies; let i=index;trackBy: trackByFnMultipleFields;">

trackByFnMultipleFields(index, item) {
    return item.title + item.director;
  }

8.Custom Directive
-Components are directives with Template (or view). We know how to build Angular Components. Structural & Attribute directives do not have an associated view.

-Structural directives change the DOM layout by adding and removing DOM elements. All structural Directives are preceded by the Asterix (*) symbol.

-The Attribute directives can change the appearance or behavior of an element.

* Custom Attribute Directive
- We attach the attribute directive to an element, which we call the parent element. To change the properties of the parent element, we need to get the reference. Angular injects the parent element when we ask for the instance of the ElementRef in its constructor.

- ElementRef is a wrapper for the Parent DOM element. We can access the DOM element via the property nativeElement. The classList method allows us to add the class to the element.

Ex -
ttClass.directive.ts

import { Directive, ElementRef, Input, OnInit } from '@angular/core'
 
@Directive({
  selector: '[ttClass]',
})
export class ttClassDirective implements OnInit {
 
  @Input() ttClass: string;
 
  constructor(private el: ElementRef) {
  }
 
  ngOnInit() {
    this.el.nativeElement.classList.add(this.ttClass);
  }
 
}

.html
<button [ttClass]="'blue'">Click Me</button>

.css
.blue {
  background-color: lightblue;
}

* Custom Structural Directive
- Since, we are manipulating the DOM, we need ViewContainerRef and TemplateRef instances.

- We use the createEmbeddedView method of the ViewContainerRef to insert the template if the condition is true. The clear removes the template from the DOM.

Ex - 
import { Directive, ViewContainerRef, TemplateRef, Input } from '@angular/core';
 
@Directive({ 
  selector: '[ttIf]' 
})
export class ttIfDirective  {
 
  _ttif: boolean;
 
  constructor(private _viewContainer: ViewContainerRef,
            private templateRef: TemplateRef<any>) {
  }
 
 
  @Input()
  set ttIf(condition) {
    this._ttif = condition
    this._updateView();
  }
 
  _updateView() {
    if (this._ttif) {
      this._viewContainer.createEmbeddedView(this.templateRef);
    }
    else {
      this._viewContainer.clear();
    }
  }
 
}

import { Component } from '@angular/core';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title: string = "Custom Directives in Angular";
  show=true;
}

.html
<h1> {{title}} </h1>
 
Show Me
<input type="checkbox" [(ngModel)]="show">
 
<div *ttIf="show">
  Using the ttIf directive
</div>
 
<div *ngIf="show">
  Using the ngIf directive
</div>

- We use the * notation to tell Angular that we have a structural directive and we will be manipulating the DOM. It basically tells angular to inject the TemplateRef. To inject the templateRef, the Angular needs to locate the template. The * tells the Angular to locate the template and inject its reference as templateRef

https://www.tektutorialshub.com/angular/custom-directive-in-angular/

* Pipes
https://www.tektutorialshub.com/angular/angular-pipes/
- The Angular pipes are used to Transform the Data. For Example, the Date pipe formats the date according to locale rules. We can pass arguments to pipe and chain pipes. The Angular also allows us to create the Custom Pipe

1. Angular Pipes

- Angular Pipes takes data as input and formats or transform the data to display in the template. We use them to change the appearance of the data before presenting it to the user. The most common use case of pipes is displaying the dates in the correct format as per the user’s locale.
Ex -
toDate | date | uppercase
<p>medium : {{toDate | date:'medium'}} </p>


2. Angular Custom Pipes

- To create a Custom Pipe, first, You need to follow these steps

1. Create a pipe class
2. Decorate the class with @pipe decorator.
3. Give a name to the pipe in the name meta data of the @pipe decorator. We will use this name in the template.
4. The pipe class must implement the PipeTransform interface. The interfaces contain only one method transform.
5. The first parameter to the transform method is the value to be transferred. The transform method must transform the value and return the result. You can add any number of additional arguments to the transform method.
6. Declare the pipe class in the Angular Module (app.module.ts)
7. Use the custom pipe just as you use other pipes.

- import {Pipe, PipeTransform} from '@angular/core';
 
@pipe({
    name: 'tempConverter'
})
export class TempConverterPipe implements PipeTransform {
    transform(value: number, unit: string) {
        if(value && !isNaN(value)) {
            if (unit === 'C') {
                var temperature = (value - 32) /1.8 ;
                return temperature.toFixed(2);
            } else if (unit === 'F'){
                var temperature = (value * 1.8 ) + 32
                return temperature.toFixed(2);
            }
        }
        return;
    }
}

.html
<p> celsius : <input type="text" [(ngModel)]="celcius" /> 
       Fahrenheit : {{celcius | tempConverter:'F'}} </p>

3. Date Pipe

* There are two types formats options available

i) Pre defined Format
Ex - 
{{toDate | date:'short'}}	5/24/20, 3:40 PM

ii) Custom Format string
Ex - 
{{toDate | date:'dd/MM/yy HH:mm'}}         //May 24, 2020, 7:17:26 PM

4. Async Pipe
https://www.tektutorialshub.com/angular/angular-async-pipe/

- The async pipe allows us to subscribe to an Observable or Promise from the template and returns the value emitted. The async pipes subscribe to the observable when the component loads. It unsubscribes when the component gets destroyed. 

- ShareReplay - We use the shareReplay when you want subscribers to share the observable and access previously emitted values. i.e. the observable is subscribed only once and for every subsequent subscription, the previously received value is used.

---Read this article from somewhere else--- 


5. KeyValue Pipe
- The KeyValue Pipe converts given Object or Map into an array of key-value pairs. We can use this with the ngFor to loop through the object keys. The keyValue accepts the one argument compareFn, which we can use to set the custom sort to the pipe. 

Ex -
obj = [
    { key:a, value:789 },
    { key:b, value:446 },
    { key:c, value:123 },
  ];
  
<ul>
  <li *ngFor="let item of obj | keyvalue">
    {{item.key}} ---> {{item.value}}</li>
</ul>

- KeyValue pipe uses the key to sort the results array. You can see it from the above example. Even though our object was c,b & a it was sorts it as a,b,c. The keyValue pipe uses the defaultComparator to sort the result. It uses

i. Ascending Order if the keys are number
ii. Alphabetical Order if keys are strings
if keys are are of different types. then covert them to to their string values and use Alphabetical Order
iii. If key is a either Null or undefined, put then at the end of the sort.

- You can customize it by providing a custom sort function (compareFn) as the first argument to the keyValue pipe.

Syntax: compareFn (a: KeyValue, b: KeyValue) => number 

orderOriginal = (a: KeyValue<number,string>, b: KeyValue<number,string>): number => {
  return 0
}
  
orderbyValueAsc = (a: KeyValue<number,string>, b: KeyValue<number,string>): number => {
   return a.value > b.value ? -1 : (a.value > b.value) ? 0 : 1  
}
 
orderbyValueDsc = (a: KeyValue<number,string>, b: KeyValue<number,string>): number => {
  return a.value > b.value ? 1 : (a.value > b.value) ? 0 : -1  
}

<ul>
  <li *ngFor="let item of obj | keyvalue : orderbyValueAsc ">
    {{item.key}} ---> {{item.value}}</li>
</ul>



6. Using Pipes in Components & Services
- We usually use Angular Pipes in the template. But a pipe is nothing but a class with a method transform. Whether it is a built-in pipe or custom pipe, we can easily use it in an angular component or service.

- Using pipes in your code involves three simple steps

Import the pipe in Module
Inject pipe in the constructor
Use the transform method of the pipe

- constructor(private datePipe:DatePipe) {
  }
 
  ngOnInit() {
     this.toDate = this.datePipe.transform(new Date());
  }


* Component Communication
- Parent Component communicates with the child component using the @Input Annotation. The child components detect changes to these Input properties using OnChanges life Cycle hook or with a Property Setter.

1.Passing data to child component 

- In Angular, the Parent Component can communicate with the child component by setting its Property. To do that the Child component must expose its properties to the parent component. The Child Component does this by using the @Input decorator

In the Child Component

i) Import the @Input module from @angular/Core Library
ii) Mark those property, which you need data from parent as input property using @Input decorator

In the Parent Component

i) Bind the Child component property in the Parent Component when instantiating the Child

- The @Input Decorator is used to configure the input properties of the component. This decorator as also supports change tracking.

When you mark a property as input property, then the Angular injects values into the component property using Property Binding. The Property Binding uses the [] brackets. The Binding Target (Property of the child component) is placed inside the square brackets. The Binding source is enclosed in quotes. Property binding is one way from Component to the Target in the template

- Various ways to use @Input Decorator
i) Using the @Input decorator to decorate the class property

Ex - @Input() count: number;

ii) Using the input array meta data of the component decorator

Ex - @Component({
    selector: 'child-component',
    inputs: ['count'],
    template: `<h2>Child Component</h2>
    current count is {{ count }}`
	})
	
- Detecting the Input changes
assing the data to child component is not sufficient, the child Component needs to know when the input changes so that it can act upon it.

There are two ways of detecting when input changes in the child component in Angular

i) Using OnChanges LifeCycle Hook
- ngOnChanges is a lifecycle hook, which angular fires when it detects changes to data bound input property. This method receives a SimpeChanges object, which contains the current and previous property values. We can Intercept input property changes in the child component using this hook.

Ex -
import { Component, Input, OnChanges, SimpleChanges, SimpleChange  } from '@angular/core';
 
@Component({
    selector: 'child-component',
    template: `<h2>Child Component</h2>
               current count is {{ count }}
    `
})
export class ChildComponent implements OnChanges {
    @Input() count: number;
 
    ngOnChanges(changes: SimpleChanges) {
 
        for (let property in changes) {
            if (property === 'count') {
              console.log('Previous:', changes[property].previousValue);
              console.log('Current:', changes[property].currentValue);
              console.log('firstChange:', changes[property].firstChange);
            } 
        }
    }
}


ii) Using Input Setter
- We can use the property getter and setter to detect the changes made to the input property as shown below
Ex -
private _count = 0;

@Input()
set count(count: number) {
    this._count = count;
    console.log(count);
}
get count(): number { return this._count; }


2.Passing Data to Parent Component
There are three ways in which parent component can interact with the child component

i) Parent Listens to Child Event
ii) Parent uses Local Variable to access the child
iii) Parent uses a @ViewChild to get reference to the child component

- The Child Component exposes an EventEmitter Property. This Property is adorned with the @Output decorator. When Child Component needs to communicate with the parent it raises the event. The Parent Component listens to that event and reacts to it.

- To Raise an event, the component must declare an EventEmmitter Property. The Event can be emitted by calling the .emit() method

- Using the EventEmitter Property gives the components ability to raise an event. But to make that event accessible from parent component, you must decorate the property with @Output decorator


-In the child component

i) Declare a property of type EventEmitter and instantiate it
ii) Mark it with a @Output annotation
iii) Raise the event passing it with the desired data

-In the Parent Component

i) Bind to the Child Component using Event Binding and listen to the child events
ii) Define the event handler function

Ex - 
import { Component} from '@angular/core';
 
@Component({
  selector: 'app-root',
  template: `
        <h1>Welcome to {{title}}!</h1>
        <p> current count is {{ClickCounter}} </p>
        <child-component [count]=Counter (countChanged)="countChangedHandler($event)"></child-component>` ,
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Component Interaction';
  Counter = 5;
 
  countChangedHandler(count: number) {
    this.Counter = count;
    console.log(count);
  }
}
 
Child component
import { Component, Input, Output, EventEmitter  } from '@angular/core';
 
@Component({
    selector: 'child-component',
    template: `<h2>Child Component</h2>
               <button (click)="increment()">Increment</button>
               <button (click)="decrement()">decrement</button>
               current count is {{ count }}
    `
})
export class ChildComponent {
    @Input() count: number;
 
    @Output() countChanged: EventEmitter<number> =   new EventEmitter();
 
    increment() {
        this.count++;
        this.countChanged.emit(this.count);
      }
    decrement() {
        this.count--;
        this.countChanged.emit(this.count);
    }
}
 
- Parent Template can access the child component properties and methods by creating the template reference variable
Ex - 
<p> current count is {{child.count}} </p>
        <button (click)="child.increment()">Increment</button>
        <button (click)="child.decrement()">decrement</button>
        <child-component #child></child-component>

- The local variable approach is simple and easy. But it is limited because the parent-child wiring must be done entirely within the parent template. The parent component itself has no access to the child.

You can’t use the local variable technique if an instance of the parent component class must read or write child component values or must call child component methods.

- Injecting an instance of the child component into the parent as a @ViewChild is the another technique used by the parent to access the property and method of the child component
Ex - @ViewChild(ChildComponent) child: ChildComponent;


* Component Life Cycle Hook
- The life cycle hooks are the methods that angular invokes on directives and components as it creates, changes, and destroys them. Using life-cycle hooks we can fine-tune the behavior of our components during creation, update, and destruction.

https://www.tektutorialshub.com/angular/angular-component-life-cycle-hooks/

1.Component Life Cycle

- The Angular life cycle hooks are nothing but callback function, which angular invokes when a certain event occurs during the component’s life cycle.

- For example,

i) ngOnInit when Angular initializes the component for the first time.

ii) When a component’s input property change, Angular invokes ngOnChanges

iii) If the component is destroyed, Angular invokes ngOnDestroy

* Constructor
- Constructor is neither a life cycle hook nor it is specific to Angular.  It is a Javascript feature. It is a method which is invoked, when a class is created. Angular makes use of a constructor to inject dependencies.

* ngOnChanges
- The Angular invokes ngOnChanges life cycle hook whenever any data-bound input property of the component or directive changes. Initializing the Input properties is the first task that angular carries during the change detection cycle. And if it detects any change in property, then it raises the ngOnChanges hook. It does so during every change detection cycle. This hook is not raised if change detection does not detect any changes.

- The change detector uses the === strict equality operator for detecting changes. Hence for objects, the hook is fired only if the references are changed. 

* ngOnInit
- It raises it after the ngOnChanges hook. This hook is fired only once and immediately after its creation (during the first change detection).

- This is a perfect place where you want to add any initialisation logic for your component.  Here you have access to every input property of the component. You can use them in  http get requests to get the data from the back end server or run some initialization logic etc.

- But note that none of child components or projected content are available at this point. Hence any properties we decorate with @ViewChild, @ViewChildren , @ContentChild & @ContentChildren will not be available to use.

* ngDoCheck
- The Angular invokes the ngDoCheck hook event during every change detection cycle. This hook is invoked even if there is no change in any of the properties.

- Angular invokes it after the ngOnChanges & ngOnInit hooks.

- Use this hook to Implement a custom change detection, whenever Angular fails to detect the changes made to Input properties. This hook is particularly useful when you opt for the Onpush change detection strategy.

* ngAfterContentInit
- ngAfterContentInit Life cycle hook is called after the Component’s projected content has been fully initialized. Angular also updates the properties decorated with the ContentChild and ContentChildren before raising this hook. This hook is also raised, even if there is no content to project.

The content here refers to the external content injected from the parent component via Content Projection. 

The Angular Components can include the ng-content element, which acts as a placeholder for the content from the parent as shown below

<h2>Child Component</h2>
<ng-content></ng-content>   <!-- placehodler for content from parent -->

Parent injects the content between the opening & closing element.  Angular passes this content to the child component

<h1>Parent Component</h1>
<app-child> This <b>content</b> is injected from parent</app-child>

* ngAfterContentChecked

- ngAfterContentChecked Life cycle hook is called during every change detection cycle after Angular finishes checking of component’s projected content. Angular also updates the properties decorated with the ContentChild and ContentChildren before raising this hook. Angular calls this hook even if there is no projected content in the component

This hook is very similar to the ngAfterContentInit hook. Both are called after the external content is initialized, checked & updated. Only difference is that ngAfterContentChecked is raised after every change detection cycle. While ngAfterContentInit during the first change detection cycle.

* ngAfterViewInit
- ngAfterViewInit hook is called after the Component’s View & all its child views are fully initialized. Angular also updates the properties decorated with the ViewChild & ViewChildren properties before raising this hook. 

- The View here refers to the template of the current component and all its child components & directives. 

- This hook is called during the first change detection cycle, where angular initializes the view for the first time

- At this point all the lifecycle hook methods & change detection  of all child components & directives are processed & Component is completely ready

* ngAfterViewChecked

- The Angular fires this hook after it checks & updates the component’s views and child views. This event is fired after the ngAfterViewInit and after that during every change detection cycle

- This hook is very similar to the ngAfterViewInit hook. Both are called after all the child components & directives are initialized and updated. Only difference is that ngAfterViewChecked is raised during every change detection cycle. While ngAfterViewInit during the first change detection cycle.

- This hook is called just before the Component/Directive instance is destroyed by Angular

You can Perform any cleanup logic for the Component here. This is the correct place where you would like to Unsubscribe Observables and detach event handlers to avoid memory leaks.

- The Angular executes the hooks in the following order
On Component Creation

1. OnChanges
2. OnInit
3. DoCheck
4. AfterContentInit
5. AfterContentChecked
6. AfterViewInit
7. AfterViewChecked

- When the Component with Child Component is created

1. OnChanges
2. OnInit
3. DoCheck
4. AfterContentInit
5. AfterContentChecked
	1. Child Component -> OnChanges
	2. Child Component -> OnInit
	3. Child Component -> DoCheck
	4. Child Component -> AfterContentInit
	5. Child Component -> AfterContentChecked
	6. Child Component -> AfterViewInit
	7. Child Component -> AfterViewChecked
6. AfterViewInit
7. AfterViewChecked

- After The Component is Created

1. OnChanges
2. DoCheck
3. AfterContentChecked
4. AfterViewChecked

- The OnChanges hook is fired only if there is an input property defined in the component and it changes. Otherwise, it will never fire

2.OnInit & OnDestroy
3.Onchanges
- The ngOnChnages is a life cycle hook, which angular fires when it detects changes to data-bound input property. This method receives a SimpeChanges object, which contains the current and previous property values.

* Why onChanges does not fire?
The Change detector also raises the OnChanges hook. But it uses a different techniques for comparison.

The change detector uses the === strict equality operator for detecting changes to the input properties. For primitive data types like string, the above comparison works perfectly

But in the case of an object like a customer, this fails. For Arrays/objects, the strict checking means that only the references are checked. Since the reference to the customer stays the same the Angular does not raise the OnChanges hook.

That leaves us two possible solutions

1. Create a new customer and copy the old data to new customer
2. We can Perform our own change detection using the ngDoCheck lifecycle hook


4.DoCheck
- We also looked at how OnChanges does not fire when the input property is an array/object because Angular uses dirty checking to compare the properties.

In such a scenario, where Angular fails to detect the changes to the input property, the DoCheck allows us to implement our custom change detection.

The Angular Fires the DoCheck hook after each change detection.

- When ngDoCheck is called
Notice that DoCheckCount keeps incrementing for every keystroke, mouse movements

Angular calls this hook very frequently. This hook is called after every change detection cycle no matter where the change has occurred

It is advisable to keep the implementation of Docheck simple and lightweight. Otherwise, it will result in bad user experience

- The Angular provides a service called differs, which evaluate the given object/array and determines what changed

There are two types of differs, that angular provides

i) key-value differs

- The KeyValueDiffers service is a differ that tracks changes made to an object over time and also expose an API to react to these changes.

- Key-value differs should be used for dictionary-like structures, and it works at the key level. This differ will identify changes when a new key is added, when a key removed and when the value of a key changed.

ii) iterable differs

- Iterable differs service is used when we have a list-like structure and we’re only interested in
knowing things that were added or removed from that list.

It will detect if the elements are added/removed from the array. This will not detect if the changes are done to the elements of array

To do that, you need to create a separate key value differ for the each element


* Angular Forms
https://www.tektutorialshub.com/angular/angular-forms-fundamentals/
1.Angular Forms Tutorial: Fundamental & Concepts

- Building Blocks of Angular Forms
i) FormControl
- A FormControl represents a single input field in an Angular form.

- The FormControl is an object that encapsulates all this information related to the single input element. It Tracks the value and validation status of each of these control

- You can use FormControl to set the value of the Form field, find the status of form field like (valid/invalid, pristine/dirty, touched/untouched ) etc & add validation rules to it.

Ex -
firstname.errors      // returns the list of errors
firstname.dirty       // true if the value has changed (dirty)
firstname.touched     // true if input field is touched
firstname.valid       // true if the input value has passed all the validation

ii) FormGroup

- FormGroup is a collection of FormControls . Each FormControl is a property in a FormGroup. with the control name as the key.

- A typical Angular Form can have more than one FormGroup. A FormGroup can also contain another FormGroup. The Angular form is itself a FormGroup

iii) FormArray
- FormArray is an array of form controls. It is similar to FormGroup except for one difference. In FormGroup each FormControl is a property with the control name as the key. In FormArray is an array of form controls.

Ex -
contactForm = new FormGroup( {
    name: new FormControl(''),
    cities:new FormArray([
      new FormControl('Mumbai'),
      new FormControl('Delhi')
    ])
  });
  
cities() :FormArray {
    return this.contactForm.get("cities") as FormArray
  }


2.Template Driven Forms in Angular
https://www.tektutorialshub.com/angular/angular-template-driven-forms/

- In Template Driven Forms we specify behaviors/validations using directives and attributes in our template and let it work behind the scenes. All things happen in Templates hence very little code is required in the component class. This is different from the reactive forms, where we define the logic and controls in the component class.

- The Template-driven forms 

1. The form is set up using ngForm directive
2. controls are set up using the ngModel directive
3. ngModel also provides the two-way data binding
4. The Validations are configured in the template via directives

- Once, we have a form with few form elements, the angular automatically converts it into a Template-driven form. This is done by the ngForm directive.

- The ngForm directive is what makes the Angular template-driven forms work. But we do not need to add it explicitly. Angular adds it automatically

- When we include FormsModule, the Angular is going to look out for any <form> tag in our HTML template. Angular does this via ngForm directive. ngForm directive automatically detects the <form> tag and automatically binds to it. You do not have to do anything on your part to invoke and bind the ngForm directive.

Ex -
<form #contactForm="ngForm" (ngSubmit)="onSubmit(contactForm)">

  <p>
    <label for="firstname">First Name</label>
    <input type="text" name="firstname" ngModel>
	//<input type="text" name="firstname" #fname="ngModel" ngModel>
  </p>
  

  <p>
    <button type="submit">Submit</button>
  </p>

</form>

onSubmit(contactForm) {
    console.log(contactForm.value);
  }
  
- We can add new FormGroup using the ngModelGroup directive. Let us add street, city & Pincode form controls and group them under the address FormGroup

<div ngModelGroup="address">
 
    <p>
      <label for="city">City</label>
      <input type="text" name="city" ngModel>
    </p>
 
    <p>
      <label for="street">Street</label>
      <input type="text" name="street" ngModel>
    </p>
    <p>
      <label for="pincode">Pin Code</label>
      <input type="text" name="pincode" ngModel>
    </p>
 
</div>

3.Set Value in Template Driven forms in Angular
https://www.tektutorialshub.com/angular/how-to-set-value-in-template-driven-forms-in-angular/

- You can make use of the patchValue to change the only few fields anytime.

Ex -
patchValue() {
    let obj = {
      firstname: "Rahul",
      lastname: "Dravid",
      email: "rahul@gmail.com",
    };
 
    this.contactForm.control.patchValue(obj);
 
  }


4.Reactive Forms in Angular

- Reactive forms ( also known as Model-driven forms) is one of the two ways to build Angular forms. 


5.FormBuilder in Reactive Forms
- The FormBuilder is the helper API to build forms in Angular.  It provides shortcuts to create the instance of the FormControl, FormGroup or FormArray. It reduces the code required to write the complex forms.

Ex -

this.contactForm = this.formBuilder.group({
      firstname: ['', [Validators.required, Validators.minLength(10)]],
      lastname: ['', [Validators.required, Validators.maxLength(15), Validators.pattern("^[a-zA-Z]+$")]],
      email: ['', [Validators.required, Validators.email]],
      gender: ['', [Validators.required]],
      isMarried: ['', [Validators.required]],
      country: ['', [Validators.required]],
      address: this.formBuilder.group({
        city: ['', [Validators.required]],
        street: ['', [Validators.required]],
        pincode: ['', [Validators.required]],
      })
    });

<form [formGroup]="contactForm" (ngSubmit)="onSubmit()" novalidate>
 
  <p>
    <label for="firstname">First Name </label>
    <input type="text" id="firstname" name="firstname" formControlName="firstname">
  </p>
 
  <div
    *ngIf="!firstname?.valid && (firstname?.dirty ||firstname?.touched)">
    <div [hidden]="!firstname.errors.required">
      First Name is required
    </div>
    <div [hidden]="!firstname.errors.minlength">
      Min Length is 10
    </div>
  </div>
 
  <p>
    <label for="lastname">Last Name </label>
    <input type="text" id="lastname" name="lastname" formControlName="lastname">
  </p>
 
  <div *ngIf="!lastname.valid && (lastname.dirty ||lastname.touched)">
    <div [hidden]="!lastname.errors.pattern">
      Only characters are allowed
    </div>
    <div [hidden]="!lastname.errors.maxLength">
      Max length allowed is {{lastname.errors.maxlength?.requiredLength}} 
    </div>
    <div [hidden]="!lastname.errors.required">
      Last Name is required
    </div>
  </div>


6.SetValue & PatchValue in Angular
* SetValue
- We use the SetValue to update the FormControl , FormGroup or FormArray. When we use it to update the FormGroup or FormArray the SetValue requires that the object must match the structure of the FormGroup or FormArray exactly. Otherwise, it will result in an error.

Ex - setValue(value: { [key: string]: any; }, options: { onlySelf?: boolean; emitEvent?: boolean; } = {}): void

* PatchValue
- The PatchValue is used to update only a subset of the elements of the FormGroup or FormArray. It will only update the matching objects and ignores the rest.

Ex - patchValue(value: { [key: string]: any; }, options: { onlySelf?: boolean; emitEvent?: boolean; } = {}): void

* onlySelf
- The Angular checks the validation status of the form, whenever there is a change in value. The validation starts from the control whose value was changed and propagates to the top level FormGroup. This is the default behavior

- There may be circumstances, where you do not want angular to check the validity of the entire form, whenever you change the value using the setValue or patchValue. We do that by setting the onlySelf=true as the argument. In such cases, the angular only checks the validity of the current control, but does not check any other control and does not propagate the validity checking to the parent form group.

* emitEvent
The Angular forms emit two events. One is ValueChanges & the other one is StatusChanges. The ValueChanges event is emitted whenever the value of the form is changed. The StatusChanges event is emitted whenever angular calculates the validation status of the Form. This is the default behavior

- We can stop that from happening, by setting the emitEvent=false

- The difference is that with setValue we must include all the controls, while with the patchValue you can exclude some controls.

Ex -

setValue() {
 
    let contact = {
      firstname: "Rahul",
      lastname: "Dravid",
      email: "rahul@gmail.com",
      gender: "male",
      isMarried: true,
      country: "1",
      address: {
        city: "Bangalore",
        street: "Brigade Road",
        pincode: "600070"
      }
    };
 
    this.reactiveForm.setValue(contact);
  }

patchName() {
    let contact = {
      firstname: "Rahul",
      lastname: "Dravid",
    }
 
    this.reactiveForm.patchValue(contact);
 
  }

- The Angular forms emit two events. One is ValueChanges & the Other one is statusChanges. You can stop them from happening using the emitEvent:false argument as shown below.

Ex -
this.reactiveForm.get("firstname").statusChanges.subscribe(x => {
      console.log('firstname status changes')
    })
	
this.reactiveForm.get("firstname").valueChanges.subscribe(x => {
      console.log('firstname value changed')
    })


7.StatusChanges in Angular Forms
https://www.tektutorialshub.com/angular/statuschanges-in-angular-forms/

- The StatusChanges event is fired whenever the angular calculates the validity status of the FormControl, FormGroup or FormArray. It is an observable and we can subscribe to it. The StatusChanges event does not fire depending on how we set emitEvent or onlySelf, when updating the value and validity of the form controls.

Ex - this.reactiveForm.get("address").statusChanges.subscribe(newStatus=> {
      console.log('address status changed')
      console.log(newStatus)
    })
	
withEmitEvent() {
    this.reactiveForm.get("firstname").setValue("Sachin");
  }
  
  withoutEmitEvent() {
	this.reactiveForm.get("firstname").setValue("", { emitEvent: false });
  }
  
- StatusChanges event can also be used in the template-driven forms. All you need to do is to get the reference to the Form Model in the component as shown below

@ViewChild('templateForm',null) templateForm: NgForm;

this.templateForm.control.get("address").statusChanges.subscribe(newStatus => {
        console.log('address status changed')
        console.log(newStatus)
      })



8.ValueChanges in Angular Forms

- The ValueChanges is an event raised by the Angular forms whenever the value of the FormControl, FormGroup or FormArray changes. It returns an observable so that you can subscribe to it. The observable gets the latest value of the control. It allows us to track changes made to the value in real-time and respond to it. For example, we can use it to validate the value, calculate the computed fields, etc.

Ex - 
this.reactiveForm.get("firstname").valueChanges.subscribe(selectedValue => {
  console.log('firstname value changed')
  console.log(selectedValue)
  console.log(this.reactiveForm.get("firstname").value)
  console.log(this.reactiveForm.value)    //shows the old first name
      
  setTimeout(() => {
    console.log(this.reactiveForm.value)   //shows the latest first name
  })
     
})

- The ValueChanges event is fired even when the values of the control are changed programmatically. In some circumstances, you might not want to raise the ValueChanges event. To do that we can use the emitEvent: false

In the following example, the ValueChanges event is not fired at all, even though the value of the firstname is changed.

Ex -
this.reactiveForm.get("firstname").setValue("", { emitEvent: false });


9.FormControl

- The FormControl is an object that encapsulates all the information related to the single input element. It Tracks the value and validation status of each of these control.

- The FormControl is just a class. A FormControl is created for each form field. We can refer to them in our component class and inspect its properties and methods

- We can use FormControl to set the value of the Form field. Find the status of form field like (valid/invalid, pristine/dirty, touched/untouched ), etc. You can add validation rules to it.


10.FormGroup

- The Forms API also allows add controls dynamically

- addControl()
Adds a control to the FormGroup and also updates validity & validation status. If the control already exists, then ignores it

Ex -
addControl(name: string, control: AbstractControl): void

addControl() {
    this.middleName = new FormControl('', [Validators.required]);
    this.reactiveForm.addControl("middleName",this.middleName);
  }
  
- registerControl() 
Adds control to this FormGroup but does not update the validity & validation status. If the control already exists, then ignores it

registerControl(name: string, control: AbstractControl): AbstractControl

registerControl() {
  this.middleName = new FormControl('', [Validators.required]);
  this.reactiveForm.addControl("middleName",this.middleName);
}

- removeControl() 
This method will remove the control with the provided name from the FormGroup.

removeControl(name: string): void

remodeControl() {
  this.reactiveForm.removeControl("middleName");
}

- setControl()
Replaces the control with the provided name with the new control.

setControl(name: string, control: AbstractControl): void

setControl() {
  this.middleName = new FormControl('test', [Validators.required]);
  this.reactiveForm.setControl("middleName",this.middleName);
}

- contains()
Check whether the control with the provided name exists or not..

contains(controlName: string): boolean

containsControl() {
  console.log(this.reactiveForm.contains("middleName"));
}

- The Angular runs validation checks, whenever the value of a form control changes. Based on the result of the validation, the FormGroup can have four possible states.

i) valid
A FormGroup is valid when it has passed all the validation checks and the FormGroup is not disabled

ii) invalid
A FormGroup is invalid when one of its controls has failed a validation check or the entire FormGroup is disabled.

iii) pending
A FormGroup is pending when it is in the midst of conducting a validation check.

iv) disabled
A FormGroup is disabled when all of its controls are disabled.

v) enabled
A FormGroup is enabled as long one of its control is enabled.

vi) pristine
A FormGroup is pristine if the user has not yet changed the value in the UI in any of the controls

vii) dirty
A FormGroup is dirty if the user has changed the value in the UI in any one of the control.

viii) touched
True if the FomGroup is marked as touched. A FormGroup is marked as touched once the user has triggered a blur event on any one of the controls

ix) untouched
True if the FormGroup has not been marked as touched. A FormGroup is untouched if the user has not yet triggered a blur event on any of its child controls

- setValidators() / setAsyncValidators()
Programmatically adds the sync or async validators. This method will remove all the previously added sync or async validators.

Ex -
setValidator() {
  this.reactiveForm.get("address").setValidators([addressValidator]);
  this.reactiveForm.get("address").updateValueAndValidity();
}
 
export const addressValidator = (control: AbstractControl): {[key: string]: boolean} => {
  const city = control.get('city').value;
  const state = control.get('state').value;
  console.log(control.value);
  if (city=="" && state=="") {
    return { address:false };
  }
  return null;
};

- clearValidators() / clearAsyncValidators()

Ex -
clearValidation() {
   this.reactiveForm.get("address").clearValidators();
   this.reactiveForm.get("address").updateValueAndValidity();
}

- errors()
An object containing any errors generated by failing validation, or null if there are no errors.

Ex - 
getErrors() {
 
  const controlErrors: ValidationErrors = this.reactiveForm.errors;
  if (controlErrors) {
    Object.keys(controlErrors).forEach(keyError => {
      console.log("firtname "+ ' '+keyError);
    });
  }
}


11.FormArray Example

- The FormArray is a way to Manage collection of Form controls in Angular. The controls can be aFormGroup, aFormControl, or another FormArray.

- We can group Form Controls in Angular forms in two ways. One is using the FormGroup and the other one is FormArray. The difference is how they implement it. In FormGroup controls becomes a property of the FormGroup. Each control is represented as key-value pair. While in FormArray, the controls become part of an array. Because it is implemented as Array, it makes it easier dynamically add controls.


12.Build Dynamic or Nested Forms using FormArray
Best dynamic example

- import { Component } from '@angular/core';
  import { FormGroup, FormArray, FormBuilder } from '@angular/forms'
 
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent  {
  
  title = 'Nested FormArray Example Add Form Fields Dynamically';
 
  empForm:FormGroup;
 
 
  constructor(private fb:FormBuilder) {
 
    this.empForm=this.fb.group({
      employees: this.fb.array([]) ,
    })
  }
 
 
  employees(): FormArray {
    return this.empForm.get("employees") as FormArray
  }
 
 
  newEmployee(): FormGroup {
    return this.fb.group({
      firstName: '',
      lastName: '',
      skills:this.fb.array([])
    })
  }
 
 
  addEmployee() {
    console.log("Adding a employee");
    this.employees().push(this.newEmployee());
  }
 
 
  removeEmployee(empIndex:number) {
    this.employees().removeAt(empIndex);
  }
 
 
  employeeSkills(empIndex:number) : FormArray {
    return this.employees().at(empIndex).get("skills") as FormArray
  }
 
  newSkill(): FormGroup {
    return this.fb.group({
      skill: '',
      exp: '',
    })
  }
 
  addEmployeeSkill(empIndex:number) {
    this.employeeSkills(empIndex).push(this.newSkill());
  }
 
  removeEmployeeSkill(empIndex:number,skillIndex:number) {
    this.employeeSkills(empIndex).removeAt(skillIndex);
  }
 
  onSubmit() {
    console.log(this.empForm.value);
  }
 
 
}
 
 
export class country {
  id: string;
  name: string;
 
  constructor(id: string, name: string) {
    this.id = id;
    this.name = name;
  }
}

<h1>{{title}}</h1>
 
<form [formGroup]="empForm" (ngSubmit)="onSubmit()">
 
  <div formArrayName="employees">
 
    <div *ngFor="let employee of employees().controls; let empIndex=index">
 
      <div [formGroupName]="empIndex" style="border: 1px solid blue; padding: 10px; width: 600px; margin: 5px;">
        {{empIndex}}
        First Name :
        <input type="text" formControlName="firstName">
        Last Name:
        <input type="text" formControlName="lastName">
 
        <button (click)="removeEmployee(empIndex)">Remove</button>
 
 
        <div formArrayName="skills">
 
          <div *ngFor="let skill of employeeSkills(empIndex).controls; let skillIndex=index">
 
 
 
            <div [formGroupName]="skillIndex">
              {{skillIndex}}
              Skill :
              <input type="text" formControlName="skill">
              Exp:
              <input type="text" formControlName="exp">
 
              <button (click)="removeEmployeeSkill(empIndex,skillIndex)">Remove</button>
 
            </div>
 
          </div>
          <button type="button" (click)="addEmployeeSkill(empIndex)">Add Skill</button>
        </div>
 
 
      </div>
 
    </div>
  </div>
 
  <p>
    <button type="submit">Submit</button>
  </p>
 
</form>
 
 
<p>
  <button type="button" (click)="addEmployee()">Add Employee</button>
</p>
 
{{this.empForm.value | json}}

https://github.com/tekTutorialsHub/Angular2-Forms 

13.SetValue & PatchValue in FormArray

Best example of Form Array
<h1>{{title}}</h1>
 
<form [formGroup]="teachersForm" (ngSubmit)="onSubmit()">
 
  <div formArrayName="teachers">
 
    <div *ngFor="let teacher of teachers().controls; let ti=index">
 
      <div [formGroupName]="ti"
        style="border: 1px solid blue; padding: 10px; width: 100%; display: inline-block; margin: 5px;">
        Teachers Name :
        <input type="text" formControlName="name">
        <button (click)="removeTeacher(ti)">Remove</button>
        <button type="button" (click)="addBatch(ti)">Add Batch</button>
 
        <div formArrayName="batches">
 
          <div *ngFor="let batch of batches(ti).controls; let bi=index">
 
            <div [formGroupName]="bi" style="border: 1px solid red; padding: 10px; margin: 5px; float:left">
 
              Batch Name :
              <input type="text" formControlName="name">
              <button (click)="removeBatch(ti,bi)">Remove Batch</button>
              <button (click)="addStudent(ti,bi)">Add Student</button>
 
              <div formArrayName="students">
 
                <div *ngFor="let batch of students(ti,bi).controls; let si=index">
                  <div [formGroupName]="si" style="border: 1px solid blue; padding: 2px; ">
                    Student Name :
                    <input type="text" formControlName="name">
                    <button (click)="removeStudent(ti,bi,si)">Remove student</button>
                  </div>
                </div>
 
              </div>
 
            </div>
 
          </div>
 
        </div>
 
      </div>
 
    </div>
 
  </div>
 
  <p>
    <button type="button" (click)="addTeacher()">Add Teacher</button>
  </p>
  <p>
    <button type="submit">Submit</button>
  </p>
 
</form>
 
{{this.teachersForm.value | json}}

import { Component } from '@angular/core';
import { FormGroup, FormArray, FormBuilder } from '@angular/forms'
 
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
 
  title = 'FormArray SetValue & PatchValue Example';
 
  teachersForm: FormGroup;
 
  constructor(private fb: FormBuilder) {
    this.teachersForm = this.fb.group({
      teachers: this.fb.array([]),
    })
  }
 
 
  /** Teachers */
  teachers(): FormArray {
    return this.teachersForm.get("teachers") as FormArray
  }
 
  newTeacher(): FormGroup {
    return this.fb.group({
      name: '',
      batches: this.fb.array([])
    })
  }
 
 
  addTeacher() {
    this.teachers().push(this.newTeacher());
  }
 
 
  removeTeacher(ti) {
    this.teachers().removeAt(ti);
  }
 
 
  /** batches */
 
  batches(ti): FormArray {
    return this.teachers().at(ti).get("batches") as FormArray
  }
 
 
  newBatch(): FormGroup {
    return this.fb.group({
      name: '',
      students: this.fb.array([])
    })
  }
 
  addBatch(ti: number) {
    this.batches(ti).push(this.newBatch());
  }
 
  removeBatch(ti: number, bi: number) {
    this.batches(ti).removeAt(ti);
  }
 
  /** students */
 
  students(ti, bi): FormArray {
    return this.batches(ti).at(bi).get("students") as FormArray
  }
 
  newStudent(): FormGroup {
    return this.fb.group({
      name: '',
    })
  }
 
  addStudent(ti: number, bi: number) {
    this.students(ti, bi).push(this.newStudent());
  }
 
  removeStudent(ti: number, bi: number, si: number) {
    this.students(ti, bi).removeAt(si);
  }
 
  onSubmit() {
    console.log(this.teachersForm.value);
  }
 
}
 
 
* How to load initial data in FormArray
When the form is loads for the first time, it will not have any controls in the FormArray. Calling PatchValue or SetValue will have no effect.

The patchValue1 method in the following example tries to load the data. The data contains one teacher managing two batches with three students in each batch.

patchValue1() {
    console.log('patchValue1')
    var data = {
      teachers: [
        {
          name: 'Teacher 1', batches: [
            { name: 'Batch No 1', students: [{ name: 'Ramesh' }, { name: 'Suresh' }, { name: 'Naresh' }] },
            { name: 'Batch No 2', students: [{ name: 'Vikas' }, { name: 'Harish' }, { name: 'Lokesh' }] },
          ]
        }
      ]
    }
 
    this.teachersForm.patchValue(data);
}
 
<p>
  <button (click)="patchValue1()">PatchValue1</button>
</p>

https://www.tektutorialshub.com/angular/setvalue-patchvalue-in-formarray-angular/

14.Select Options Dropdown

Ex -
<form [formGroup]="contactForm" (ngSubmit)="submit()">
 
<p>
 
  <select formControlName="country">
    <option [ngValue]="null" disabled>Select Country</option>
    <option *ngFor="let country of countries" [ngValue]="country.id">{{country.name}}</option>
  </select>
 
  <button type="submit">Submit</button>
</p>
 
</form>

- <option [ngValue]="null" disabled > displays the Select Country when no value for country is selected or country is null

The ngFor loops through the "countries" array and displays the country.name in the drop down. You can also display the country.name - country.id or any other property of the country

We want to return the id of the country. Hence we use the [ngValue]="country.id". You can also use [ngValue]="country", in which case it will return the country object.


* Services & Dependency Injection
https://www.tektutorialshub.com/angular/angular-services/

1.Services

- Service is a piece of reusable code with a focused purpose. A code that you will use it in many components across your application

* What services are used for
i. Features that are independent of components such a logging services
ii. Share logic or data across components
iii. Encapsulate external interactions like data access

* Advantageous of Service
i. Services are easier to test.
ii. Services are easier to Debug.
iii. You can reuse the service.

- Directly instantiating the service, as shown above, has many disadvantageous

i. The ProductService is tightly coupled to the Component. If we change the ProductService class definition, then we need to update every code where service is used
ii. If we want to change ProductService with BetterProductService, then we need to search wherever the ProductService is used and manually change it
iii. Makes Testing difficult. We may need to provide mockProductService for testing and use the ProductService for Production.
This problem can be solved by Angular Dependency injection.

- Services allow us to create reusable code and use it every component that needs it. The Services can be injected into components and other services using the dependency injection system. The dependencies are declared in the Module using the Provider’s metadata. The Angular creates a tree of injector & Providers that resembles the Component Tree. This is called the hierarchical pattern.

2.Dependency injection
https://www.tektutorialshub.com/angular/angular-dependency-injection/

- Dependency Injection (DI) is a technique in which we provide an instance of an object to another object, which depends on it. This is technique is also known as “Inversion of Control” (IoC)

- How to solve all these problems. Move the creation of ProductService to the constructor the AppComponent class as shown below.
Ex -
constructor(private productService:ProductService) {}

The above pattern is known as Dependency Injection Pattern.

* Why use Dependency Injection
- Our Component is now loosely coupled to the ProductService. AppComponent does not know how to create the ProductService. 

AppComponent is now easier to Test. Our AppComponent is not dependent on a Particular implementation of ProductService anymore. It will work with any implementation of ProductService that is passed on to it. You can just create a mockProductService Class and pass it while testing.

Reusing of the component is becomes easier. Our Component will now work with any ProductService as long as the interface is honored.

Dependency injection pattern made our AppComponent testable, maintainable etc.

But does it solve all our Problem ?. No, we just moved the Problem out of Component to the Creator of the Component.

How do we create an instance of ProductService and pass it to the AppComponent? That is what Angular Dependency Injection does.

- Angular Dependency Injection framework implements the Dependency injection Pattern in Angular. It creates & maintains the Dependencies and injects them into the Components or Services which requests for it.

* Parts of Angular Dependency Injection Framework 

i) Consumer
- The Component that needs the Dependency. In the above example, the AppComponent is the Consumer

ii) Dependency
- The Service that is being injected. In the above example the ProductService is the Dependency

iii) DI Token
- The DI Token uniquely identifies a Dependency. We use DI Token when we register dependency

iv) Provider
- The  Providers Maintains the list of Dependencies along with their Tokens. The DI Token is used to identify the Dependency.  

v) Injector
- Injector holds the Providers and is responsible for resolving the dependencies and injecting the instance of the Dependency to the Consumer

- The dependencies are registered with the Provider. This is done in the Providers metadata of the Injector.

Angular Provides an instance of Injector & Provider to every Consumer.

Consumer when instantiated, It declares the Dependencies it needs in its constructor.

Injector reads the Dependencies from the constructor of the Consumer and looks for the dependency in the provider. The Provider provides the instance and injector, then injects it into the consumer. If the instance of the Dependency is already exists, then it is reused making the dependency singleton.

- @Injectable() decorator is not needed, if the class already has other Angular decorators like @Component, @pipe or @directive etc. Because all these are a subtype of Injectible.

- @Injectible is also not needed if the class does not have any dependencies to be injected. However it is best practice is to decorate every service class with @Injectable(), even those that don’t have dependencies.     

- The Services are usually not added to Providers array of the Component, but to the Providers array of the @NgModule. Then they will be available to be used in all the components in the application

- Angular  does not have any options add providers in the Service Class. The Providers must be added to the Component/Directive/Pipe or to the Module.

- The services injected at the module level are app-scoped, which means that they can be accessed from every component/service within the app.Any service provided in the Child Module is available in the entire application.

- The services is provided in a lazy module are module scoped and available only to the lazy loaded module.

- The services provided in the Component level are available only to the Component & and to the child components.



3.Injector, @Injectable & @Inject
https://www.tektutorialshub.com/angular/angular-injector-injectable-inject/

- The Angular Injector is responsible instantiating the dependency and injecting into the component or service.

The Injector looks for the dependency in the Angular Providers using the token. The Angular Providers array returns the Provider, which contains the information about how to create the instance of the dependency. The Injector creates the instance and injects it into Component or service.

- The Root Component contains all other components. Angular App will create child components under the Root Component. All these child component can have their own child components creating a tree of components. The Angular Injector is also created for all those components creating a Injector tree closely mimicking the component tree.

4.Providers
- There are four ways by which you can create the dependency: They are Class Provider (useClass), Value Provider (useValue ), Factory Provider ( useFactory ), and Aliased Class Provider ( useExisting).

- The Angular Provider is an instruction (or recipe) that describes how an object for a certain token is created. The Angular Providers is an array of such instruction (Provider). Each provider is uniquely identified by a token (or DI  Token ) in the Providers Array.

- Registered our ProductService using the Providers arrays as shown below in the @NgModule
providers :[{ provide: ProductService, useClass: ProductService }]

Shorthand notation of above
providers: [ProductService]

* Types of DI Token

i) Type Token
providers :[{ provide: ProductService, useClass: ProductService }]

class ProductComponent {
  constructor(private productService : ProductService ) {}
}

ii) String token
 {provide:'PRODUCT_SERVICE', useClass: ProductService },   

class ProductComponent {
   constructor(@Inject('PRODUCTSERVICE') private prdService:ProductService ) { 
}

Ex -
{provide:'USE_FAKE', useValue: true },   
 {provide:'APIURL', useValue: 'http://SomeEndPoint.com/api' },   
 
class ProductComponent {
   constructor(@Inject('APIURL') private apiURL:string )
}

iii) Injection Token
The Problem with the string tokens is that two developers can use the same string token at a different part of the app. You also do not have any control over the third-party modules, which may use the same token. If the token is reused, the last to register overwrites all previously registered tokens.

String tokens are easier to mistype and that makes it difficult to track & maintain in big applications.

The Angular provides InjectionToken class so as to ensure that the Unique tokens are created. The Injection Token is created by creating a new instance of the InjectionToken class.

Ex -
First, create a separate file and name it as tokens.ts. Import the InjectionToken from @angular/core library. Create an instance of InjectionToken and assign it to a const API_URL

import { InjectionToken } from '@angular/core';
 
export const API_URL= new InjectionToken<string>(''); 

Open the AppModule and the Token is used to register the value in providers metadata

import { API_URL } from './tokens';
 
providers: [ 
    { provide: API_URL, useValue: 'http://SomeEndPoint.com/api' }
]
 
It is then injected using the @Inject in the constructor of the service/component.

import { API_URL } from './tokens';
 
constructor(@Inject(API_URL) private apiURL: string) { 
}

* The Types of Provider 

i) Class Provider : useClass
ii) Value Provider: useValue
iii) Factory Provider: useFactory
iv) Aliased Class Provider: useExisting

5.Hierarchical Dependency Injection
https://www.tektutorialshub.com/angular/angular-hierarchical-dependency-injection/

- The Angular creates the Injector, when the application root module (named as AppModule) is bootstrapped. This injector is called as root injector and acts as a parent to all other injectors. The root injector also gets its own copy of Providers. It gets it from the Providers is metadata of @NgModule of AppModule.

- What happens if the child1Component requests a Service. The injector attached to Child1Component looks for the provider in the Providers collection registered with the Child1Component.

If it does not find the provider, it then passes the request to the injector instance of the parent1Component as shown by the dotted arrow in the image above. If the provider is found, the request is returned with the instance of the dependency else the request is passed on the injector of the AppComponent. This process continues until it reaches the top-level injector.

- 

* Angular Forms Validation
https://www.tektutorialshub.com/angular/angular-reactive-forms-validation/

1.Validations in Reactive Forms in Angular
- A Validator is a function that checks the instance of FormControl, FormGroup or a FormArray and returns a list of errors. If the Validator returns a null means that validation has passed

- sync validators runs validations and returns immediately. They either return a list of errors or null if no errors found.

- async validators: returns a Promise or Observable. They either return a list of errors or null if no errors are found.

- First, we need to disable browser validator by adding the novalidate attribute to the <form> element as shown below. If this attribute is present then the form is not validated by the built-in HTML5 validation when submitted.

<form [formGroup]="contactForm" (ngSubmit)="onSubmit()" novalidate>

<button type="submit" [disabled]="!contactForm.valid">Submit</button>

- Displaying the Validation/Error messages
i) Ex -
<div
    *ngIf="!contactForm.controls.firstname?.valid && (contactForm.controls.firstname?.dirty
    ||contactForm.controls.firstname?.touched)">
      First Name is not valid
  </div>

ii) Ex -
<div *ngIf="!firstname.valid && (firstname.dirty ||firstname.touched)">
      First Name is not valid
  </div>
  
- Apart from checking valid we are also checking for the dirty & touched. Because we do not want the application to display the error when the form is displayed for the first time. We want to display errors only after the user has attempted to change the value. The dirty & touched properties help us do that.

dirty: A control is dirty if the user has changed the value in the UI.
touched: A control is touched if the user has triggered a blur event on it.

Ex -
<div
    *ngIf="!firstname?.valid && (firstname?.dirty ||firstname?.touched)">
    <div [hidden]="!firstname.errors.required">
      First Name is required
    </div>
    <div [hidden]="!firstname.errors.minlength">
      Min Length is 10
    </div>
  </div>


2.Custom Validator in Reactive Forms

- Building a custom Validator is as easy as creating a Validator function. It is a function, which must implement ValidatorFn Interface.

- The ValidatorFn is an Interface, which defines the signature of the Validator function.

Ex -
interface ValidatorFn {
  (control: AbstractControl): ValidationErrors | null
}

- The function takes the AbstractControl. This is the base class for FormControl, FormGroup, and FormArray. The validator function must return a list of errors i.e ValidationErrors or null if the validation has passed

Our example app has numVal form field. We want it to be greater than 10.

Ex -
import { AbstractControl, ValidationErrors } from '@angular/forms'
 
export function gte(control: AbstractControl): ValidationErrors | null {
 
    const v=+control.value;
 
    if (isNaN(v)) {
      return { 'gte': true, 'requiredValue': 10 }
    }      
 
    if (v <= 10) {
      return { 'gte': true, 'requiredValue': 10 }
    } 
 
    return null
 
}

- If the validation fails then return the ValidationErrors. You can use anything for the key, but it is advisable to use the name of the validator i.e gte as the key. Also, assign true as value. You can as well assign a string value.

- You can return more than one key-value pair as shown in the above example. The second key requiredValue returns the value 10. We use this in the template to show the error message.

Ex -
 myForm = new FormGroup({
    numVal: new FormControl('', [gte]),
  })

<div>
    <label for="numVal">Number :</label>
    <input type="text" id="numVal" name="numVal" formControlName="numVal">
    <div *ngIf="!numVal.valid && (numVal.dirty ||numVal.touched)">
      <div *ngIf="numVal.errors.gte">
        The number should be greater than {{numVal.errors.requiredValue}}
      </div>
    </div>
</div>

- The problem with the above validator is that the value 10 is hardcoded. Hence, we will be not able to reuse it. If we want to resue it, we need to pass the number as the parameter.

3.Passing Parameter to Custom Validator in Reactive Forms

- To pass a parameter, we need to create a factory function or a function that returns a function. The example code is as shown below

Ex -
export function gte(val: number): ValidatorFn {
 
  return (control: AbstractControl): ValidationErrors | null => {
 
    let v: number = +control.value;
 
    if (isNaN(v)) {
      return { 'gte': true, 'requiredValue': val }
    }      
 
    if (v <= +val) {
      return { 'gte': true, 'requiredValue': val }
    } 
      
    return null;
    
  }
 
}

myForm = new FormGroup({
    numVal: new FormControl('', [gte(10)]),
  })

<label for="numVal">Number :</label>
    <input type="text" id="numVal" name="numVal" formControlName="numVal">
    <div *ngIf="!numVal.valid && (numVal.dirty ||numVal.touched)">
      <div *ngIf="numVal.errors.gte">
        The number should be greater than {{numVal.errors.requiredValue}}
      </div>
    </div>



4.Inject Service into Custom Validator

- The gte method takes val and requiredValue as the parameter. It checks if the val is a number and is greater than requiredValue. If yes returns true else returns false.

Ex -
import { Injectable } from '@angular/core';
 
@Injectable({
  providedIn: 'root',
})
export class gteService {
 
  gte(num:any, requiredValue:Number) : Boolean {
 
    if (isNaN(num)) {
      return false;
    }      
  
    if (num <= +requiredValue) {
      return false;
    }
 
    return true;
  }
}

- There are two ways you can inject service into the validator. One is to create a wrapper service. The other option is to inject service directly into the validator.

i) Wrapper Service
Open the gte.validator.ts. Create the gteValidatorService class. In the constructor inject the gteService. Copy the validator functiongte into the class and use the gteService as shown below

import { AbstractControl, ValidationErrors, ValidatorFn, Validator, NG_VALIDATORS, FormControl } from '@angular/forms'
import { gteService } from './gte.service';
import { Directive, OnInit, forwardRef, Input, Injectable } from '@angular/core';
 
@Injectable({
  providedIn: 'root',
})
export class gteValidatorService {
 
  constructor(private gteService: gteService) {
  }
 
  gte(val: number): ValidatorFn {
 
    return (control: AbstractControl): ValidationErrors | null => {
  
      let v: number = +control.value;
      if (!this.gteService.gte(v,val)) {
        return { 'gte': true, 'requiredValue': val }
      }
  
      return null;
    }
  }
}

constructor(private gteValidator:gteValidatorService) {
  }
 
 
  myForm = new FormGroup({
    numVal: new FormControl('', [this.gteValidator.gte(10)]),
  })

ii) Inject Service directly into the Validator

import { AbstractControl, ValidationErrors, ValidatorFn, Validator, NG_VALIDATORS, FormControl } from '@angular/forms'
import { gteService } from './gte.service';
import { Directive, OnInit, forwardRef, Input, Injector } from '@angular/core';
 
export function gte(val: number): ValidatorFn {
 
  return (control: AbstractControl): ValidationErrors | null => {
 
    let injector = Injector.create([ { provide: gteService, useClass:gteService,deps: []}])
    let service = injector.get(gteService);
 
    let v: number = +control.value;
    if (!service.gte(v, val)) {
      return { 'gte': true, 'requiredValue': val }
    }
 
    return null;
 
  }
}

5.Validation in Template Driven Forms

- Adding in Built-in Validators
Ex -
<input type="text" id="firstname" name="firstname" required [(ngModel)]="contact.firstname">

<input type="text" id="firstname" name="firstname" required minlength="10" [(ngModel)]="contact.firstname">

<input type="text" id="lastname" name="lastname" required maxlength="15" [(ngModel)]="contact.lastname">

<input type="text" id="lastname" name="lastname" required maxlength="15" 
    pattern="^[a-zA-Z]+$" [(ngModel)]="contact.lastname">

<input type="text" id="email" name="email" required email [(ngModel)]="contact.email">



6.Custom Validator in Template Driven Forms
7.Angular Async Validator
https://www.tektutorialshub.com/angular/angular-async-validator-example/

- The creating an async validator is very similar to the Sync validators. The only difference is that the async Validators must return the result of the validation as an observable (or as Promise).

- Creating a Async Validator is simple as creating a function, which must obey the following rules

i) The function must implement the AsyncValidatorFn Interface, which defines the signature of the validator function.
ii) The function must return either an observableor a promise
iii) Return null for valid, or an ValidationErrors if the input is invalid

Ex -
import { AbstractControl, ValidationErrors } from '@angular/forms'
 
import { Observable, of } from 'rxjs';
 
export function gte(control: AbstractControl): 
         Observable<ValidationErrors> | null {
 
    const v:number=+control.value;
 
    console.log(v)
    
    if (isNaN(v)) {
      return of({ 'gte': true, 'requiredValue': 10 })
    }      
 
    if (v <= 10) {
      return of({ 'gte': true, 'requiredValue': 10 })
    } 
 
    return of(null)
 
}


8.Cross Field Validation

- Some times we also come across fields whose value depends on another field. For example, the following scenario’s requires us to compare two fields.

i) Start date & end date fields. The end date must be greater than the start date.
ii) Password confirmation. The new password must match the confirm password.

- When we validate the multiple fields, we need to ensure that our validation logic runs for each of those fields.

Hence we attach the validator to the Formgroup instead of FormControl. The Validator runs whenever we modify any of the fields in the FormGroup.

Ex -
this.mainForm = this.builder.group({
      userName: ["", [Validators.required]],
      password: ["", [Validators.required, Validators.minLength(5)]],
      confirm: ["", [Validators.required]]
    }, { validator: this.matchPassword2('password', 'confirm') });

matchPassword2(firstControl, secondControl): ValidatorFn {
 
    return (control: AbstractControl): ValidationErrors | null => {
 
      const password = control.get(firstControl).value;
      const confirm = control.get(secondControl).value;
 
      if (password != confirm) { return { 'noMatch': true } }
 
      return null
 
    }
  }
  

9.Adding Validators Using SetValidators
- There are many use cases where it is required to add/remove validators dynamically to a FormControl or FormGroup. Usually when you have a Form Field, whose value depends on another Form Field.

- The setValidators programmatically adds the sync validators. This method will remove all the previously added sync or async validators.

Ex -
this.myform.controls["mobile"].setValidators(Validators.required);

this.myform.controls["mobile"].setValidators([Validators.required,Validators.minLength(10)]);

- But, The setAsyncValidators programmatically add the Async validators.

- setValidators overwrites all existing Validators. Hence it is very important to include all the validators that we want in the setValidators method

- There is no option that exists, which can remove an individual validator. Use clearValidators to remove all the validators of a control.

Ex -
this.myForm.controls['controlName'].clearValidators()

- We have two fields email & mobile.

The user needs to choose, how he wants the system to notify him, using the drop-down field notifyVia. The drop-down has two options email & Mobile.

If the user chooses email, then we need to make the email field as a Required field. If he chooses the Mobile, then we must make the mobile field as Required field.

We subscribe to the valueChanges event of the notifyVia to listen for changes and invoke the changeValidators method.

In the changeValidators method, we check the value of notifyVia and add or remove the required validator using the setValidators. We also add the email validator (for email field) or MinLength validator (for mobile field). To remove the validator, we use the method clearValidators()

Finally, we use the updateValueAndValidity method, which forces the angular to update the validity status of the control.

Ex -
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, FormControl, Validators } from '@angular/forms';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
})
export class AppComponent {
  title = 'setValidators';
 
  myform:FormGroup;
 
  notifyOptions = ["Email" ,"SMS"]
 
  constructor(private fb: FormBuilder) {
 
    this.myform = this.fb.group({
      email: new FormControl(''),
      mobile: new FormControl(''),
      notifyVia: new FormControl('',Validators.required),
    });
 
    this.myform.get("notifyVia").valueChanges
      .subscribe(data=> {
        this.changeValidators()
      })
  }
 
 
  changeValidators() {
    console.log(this.myform.get("notifyVia").value)
 
    if (this.myform.get("notifyVia").value=="Email") {
      this.myform.controls["email"].setValidators([Validators.required,Validators.email]);
      this.myform.controls["mobile"].clearValidators();
    } else {
      this.myform.controls["email"].clearValidators();
      this.myform.controls["mobile"].setValidators([Validators.required,Validators.minLength(10)]);
    }
 
    this.myform.get("email").updateValueAndValidity();
    this.myform.get("mobile").updateValueAndValidity();
 
  }
}

<form [formGroup]="myform">
 
  notify :
<select formControlName="notifyVia">
  <option *ngFor="let item of notifyOptions" [ngValue]="item">{{item}}</option>
</select>
<br>
<br>
 
 
email :
<input type="text" formControlName= "email"/>
<br>
<br>
mobile :
<input type="text" formControlName= "mobile"/>
<br>
<br>
 
<button type="submit" >Submit </button>
</form>
 
<br>
<br>
 
Form valid ---- {{myform.valid}}  <br>
 
email valid-- {{myform.controls['email'].valid}}  <br>
 
mobile valid -- {{myform.controls['mobile'].valid}}  <br>



*  HTTP 
https://www.tektutorialshub.com/angular/angular-httpclient/

- The newly designed HttpClient Module allows us to query the Remote API source to get data into our Application. It requires us to Subscribe to the returned response using RxJs observables.

1.Angular HTTP Client Tutorial

- The HttpClient is a separate model in Angular and is available under the @angular/common/http package.

- Observable help us to manage async data. You can think of Observables as an array of items, which arrive asynchronously over time.

- When an Observer subscribes to an observable, it needs to pass (optional) the three callbacks. next(),  error()  &  complete(). The observable invokes the next() callback, when it receives an value. When the observable completes it invokes the complete() callback. And when the error occurs it invokes the error() callback with details of error and subscriber finishes.

- Observables Operators
Operators are methods that operate on an Observable and return a new observable. Each Operator modifies the value it receives. These operators are applied one after the other in a chain. The RxJs provides several Operators, which allows you to filter, select, transform, combine and compose Observables. Examples of Operators are map, filter, take, merge, etc

- HTTP Get

Syntax:
get(url: string, 
      options: {
          headers?: HttpHeaders | { [header: string]: string | string[]; };
          params?: HttpParams | { [param: string]: string | string[]; };
          observe?: "body|events|response|";
          responseType: "arraybuffer|json|blob|text";
          reportProgress?: boolean; 
          withCredentials?: boolean;}
     ): Observable<>
	 
- By default, the body of the response is parsed as JSON. If you want any other type, then you need to specify explicitly using the observe & responseType options.

- headers : It allows you to add HTTP headers to the outgoing requests. 

observe: The HttpClient.get method returns the body of the response parsed as JSON (or type specified by the responseType). Sometimes you may need to read the entire response along with the headers and status codes. To do this you can set the observe property to the response.

response: which returns the entire response

body: which returns only the body

events: which return the response with events.

params: Allows us to Add the URL parameters or Get Parameters to the Get Request

reportProgress: This is a boolean property. Set this to true, if you want to get notified of the progress of the Get Request. This is a pretty useful feature when you have a large amount of data to download (or upload) and you want the user to notify of the progress.

responseType: Json is the default response type. In case you want a different type of response, then you need to use this parameter. The Allowed Options are arraybuffer, blob, JSON, and text. 

withCredentials: It is of boolean type. If the value is true then HttpClient.get will request data with credentials (cookies)


- HTTP Post

Syntax:
post(url: string, 
     body: any, 
     options: { 
        headers?: HttpHeaders | { [header: string]: string | string[]; }; 
        observe?: "body|events|response|"; 
        params?: HttpParams | { [param: string]: string | string[]; }; 
        reportProgress?: boolean; 
        responseType: "arraybuffer|json|blob|text"; 
        withCredentials?: boolean; 
     }
): Observable

Ex -
addPerson(person:Person): Observable<any> {
    const headers = { 'content-type': 'application/json'}  
    const body=JSON.stringify(person);
    this.http.post(this.baseURL + 'people', body,{'headers':headers , observe: 'response'})
      .subscribe(
       response=> {
            console.log("POST completed sucessfully. The response received "+response);
        },
        error => {
            console.log("Post failed with the errors");
        },
        () => {
            console.log("Post Completed");
        }
}

- HTTP PUT

Syntax:
put(url: string, 
     body: any, 
     options: { 
        headers?: HttpHeaders | { [header: string]: string | string[]; }; 
        observe?: "body|events|response|"; 
        params?: HttpParams | { [param: string]: string | string[]; }; 
        reportProgress?: boolean; 
        responseType: "arraybuffer|json|blob|text"; 
        withCredentials?: boolean; 
     }
): Observable

- HTTP PATCH

Syntax:
patch(url: string, 
     body: any, 
     options: { 
        headers?: HttpHeaders | { [header: string]: string | string[]; }; 
        observe?: "body|events|response|"; 
        params?: HttpParams | { [param: string]: string | string[]; }; 
        reportProgress?: boolean; 
        responseType: "arraybuffer|json|blob|text"; 
        withCredentials?: boolean; 
     }
): Observable

- HTTP DELETE

Syntax:
delete(url: string, 
      options: {
          headers?: HttpHeaders | { [header: string]: string | string[]; };
          params?: HttpParams | { [param: string]: string | string[]; };
          observe?: "body|events|response|";
          responseType: "arraybuffer|json|blob|text";
          reportProgress?: boolean; 
          withCredentials?: boolean;}
     ): Observable<>


2.HTTP GET Example
https://www.tektutorialshub.com/angular/angular-http-get-example-using-httpclient/

- When the observable completes, it will call the complete() callback. There is no need for this call back as the subscription completes when the data is received.

3.HTTP POST Example
https://www.tektutorialshub.com/angular/angular-http-post-example/



4.Passing URL Parameters (Query strings)

- Construct a new body with a new value for the given parameter name. If the parameter already exists then it is replaced else it is added.

Ex -
params = new HttpParams()
    .set('page', '2')
    .set('page', '3')
    .set('sort', 'name');
 
console.log(params.toString()); //Returns page=3&sort=name

- The HttpParams object is immutable. Every time you call a set method on Params object, it will create and return a new instance of the Params.
The following code does not work
 
let params = new HttpParams();
params.set('page', PageNo);
params.set('sort', SortOn);

To work around, you can use the code as follows

let params = new HttpParams()
    .set('page', PageNo)
    .set('sort', SortOn);

let params = new HttpParams();
params=params.set('page', PageNo);
params=params.set('sort', SortOn);
params=params.append('page', PageNo);

- Returns true if the given parameter name already exists in the HttpParams

params = new HttpParams()
    .set('sort', 'name');
 
if (!params.has('page')) {
    params = params.set('page', PageNo)
}

console.log(params.getAll('page')); // Returns ["2", "3"] All occurance of Page

console.log(params.keys()); //Returns ["page", "sort"]



5.HTTP Headers Example

- There are two ways by which we can add the headers. One, we add the HTTP Headers while making a request. The second way is to use the HTTP interceptor to intercept all the Requests and add the Headers. In both cases, we use the httpHeaders configuration option provided by angular HttpClient to add the headers.

- We add HTTP Headers using the HttpHeaders helper class. It is passed as one of the arguments to the GET, POST, PUT, DELETE, PATCH & OPTIONS request.

- Then create an instance of the class
Ex -
const headers= new HttpHeaders()
  .set('content-type', 'application/json')
  .set('Access-Control-Allow-Origin', '*');
  
 return this.httpClient.get(this.baseURL + 'users/' + userName + '/repos', { 'headers': headers })

- The HTTP headers are immutable. The following example does not work as each set method returns a new header and does not update the original header.
**WRONG**
let headers = new HttpHeaders()
headers .set('content-type', 'application/json')
headers .set('Access-Control-Allow-Origin', '*')

To work around, you can use the code as follows

const headers= new HttpHeaders()
  .set('content-type', 'application/json')
  .set('Access-Control-Allow-Origin', '*');
  
- The append method appends a new value to the existing set of values for a header and returns a new instance. The append method does not check if the value exists.

Ex -
let headers = new HttpHeaders()
 
headers=headers.append('content-type','application/json')
headers=headers.append('Access-Control-Allow-Origin', '*')
headers=headers.append('content-type','application/x-www-form-urlencoded')
 
console.log(headers)
The above results in content-type header in the request header as content-type: application/json,application/x-www-form-urlencoded

- Most headers we add to the HTTP Request in the entire application likely to remain the same. Adding them to every GET, POST, PUT, etc requests are cumbersome. Instead, you can make use of the HTTP Interceptors to intercept every request and add the commonly used headers. Refer to our tutorial on how to set HttpHeaders using HTTP Interceptors


6.HTTP Interceptor
- The Angular HTTP interceptors sit between our application and the backend. When the application makes a request, the interceptor catches the request before it is sent to the backend. By Intercepting requests, we will get access to request headers and the body. This enables us to transform the request before sending it to the Server. 

- When the response arrives from the back end the Interceptors can transform it before passing it to our application.

- One of the main benefits of the Http Interceptors is to add the Authorization Header to every request. We could do this manually, but that is a lot of work and error-prone. Another benefit is to catch the errors generated by the request and log them.

** Read this article from somewhere **

* Angular Router

https://www.tektutorialshub.com/angular/angular-routing-navigation/


- The Router module handles the navigation & Routing in Angular. The Routing allows you to move from one part of the application to another part or one View to another View. 

1. Routing and Navigation in Angular
- Routing allows you to move from one part of the application to another part or one View to another View.

- The Router is a separate module in Angular. It is in its own library package, @angular/router. The Router Module provides the necessary service providers and directives for navigating through application views.

- Using Angular Router you can

i. Navigate to a specific view by typing a URL in the address bar
ii. Pass optional parameters to the View
iii. Bind the clickable elements to the View and load the view when the user performs application tasks
iv. Handles back and forward buttons of the browser
v. Allows you to dynamically load the view
vi. Protect the routes from unauthorized users using Guards

- Router 
The Angular Router is an object that enables navigation from one component to the next component as users perform application tasks like clicking on menus links, buttons or clicking on back/forward button on the browser. We can access the router object and use its methods like navigate() or navigateByUrl(), to navigate to a route

- Route 
Route tells the Angular Router which view to display when a user clicks a link or pastes a URL into the browser address bar. Every Route consists of a path and a component it is mapped to. The Router object parses and builds the final URL using the Route

- Routes 
Routes is an array of Route objects our application supports

- RouterOutlet
The outerOutlet is a directive (<router-outlet>) that serves as a placeholder, where the Router should display the view

- RouterLink
The RouterLink is a directive that binds the HTML element to a Route. Clicking on the HTML element, which is bound to a RouterLink, will result in navigation to the Route. The RouterLink may contain parameters to be passed to the route’s component.

- RouterLinkActive
RouterLinkActive is a directive for adding or removing classes from an HTML element that is bound to a RouterLink. Using this directive, we can toggle CSS classes for active RouterLinks based on the current RouterState

- ActivatedRoute
The ActivatedRoute is an object that represents the currently activated route associated with the loaded Component.

- RouterState
The current state of the router including a tree of the currently activated routes together with convenience methods for traversing the route tree.

- RouteLink Parameters array
The Parameters or arguments to the Route. It is an array which you can bind to RouterLink directive or pass it as an argument to the Router.navigate method.

- Import the Router Module from @angular/router library in the root module of the application. Then, install the routes using the RouterModule.forRoot method, passing the routes as the argument in the imports array

imports: [RouterModule.forRoot(routes)],

- Ex -
{ path: '', redirectTo: 'home', pathMatch: 'full' },

The path is empty, indicates the default route. The default route is redirected to the home path using the RedirectTo argument. This route means that, when you navigate to the root of your application /, you are redirected to the home path (/home), which in turn displays the HomeComponent.

Note, that we have pathMatch argument set to ‘full’. The pathMatch tells the Router how to match the URL.

When it is set to full, the path is matched to the entire URL

Every route ends in an empty space for ex: /contact/’’. If pathMatch is not set to full then the router will apply the redirect, which results in the error.

Wild Card Route
{ path: '**', component: ErrorComponent }
The “**” matches every URL. The Router will display the ErrorComponent.

- Note that the order of the route is important. The Routes are matched in the order they are defined. The Router always returns the first matching route (first-match-wins strategy)

Since the wildcard route (**) matches every URL and should be placed last.

- the forRoot method is used, when you want to provide the service and also want to configure the service at the same time

- The routermodule.forroot method returns the Router Service configured with the routes passed in the argument and also registers the Router service. It also registers the other providers that the routing module requires.

- When the application is bootstrapped, the Router service looks at the current browser URL and performs the initial navigation.

When the user changes the URL either clicking on a link in the page or by entering a URL in the address bar, the router looks for a corresponding Route from the Routes array and renders the associated component.

2. Location Strategies in Angular Router

- Angular supports two Location Strategies:
i. HashLocationStrategy
Where URL looks like http://localhost:4200/#/product

ii. PathLocationStrategy
Where URL looks like http://localhost:4200/product

- The introduction of HTML5, now allows browsers to programmatically alter the browser’s history through the history object.

Using history.pushState() method, we can now programmatically add the browser history entries and change the location without triggering a server page request.

The history.pushState method accepts the following three parameters.

i. State object: A state object is a JavaScript object which is associated with the new history entry created by pushState()
ii. Title: This is an optional title for the state
iii. URL: The new history entry’s URL. The browser won’t jump to that page.

Ex -
var stateObj= { message: "some message" };
history.pushState(stateObj, "title", newUrl);
 
- Which Location Strategy to Use
We recommend you to use the HTML 5 style (PathLocationStrategy ) as your location strategy.

- Because, It produces clean and SEO Friendly URLs that are easier for users to understand and remember.
You can take advantage of the server-side rendering, which will make our application load faster, by rendering the pages in the server first before delivering it the client
Use hash location strategy only if you have to support the older browsers.

3. Passing Parameters to Route

- Defining the Route
{ path: 'product/:id', component: ProductDetailComponent }

- Defining the Navigation
<a [routerLink]="['/Product', product.productID]">{{product.name}} </a>

- The ActivatedRoute is a service, which keeps track of the currently activated route associated with the loaded Component.

- ParamMap
The Angular adds the map all the route parameters in the ParamMap object, which can be accessed from the ActivatedRoute service

The ParamMap makes it easier to work with parameters. We can use get or getAll methods to retrieve the value of the parameters in the component. Use the has method to check if a certain parameter exists.

The Older version of ActivatedRoute class has a Params array which is an array of the parameter values, indexed by name. You can still use it but It is now deprecated and is replaced by the ParamMap.

- There are two ways in which you can use the ActivatedRoute to get the parameter value from the ParamMap object.

i. Using Snapshot
The snapshot property returns the initial value of the route. You can then access the paramsMap array, to access the value of the id, as shown above,

Ex -  this.id=this._Activatedroute.snapshot.paramMap.get("id");


ii. Using observable
You can retrieve the value of id by subscribing to the paramMap observable property of the activateRoute as shown above. Better to use observable.

Ex -
this._Activatedroute.paramMap.subscribe(params => { 
    this.id = params.get('id'); 
});

- The ActivatedRoute service has a great deal of useful information including:

url: This property returns an array of Url Segment objects, each of which describes a single segment in the URL that matched the current route.

params: This property returns a Params object, which describes the URL parameters, indexed by name.

queryParams: This property returns a Params object, which describes the URL query parameters, indexed by name.

fragment: This property returns a string containing the URL fragment.

Snapshot: The initial snapshot of this route

data: An Observable that contains the data object provided for the route

Component: The component of the route. It’s a constant

outlet: The name of the RouterOutlet used to render the route. For an unnamed outlet, the outlet name is primary.

routeConfig: The route configuration used for the route that contains the origin path.

parent: an ActivatedRoute that contains the information from the parent route when using child routes.

firstChild: contains the first ActivatedRoute in the list of child routes.

children: contains all the child routes activated under the current route

pathFromRoot: The path from the root of the router state tree to this route


4. Child Routes / Nested Routes

- Why subscribe to route params

Because the angular does not create the component if it is already present in the DOM. It reuses the component instance

This implies that the ngOnInit life cycle hook is not invoked when the user navigates to the component again. We are retrieving the parameter value in the ngOnInit using the snapshot method. Hence our component does not update itself.

This issue can be rectified by subscribing to the observable params property. Our component will be notified, whenever the value of the parameter changes. So that we can update the component accordingly.

- 


5.Passing Optional (Query) Parameters to a route
https://www.tektutorialshub.com/angular/angular-passing-optional-query-parameters-to-route/

- <a [routerLink]="['product']" [queryParams]="{ val1:2 , val2:10}">Whatever</a>

The router will construct the URL as /product?val1=2&val2=10

- The queryParamsMap is a Observable that contains a map of the query parameters available to the current route. We can use this to retrieve values from the query parameter. The queryParamsMap is accessible via ActivatedRoute.

Ex:
this.sub = this.Activatedroute.queryParamMap
       .subscribe(params => {
     this.pageNum = +params.get('pageNum')||0;     
});

- You can also read the value of the query parameter from queryParamMap using the snapshot property of the ActivatedRoute as shown below

Ex: this.Activatedroute.snapshot.queryParamMap.get('pageNum')||0;;

- Remember, the router populates the snapshot, when the component loads for the first time. Hence you will read only the initial value of the query parameter with the snapshot property. You will not be able to retrieve any subsequent changes to the query parameter.

- 

6.Navigation between Routes

- Navigating between Angular routes
i. RouterLink directive
Ex -<li><a [routerLink]="['product']">Product</a></li>

Will map to URL “/product” and renders the associated ProductComponent

ii. Navigating Using Code
Ex - this._router.navigate(['product'])
or
this._router.navigateByUrl('product')

- router.navigate 
Use this method, if you want to Navigate to a route using the link parameters array. The first argument to the navigate method is link parameters array, which is similar to what we provide while defining the routerlink directive. Navigate Method always uses the absolute path unless you provide a starting point.

- navigate.navigateByUrl
Use this method if you want to navigate to a URL by using the absolute path. The first argument is a string containing the complete URL. NavigateByUrl Method always uses the absolute path

- If the First segment of the route starts with “/“, then the path is considered to be Absolute path

- If the First segment begins with “./” or it does not begin with a slash, then the path is considered to be the relative path.

- And if the First segment begins with “. ./“, then the path is relative to the parent route. (one level up)

- NavigationExtras

- relativeTo: ActivatedRoute
We can provide the extra options to both router.navigate() or router.navigatebyURL() method. Enables relative navigation from the current ActivatedRoute. This is applicable only to router.navigate() method.

Ex - this.router.navigate(['../Detail'], { relativeTo: this.activatedRoute });

- queryParams: Params
Sets query parameters to the URL. 
Ex - this.router.navigate(['/products'], { queryParams: { page: 1 } });

- fragment: string
Sets the hash fragment for the URL. The following code constructs the URL as “/home#top”
Ex - this.router.navigate(['/home'], { fragment: 'top' });

- preserveQueryParams: boolean
Passes the query parameters of the current route to the next route. If you are on the route “Product?Page=2”, then the clicking on the following will pass the query parameters to the “view” route as “view?Page=2”

Ex - this.router.navigate(['/view'], { preserveQueryParams: true });

- queryParamsHandling: QueryParamsHandling
The query parameters of the current route are merged with that of the new route if you set queryParamsHandling=”merge”.

Ex - 
this.router.navigate(['/view'], { queryParams: { page: 2 },preserveQueryParams: true, queryParamsHandling: "merge" });

- preserveFragment: boolean
Passes the fragment of the current route to the next navigation. Similar to the preserveQueryParams

Ex - this.router.navigate(['/view'], { preserveFragment: true });

- skipLocationChange: boolean
You can change the route, without changing the URL in the browser.  This Navigates to a new URL without pushing a new state into history.

Ex - this.router.navigate(['/view'], { skipLocationChange: true });

- replaceUrl: boolean
The current route is removed from the browser history while navigating to the new route. It replaces the current state in history with the new state.

Ex - this.router.navigate(['/view'], { replaceUrl: true });

7.Angular Route Guards
- We use the Angular Guards to control, whether the user can navigate to or away from the current route.

- We need to restrict the user until the user performs specific actions like login. Angular provides the Route Guards for this purpose.

- Uses of  Angular Route Guards
i. To Confirm the navigational operation
ii. Asking whether to save before moving away from a view
iii. Allow access to certain parts of the application to specific users
iv. Validating the route parameters before navigating to the route
v. Fetching some data before you display the component.

- Types of Route Guards
i. CanActivate
This guard decides if a route can be activated (or component gets used). This guard is useful in the circumstance where the user is not authorized to navigate to the target component. Or the user might not be logged into the system

ii. CanDeactivate
This Guard decides if the user can leave the component (navigate away from the current route). This route is useful in where the user might have some pending changes, which was not saved. The CanDeactivate route allows us to ask user confirmation before leaving the component.  You might ask the user if it’s OK to discard pending changes rather than save them.

iii. Resolve
This guard delays the activation of the route until some tasks are complete. You can use the guard to pre-fetch the data from the backend API, before activating the route


iv. CanLoad
The CanLoad Guard prevents the loading of the Lazy Loaded Module. We generally use this guard when we do not want to unauthorized user to be able to even see the source code of the module.

This guard works similar to CanActivate guard with one difference. The CanActivate guard prevents a particular route being accessed. The CanLoad prevents entire lazy loaded module from being downloaded, Hence protecting all the routes within that module.

v. CanActivateChild
This guard determines whether a child route can be activated. This guard is very similar to CanActivateGuard. We apply this guard to the parent route. The Angular invokes this guard whenever the user tries to navigate to any of its child route. This allows us to check some condition and decide whether to proceed with the navigation or cancel it.

- CanDeactivate() and CanActivateChild() guards are always checked first. The checking starts from the deepest child route to the top. CanActivate() guard is checked next and checking starts from the top to the deepest child route. CanLoad() is invoked next,  If the feature module is to be loaded asynchronously. Resolve() Guard is invoked last.

- The canActivate method accepts two arguments. The first argument is an ActivatedRouteSnapshot object, which describes the route that is being navigated to using the properties. The second argument is a RouterStateSnapshot object, which describes the current route through a single property called URL.

8.CanActivate Guard
- The example of canActivate guard is as follows

import { Injectable } from '@angular/core';
import { Router, CanActivate, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';
 
 
@Injectable()
export class AuthGuardService implements CanActivate {
 
    constructor(private _router:Router ) {
    }
 
    canActivate(route: ActivatedRouteSnapshot,
                state: RouterStateSnapshot): boolean {
 
        //check some condition  
        if (someCondition)  {
            alert('You are not allowed to view this page');
            //redirect to login/home page etc
            //return false to cancel the navigation
            return false;
        } 
        return true;
    }
}

{ path: 'product', component: ProductComponent, canActivate : [AuthGuardService] },


9.CanActivateChild Guard
- The Angular CanActivateChild guard runs before we navigate to a child route.

- The CanActivatechild guard is very similar to CanActivateGuard. We apply this guard to the parent route. The Angular invokes this guard whenever the user tris to navigate to any of its child route. This allows us check some condition and decide whether to proceed with the navigation or cancel it.

- Difference between CanActivate & CanActivateChild

i. The ProductComponent displays the list of product. We have attached the canActivate guard to the product route. The canActivate guard blocks the access to the route, if the user is not logged in. This guard protect both the product route and all its children.

Ex -
{ path: 'product', component: ProductComponent, canActivate : [AuthGuardService],
      children: [
      {  path: 'view/:id', component: ProductViewComponent  },
      {  path: 'edit/:id', component: ProductEditComponent  },
      {  path: 'add', component: ProductAddComponent }
      ]  
  },

Now, consider the case where we want all users to view the ProductComponent, but only the Admin user can view any of its child routes. We can create another guard ProductGuardService which implements the canActivate guard and attach it to each of those child routes as shown below.

Ex -
{ path: 'product', component: ProductComponent, canActivate : [AuthGuardService],
      children: [
      {  path: 'view/:id', component: ProductViewComponent, canActivate : [ProductGuardService]  },
      {  path: 'edit/:id', component: ProductEditComponent, canActivate : [ProductGuardService]  },
      {  path: 'add', component: ProductAddComponent, canActivate : [ProductGuardService] }
      ]  
  },

Another way is to use the CanActivateChild guard and attach it to the product route as shown below. When Angular sees a canActivateChild guard attached to the parent route, it invokes it every time the user tries to navigates to the child route. Hence instead of attaching Guard service every child, you can attach it to the parent route.

Ex -
{ path: 'product', component: ProductComponent, canActivate : [AuthGuardService], 
canActivateChild : [AdminGuardService],
      children: [
      {  path: 'view/:id', component: ProductViewComponent  },
      {  path: 'edit/:id', component: ProductEditComponent  },
      {  path: 'add', component: ProductAddComponent }
      ]  
  },

10.CanDeactivate Guard
- The Angular CanDeactivate Guard determines whether we can navigate away from a route. The Angular CanDeactivate guard is called, whenever we navigate away from the route before the current component gets deactivated.

- The best use case for CanDectivate guard is the data entry component. The user may have filled the data entry and tries to leave that component without saving his work. The CanDeactivate guard gives us a chance to warn the user that he has not saved his work and give him a chance to cancel the navigation.

Syntax :
interface CanDeactivate<T> {
  canDeactivate(component: T, 
                currentRoute: ActivatedRouteSnapshot, 
                currentState: RouterStateSnapshot, 
                nextState?: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree
}

11.Angular Resolve Guard
- The Angular Resolve Guard or Angular Resolvers allow us to load certain data before we navigate to a Route. 

- The Angular renders the Angular Component, when we navigate to a route. The component will then sends an HTTP request to back end server to fetch data so as to display it to the user. We generally do this in ngOnInit Life cycle hook

The Problem with the above approach is that, the use will see a empty component. The component shows the data after the arrival of the data. The one way is solve this problem is to show some loading indicator

The another way to solve this is to make use the Resolve Guard. The Resolve Guard pre fetches the data before the navigating to the route. Hence the component is rendered along with the data.

- Remember Resolve runs after all other guards are executed


12.Angular Pass data to route

- Angular allows us to pass data to the route. The route data can be either static or dynamic. The static data use the Angular route data property, where you can store arbitrary data associated with this specific route. For to pass dynamic data (or an object), we can make use of the history state object. The Routed Component can then retrieve the dynamic data from the history state object.

- The Angular can pass data to Route in several ways.

i. Using URL or Route Parameter
ii. The Optional Parameter or Query Strings
iii. Using URL Fragment
iv. Static data using the data property
v. Dynamic data using state object

- The option to pass the dynamic data or a user-defined object was added in the Angular Version 7.2 using the state object. The state object is stored in History API

Ex -
<a [routerLink]="['dynamic']" [state]="{ id:1 , name:'Angular'}">Dynamic Data</a>

or

this.router.navigateByUrl('/dynamic', { state: { id:1 , name:'Angular' } });

The Router will add a navigationId property to the state object. Hence you cannot use a scalar value.


- The state can be accessed by using the getCurrentNavigation method of the router (works only in the constructor)

Ex - 
this.router.getCurrentNavigation().extras.state

or 
console.log(history.state)

or use the getState method of the Location Service. This method is available Angular 8+

import { Location } from '@angular/common';
 
export class SomeComponent
{
  products:Product[];
 
  constructor(private location:Location){
  }
 
  ngOnInit() {
    console.log(this.location.getState());
  }
}

- Passing static data to a route
The Angular Router will pass the { id:'1', name:"Angular"} when the StaticComponent is rendered. The data value will be located in the data property of the ActivatedRoute service

Ex -
{ path: 'static', component: StaticComponent, data :{ id:'1', name:"Angular"}},

ngOnInit() {
      this.activatedroute.data.subscribe(data => {
          this.product=data;
      })
}

-  Passing dynamic data (or object) example
import {Component, OnInit, ChangeDetectorRef} from '@angular/core';
import { ActivatedRoute, Router, NavigationStart } from '@angular/router';
import { map, filter} from 'rxjs/operators';
import { Observable} from 'rxjs/observable';
 
@Component({
     template: `<H1>Passing Dynamic Data Demo</H1>
 
     {{ product | json }}`
})
export class DynamicComponent implements OnInit {
 
     product;
 
     constructor(private router:Router, private activatedRoute:ActivatedRoute) {
          console.log(this.router.getCurrentNavigation().extras.state);
     }
 
     ngOnInit() {
          //console.log(history.state);
          this.product=history.state;
     }
 }

import { Component } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
 
@Component({
  template: `
     <ul>
       <li><a [routerLink]="['/static']">Static Data</a></li>
       <li><a [routerLink]="['/dynamic']" [state]=product>Dynamic Data</a></li> 
    </ul>
   
    <p>Id :   <input type="text" [(ngModel)]="product.id" > </p>
    <p>name :<input type="text" [(ngModel)]="product.name" > </p>
    <button (click)="gotoDynamic()" >Goto Dynamic Component</button>`
})
export class HomeComponent {
  
  public product = { id:'1', name:"Angular"};
 
  constructor(private router : Router) {
  }
 
  gotoDynamic() {
    //this.router.navigateByUrl('/dynamic', { state: { id:1 , name:'Angular' } });
    this.router.navigateByUrl('/dynamic', { state: this.product });
  }
}

The Dynamic Component gets dynamic data. We use the history.state to access the product data. Alternatively, we can use the this.router.getCurrentNavigation().extras.state to achieve the same. Please remember getCurrentNavigation only works in the constructor. It will return null if used elsewhere.

In HomeComponent, we have used routerLink & navigateByUrl to pass the data to the dynamic component. You can also use the form fields to change the data, before passing it to the dynamic route.

- Static data is defined on route and will work on a refresh. Dynamic data will not work

13.RouterLinkActive
- The RouterLinkActive is a directive for adding or removing classes from an HTML element that is bound to a RouterLink. Using this directive, we can toggle CSS classes for active Router Links based on the current RouterState. The main use case of this directive is to highlight which route is currently active. You can either make the font bold or apply some background color.

Ex -
<li><a [routerLink]="['home']" routerLinkActive="active">Home</a></li>
 
<li><a [routerLink]="['product']" [routerLinkActive]="['active']">Product</a></li>

With the CSS Rule defined as the global styles.

.active {
  background-color: yellow;
}

- When the user navigates to any of the above routes, the Angular router adds the “active” class to the activated element. And when the user navigates away the class will be removed.

The Angular does this by watching the URL. Whenever the Url matches with the URL of the routerLink directive, it applies the classes defined in the RouterLinkActive directive. When it does not match it will be removed from the element.

Using this we can apply different background or foreground color to our navigation links.

- You can add multiple classes to the routerLinkActive directive as shown below
Ex -
<a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
 
<li><a [routerLink]="['home']" routerLinkActive="active  home">Home</a></li>
<li><a [routerLink]="['product']" [routerLinkActive]="['active','home']">Product</a></li>

14.Router Events
- The Angular Router raises events when it navigates from one route to another route. It raises several events such as NavigationStart, NavigationEnd, NavigationCancel, NavigationError, ResolveStart, etc. You can listen to these events and find out when the state of the route changes.

The router.events is an Observable that gets triggered when the route changes. We receive NavigationEvent as the parameter in the callback. We check the NavigationEvent instance to check the Type of event fired.

Ex:
this.router.events
  .subscribe(
    (event: NavigationEvent) => {
      if(event instanceof NavigationStart) {
        console.log(event);
      }
    });
or
import { filter } from 'rxjs/operators';
import { Router, NavigationStart, Event as NavigationEvent } from '@angular/router';
 
this.router.events
  .pipe(
    filter( event =>event instanceof NavigationStart)
  )
  .subscribe(
    (event: NavigationEvent) => {
      console.log(event);
  }
)

- The Router events allow us to watch for the router state changes and run some custom logic. One of the use case scenarios is to show the loading indicator when the user navigates from one route to another. You can listen to NavigationStart and NavigationEnd events to achieve this result


* Angular Module
https://www.tektutorialshub.com/angular/angular-modules/
- The Angular Modules help us to organize our code into manageable parts or block. Each block implements a specific feature. The Components, Templates, Directives, Pipes, and Services, which implements that feature become part of the module.

1.Introduction to Angular Modules
- The Angular module (also known as ngModule) help us to organize the application parts into cohesive blocks of functionality. Each block is focused on providing a specific functionality or a feature.

- The JavaScript Modules , which also goes by the name JS modules or ES modules or ECMAScript modules are part of the JavaScript Language. The JS Modules are stored in a file. There is exactly one module per file and one file per module. These modules contain small units of independent, reusable code. They export a value, which can be imported and used in some other module.

- The NgModule() decorator is a function that takes a single metadata object, whose properties describe the module. The most important properties are as follows.

@NgModule({
  declarations: [  ],
  imports:      [  ],
  providers:    [  ],
  exports:      [  ],
  bootstrap:    [  ],
  entrycomponents: [ ]
})

- Declarations array
This is where components, directives, and pipes that belong to this NgModule are declared.

You should add only those, which belong to this module. The Component cannot belong to more than one module. The services must not be declared here. They are defined in the Angular Providers array.

- Providers array
The Services, which you want to add to the global collection of services are added here. The services are then available for injection via dependency injection.
Remember :
Declarations is for Components, Directives & Pipes. Providers are for Services

Services are global in scope. Services added to Providers array are available for injection in the entire application

- Imports array
If you want this ngModule require any feature or functionality, then those modules need to be imported here. Any components, directives, and pipes that are defined and exported in that module can be used in this module.

- Exports array
If you want other modules to use the component, pipes, directives of this NgModule, then those must be specified here.

Only those components declared here are visible to the other ngModules, when they import this module.

- Bootstrap
The main component of this module, which needs to be loaded when the module is loaded is specified here.

This is a must if you are the first module ( called the root module) that is loaded when the Angular App starts. It is the responsibility of the root module to load the first view and it is done by specifying the component here.

If the module is not the root module, then you should keep this blank

- EntryComponents
The components that are dynamically loaded needs to be declared here.

- The application needs only one instance of the services provided by the RouterModule.  But every Angular module might contain routes of its own and needs to import RouterModule and register the routes.

Angular has a nice way to solve this problem. The Services are registered only if you call the forRoot method. forRoot method must be called only once and in the Root module. In the other modules, we will be using the forChild method to register the routes

2.Routing Between Angular Modules
https://www.tektutorialshub.com/angular/angular-routing-between-modules/

- forRoot vs forChild
The services provided in the Root Module or in any of the eagerly loaded feature modules  are app-scoped. i.e they are available for injection in every component in the app.

This rule does not apply to the lazy loaded modules. The lazy loaded modules gets their own injector and providers. The services provided in the lazy loaded modules are available only in the lazy loaded module only.

- It may happen that you may have other routes defined in the AppRoutingModule and might not be able to import it last. In that case create another routing module and place only the wild card route in it and import it in the AppModule.

3.Angular folder structure: Best Practices
- We can classify our modules into the following four categories

i. Root Module
The Angular requires one module to be loaded as the application starts. We call this as root module. The root module loads the root component and all other modules.  The root module is conventionally called as AppModule and created under the  /src/app.folder

ii. Feature Module
The Features module implements a specific feature of the Application. All the components, pipes & directives which implement the feature become part of the module.

iii. Shared Module
There are many components, directives & pipes, which we may like to share across various modules. All these components should go into the shared module. 

The shared module and must declare the components, pipes, and directives using the declarations metadata and export it using the exports metadata

The Services must not be defined here. Since the shared modules are imported everywhere, it may create a new instance of the service if it is imported in the lazy loaded modules.

iv. Core Module
The Services shared across the application must become part of the CoreModule. The user authentication services, services that fetch data are examples of such services.

The Services usually needs to be Singleton, Only one instance of the Service must exist. Providing it in CoreModule ensures that the services remain singleton

4.Lazy Loading in Angular
https://www.tektutorialshub.com/angular/angular-lazy-loading/
- Lazy loading is the technique where angular loads the Modules only on a need basis rather than all at once. It is also called on-demand loading. By default, Angular Loads the modules eagerly. Lazy Loading of Angular Modules reduces the initial load time of the app. We use the loadChilden method of the Angular Router to lazy load them when the user navigates to a route.

Syntax: 
 > Angular 8
 {path: "admin", loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)},
 
 < Angular 7
 {path: "admin", loadChildren:'./admin/admin.module#AdminModule'},

-loadChildren: We need to provide call back function to loadChildren argument. The call back must load the AdminModule. We use the dynamic import syntax using the import method. The import method loads the module from the path, which we provide as the argument to it.

- The lazy loaded module loads only for the first visit of the URL, it will not load when we revisit that URL again. When we define an AdminModule to lazy loaded, the angular creates a separate bundle for the entire module.

- We need to be careful when we create a service or provide a services in Lazy loaded module.

Any Service defined in the Lazy Loaded Module, will not be load until the user navigates to that module. Hence we cannot use them anywhere else in the application.

The Angular creates a separate injector for the lazy loaded module. Therefore, any service we provide in the lazy loaded module gets its own instance of the service.

- Hence create a service in the lazy loaded module, only if it is used within the lazy loaded Module. Else consider moving it to the AppModule or a special CoreModule. 

- Do not import lazy loaded modules in any other modules. This will make the angular to load the module eagerly and can have unexpected bugs.

- Be careful when you import other modules in the lazy loaded module. If the other modules providers any services, then the lazy loaded module will get a new instance of the service. This may have unintended side effects, if the services are intended to be app-wide singleton

5.Preloading Strategy

- Angular Preloading Strategy is yet another way to speed up the load time of the Angular Apps. We build Modular apps using the Angular Modules. The Angular loads all the modules, when the user requests for the first time. This will make app loading slowly as it need to download all the modules. We can solve this problem by lazy loading those modules. The Angular allows us further optimize our app using a technique called PreLoading.

- Preloading in Angular means loading the Lazy loaded Modules in the background asynchronously, while user is interacting with the app. This will help boost up the loading time of the app

- By Lazy loading the modules, we can reduce the initial download size of the app, and thus making app load quickly. This is very useful in case of big apps. But when user navigates to a lazy loaded part of the app, the angular will have to download the module from the server, which means that user will have to wait for the download to finish.

- By Preloading the lazy loaded module, the user do not have to wait for the module to be downloaded as the module is already downloaded in the background.

- To make use of Preloading, first we need to enable lazy loading of the Modules. Mark the modules with the loadChildren, when you define routes as shown below. The angular will lazy load those modules.

const routes: Routes = [
  {path: "admin", loadChildren:'./admin/admin.module#AdminModule'},
];

And then, you can enable preloading by using the preloadingStrategy: PreloadAllModules, while registering the routes using the forRoot method.

RouterModule.forRoot(routes, {preloadingStrategy: PreloadAllModules}) 

- NoPreloading: This will disables all the preloading. This is default behavior i.e. if you don not specify the preloadingStrategy, then the angular assumes you do not want preloading

RouterModule.forRoot(routes,{preloadingStrategy: NoPreloading}

- PreloadAllModules: This strategy will preload all the lazy loaded modules. 

RouterModule.forRoot(routes,{preloadingStrategy: PreloadAllModules}) 

- With PreloadAllModules all the modules are preloaded, which may actually create a bottleneck if the application has large no of modules to be loaded.

- The better way strategy would be
i. Eagerly Load the modules required at startup. For Example authentication module, core module, shared module etc
ii. Preload all frequently used modules, may be after some delay
iii. Lazy load remaining modules

To selectively preload a module, we need to make use of custom preloading strategy.

In a real application, you may set a delay before preloading the module. You can also set different delay for different routes also.

Ex -
const routes: Routes = [
  {path: "admin", loadChildren:'./admin/admin.module#AdminModule',data: { preload: true, delay:5000 }},
  {path: "test", loadChildren:'./test/test.module#TestModule',data: { preload: true, delay:10000 }},
];

import { Injectable } from '@angular/core';
import { Observable, of, timer  } from 'rxjs';
import { flatMap } from 'rxjs/operators'
 
import { PreloadingStrategy, Route } from '@angular/router';
 
@Injectable()
export class CustomPreloadingStrategy implements PreloadingStrategy {
 
    preload(route: Route, loadMe: () => Observable<any>): Observable<any> {
    
    if (route.data && route.data['preload']) {
      var delay:number=route.data['delay']
      console.log('preload called on '+route.path+' delay is '+delay);
      return timer(delay).pipe(
        flatMap( _ => { 
          console.log("Loading now "+ route.path);
          return loadMe() ;
        }));
    } else {
      console.log('no preload for the path '+ route.path);
      return of(null);
    }
  }
} 

6.CanLoad Guard
- The Angular Route Guards are used to control, whether the user can navigate to or away from a given route. The canload guard determines whether a particular lazy loaded child route can be loaded.

- The Angular modules can be either eagerly loaded or lazy loaded. By default Angular loads all the modules eagerly. To lazy load a module we need to use the loadChildren in the route definition

- Sometimes, we want to prevent the loading of the modules for unauthorized users. This is where we use the CanLoad Guard.

- The Angular provides canActivate Guard, which prevents unauthorized user from accessing the route. But it does not stop the module from being downloaded. The user can use the chrome developer console to see the source code. The CanLoad Guard prevents the module from being downloaded.

* Advanced Components

1.Ng-Content & Content Projection in Angular
- The ng-content tag acts as a placeholder for inserting external or dynamic content. The Parent component passes the external content to the child component. When Angular parses the template, it inserts the external content where ng-content appears in the child component’s template

- We can use content projection to create a reusable component. The components that have similar logic & layout and can be used in many places in the application.

- Take an example of a card component. It has a header section, footer section & body section. The contents of these sections will vary. The ng-content will allow us to pass these sections to the card component from the parent component. This enables us to use the card component at many places in the app.

Example -
import { Component } from '@angular/core';
 
 
@Component({
  selector: 'app-card',
  template: `
    <div class="card">
    <div class="header">
      <ng-content select=".header" ></ng-content>
    </div>
    <div class="content">
      <ng-content select="content" ></ng-content>
    </div>
    <div class="footer">
      <ng-content select="footer" ></ng-content>
    </div>
    </div>
  `,
  styles: [
    ` .card { min- width: 280px;  margin: 5px;  float:left  } 
      .header { color: blue}
    `
  ]
})
export class CardComponent {
}
 
In the above example, we have three ng-content slots, each have a selector header,content & footer. Now open the app.component.html add the following code

<app-card>
 <header><h1>Angular</h1></header>
 <content>One framework. Mobile & desktop.</content>
 <footer><b>Super-powered by Google </b></footer>
</app-card>
  
<app-card>
 <div class="header">
    <h1>Angular</h1>
  </div>
 <content>A JavaScript library for building user interfaces</content>
 <footer><b>Facebook Open Source </b></footer>
</app-card>

Similarly, you can use the various CSS Selectors as shown below

 <ng-content select="custom-element" ></ng-content>
 <ng-content select=".custom-class" ></ng-content>
 <ng-content select="[custom-attribute]" ></ng-content>

- ng-content without selector catches all
Now, in the following example, the last paragraph does not belong to any ng-content slots. Hence ng-content will not project the last para as it cannot determine where to add.

<card>
  <div class="header"><h1>Typescript</h1></div>
  <div class="content">Typescript is a javascript for any scale</div>
  <div class="footer"><b>Microsoft </b></div>
  <p>This text will not be shown</p>
</card>

To solve the above issue, we can include ng-content without any selector. It will display all the content, which cannot be projected into any other slots.

import { Component } from '@angular/core';
 
 
@Component({
  selector: 'app-card',
  template: `
    <div class="card">
    <div class="header">
      <ng-content select="header" ></ng-content>
    </div>
    <div class="content">
      <ng-content select="content" ></ng-content>
    </div>
    <div class="footer">
      <ng-content select="footer" ></ng-content>
    </div>
    <ng-content></ng-content>                      
    </div>
  `,
  styles: [
    ` .card { min- width: 280px;  margin: 5px;  float:left  } 
      .header { color: blue}
    `
  ]
})
export class CardComponent {
}

- ngProjectAs
Sometimes it becomes necessary to wrap the component using the ng-container. Most of the time when you use a structural directive like ngIf or ngSwitch.

<card>
  <ng-container ngProjectAs="header">
    <div>
      <h1 style="color:red;">React</h1>
    </div>
  </ng-container>
  <div class="content">A JavaScript library for building user interfaces</div>
  <div class="footer"><b>Facebook Open Source </b></div>
</card>


2.Angular @input, @output & EventEmitter
https://www.tektutorialshub.com/angular/angular-input-output-eventemitter/

- @input - Input decorator marks the property as the input property. I.e it can receive data from the parent component. The parent component uses the property binding to bind it to a component property. Whenever the value in the parent component changes angular updates the value in the child component.

- @output - Output decorates the property as the output property. We initialize it as an EventEmitter. The child component raises the event and passes the data as the argument to the event. The parent component listens to events using event binding and reads the data.

- EventEmitter - EventEmitter is responsible for raising the event. The @output property normally is of type EventEmitter. The child component will use the emit() method to emit an event along with the data.


3.Template Reference Variable in Angular
https://www.tektutorialshub.com/angular/template-reference-variable-in-angular/

- Template Reference Variable
The Template reference variable is a reference to any DOM element, component or a directive in the Template. We can use it elsewhere in the template. We can also pass it to a method in the component. It can contain a reference to elements like h1, div, etc
Ex - 
HTML Element
<input type="text" #firstName>

Component/Directive
<app-customer #customerList=”customer”></app-customer>

Component/Directive with exportAs
<app-customer #customerList=”customer”></app-customer>
customer is exportAs name in component.

Example:
Create a new component customer-list.component.ts

import { Component } from '@angular/core';
import { Customer } from './customer';
 
@Component({
  selector: 'app-customer-list',
  templateUrl: './customer-list.component.html',
  exportAs:'customerList'
})
export class CustomerListComponent {
 
  selectedCustomer: any;
 
  customers: Customer[] = [
 
    {customerNo: 1, name: 'Rahuld Dravid', address: '', city: 'Banglaore', state: 'Karnataka', country: 'India'},
    {customerNo: 2, name: 'Sachin Tendulkar', address: '', city: 'Mumbai', state: 'Maharastra', country: 'India'},
    {customerNo: 3, name: 'Saurrav Ganguly', address: '', city: 'Kolkata', state: 'West Bengal', country: 'India'},
    {customerNo: 4, name: 'Mahendra Singh Dhoni', address: '', city: 'Ranchi', state: 'Bihar', country: 'India'},
    {customerNo: 5, name: 'Virat Kohli', address: '', city: 'Delhi', state: 'Delhi', country: 'India'},
 
  ]
}

customer-list.component.html

<h2>List of Customers</h2>
 
<table class='table'>
  <thead>
    <tr>
      <th>No</th>
      <th>Name</th>
      <th>Address</th>
      <th>City</th>
      <th>State</th>
      <th>Select</th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let customer of customers;">
      <td>{{customer.customerNo}}</td>
      <td>{{customer.name}}</td>
      <td>{{customer.address}}</td>
      <td>{{customer.city}}</td>
      <td>{{customer.state}}</td>
      <button (click)="selectedCustomer=customer">Select</button>
    </tr>
  </tbody>
</table>

app.component.html

You have selected {{customerListComponent.selectedCustomer?.name}}
<app-customer-list #customerListComponent></app-customer-list>

ExportAs
Sometimes there could be more than one directive on a DOM Element.For Example in the following code has two directives. In such a case, we need to specify which directive to use for #variable.

<a-directive b-directive #variable />
The components or directives can use exportAs to export the component/directive in a different name.

For Example, open the customer-list.component and add the exportAs:'customerList' under the @Component metadata

@Component({
 selector: 'app-customer-list',
 templateUrl: './customer-list.component.html',
 exportAs:'customerList'
})

You have selected {{customerList.selectedCustomer?.name}}
<app-customer-list #customerList="customerList"></app-customer-list>

- Variable Scope
 The scope of the template reference variable is the template within which it is declared. You cannot access it outside the template. Hence any variable declared in CustomerListComponent cannot be accessed from the app component although we render the customer list within the app component.

- Child scope
Also, note that we can create a new child template scope (nested scope) by using the directive ng-template . Also the structural directive like ngIf, ngFor, etc also creates their own child scope. The following is an example of the <ng-template> directive. The address variable defined inside the ng-template is not accessible outside it.

Ex - 
<h2>Variable Scope</h2>
 
<div *ngIf="false else addressTemplate"></div>
 
<ng-template #addressTemplate>
 <p>
   <label for="address">Address</label>
   <input (keyup)="0" type="text" #address id="address">
 </p>
 <p>The address of {{firstName.value}} {{lastName.value}} Entered {{address.value}} </p>
 
</ng-template>
 
<!-- address is not accessible here -->
<p>
You Entered {{address?.value}}
</p>

<div *ngIf="true">
  <app-customer-list #variable></app-customer-list
  //variable is accessible from here
</div>
 
//variable is not accessible from here


4.ng-container in Angular

- ng-container allows us to create a division or section in a template without introducing a new HTML element. The ng-container does not render in the DOM, but content inside it is rendered. ng-container is not a directive, component, class, or interface, but just a syntax element.
Ex - 
<h1> ng-Container</h2>
<p>Hello  world! </p>
<ng-container>               //This is removed from the final HTML
 Container's content.
</ng-container>

Renders as
<h1> ng-Container</h2>
<p>Hello  world! </p>
Container's content.

You can see that the element is absent in the final HTML

- It is a very useful directive. Especially when working with structural directives like ngIf, ngFor, etc.

- ng-Container with ngFor
For Example, consider the following items. We want to display the items as a list, but only the active items. This requires two directives ngFor to loop through the items and ngIf to check if the items are active

items= [
   { name:'Angular', active:true},
   { name:'React', active:true},
   { name:'Typescript', active:true},
   { name:'FoxPro', active:false},
   { name:'Javascript', active:true},
   { name:'ASP.NET Core', active:true},
   { name:'DBase', active:false}
 ]
 
 Without ng-container, the only way to achieve this is by using the span element as shown. This adds the unnecessary DOM element. and it may also cause issues with the CSS.

<ul>
 <span *ngFor="let item of items;">
   <li *ngIf="item.active">
     {{item.name}}
   </li>
 </span>
</ul>

By Replacing the span with ng-container our HTML renders correctly without those extra span elements

<ul>
 <ng-container *ngFor="let item of items;">
   <li *ngIf="item.active">
     {{item.name}}
   </li>
 </ng-container>
</ul>
 
- ng-container with ngIf
The div of the ngIf is not necessary here.
<div *ngIf="items1">          //Replace the div with ng-container as shown below
 <div *ngFor="let item of items1;">
   {{item.name}}
 </div>
</div>

<ng-container *ngIf="items1">
 <div *ngFor="let item of items1;">
   {{item.name}}
 </div>
</ng-container>

- ngSwitch with/without ng-container
<div [ngSwitch]="value">
 <span *ngSwitchCase="0">Text one</span>
 <span *ngSwitchCase="1">Text two</span>
</div>
 
<div [ngSwitch]="value">
 <ng-container *ngSwitchCase="0">Text one</ng-container>
 <ng-container *ngSwitchCase="1">Text two</ng-container>
</div>

- ngTemplateOutlet (Interview question)
The container is also used as a placeholder for injecting a dynamic template using the ngTemplateOutlet.

<ng-container *ngTemplateOutlet="loading"></ng-container>


5.ng-template & TemplateRef in angular
https://www.tektutorialshub.com/angular/ng-template-in-angular/

- The <ng-template> is an Angular element, which contains the template. A template is an HTML snippet. The template does not render itself on DOM.

Ex -
<h2>Defining a Template using ng-Template</h2>
 
<ng-template>
  <p> Say Hello</p>
</ng-template>

The above code generates the following output. The Angular does not render Say Hello. You won’t even find it as a hidden element in the DOM.

//output
Defining a Template using ng-Template

i.e because ng-template only defines a template. It is our job to tell angular where & when to display it.

- There are few ways you can display the template.
i. Using the ngTemplateOutlet directive.
The ngTemplateOutlet, is a structural directive, which renders the template. To use this directive, first, we need to create the template and assign it to a template reference variable (sayHelloTemplate in the following template).

Ex -
<h1>ng-template & TemplateRef</h1>
<h2>Using the ngTemplateOutlet</h2>
 
<ng-template #sayHelloTemplate>
  <p> Say Hello</p>
</ng-template>

We use the ngTemplateOutlet in the DOM, where we want to render the template.

The following code assigns the Template variable sayHelloTemplate to the ngTemplateOutlet directive using the Property Binding.

<ng-container *ngTemplateOutlet="sayHelloTemplate">
  This text is not displayed
</ng-container> 

//Output
ng-template & TemplateRef
Using the ngTemplateOutlet
Say Hello

- The content inside the ngTemplateOutlet directive is not displayed. It replaces it with content it gets from the sayHelloTemplate.

- The ngTemplateOutlet is a very powerful directive. You can use it render templates, pass data to the template, pass the template to child components, etc. You can learn all these from our ngTemplateOutlet tutorial

ii. Using the TemplateRef & ViewContainerRef

- TemplateRef is a class and the way to reference the ng-template in the component or directive class. Using the TemplateRef we can manipulate the template from component code.

Ex -
<ng-template #sayHelloTemplate>
  <p> Say Hello</p>
</ng-template>

Now, we can use the ViewChild query to inject the sayHelloTemplate into our component as an instance of the class TemplateRef.

@ViewChild('sayHelloTemplate', { read: TemplateRef }) sayHelloTemplate:TemplateRef<any>;

Now, we need to tell Angular where to render it. The way to do is to use the ViewContainerRef.

The ViewContainerRef is also similar to TemplateRef. Both hold the reference to part of the view.

The TemplateRef holds the reference template defined by ng-template.
ViewContainerRef, when injected to via DI holds the reference to the host element, that hosts the component (or directive).

Once, we have ViewContainerRef, we can use the createEmbeddedView method to add the template to the component.

constructor(private vref:ViewContainerRef) {}
 
  ngAfterViewInit() {
this.vref.createEmbeddedView(this.sayHelloTemplate);
  }

- ng-template with ngIf
To understand how structural directives using ng-template works let us look at ttIf directive which we built in the tutorial custom structural directive. The ttIf directive is a simplified clone of *ngIf.

Create tt-if.directive.ts and add the following code. Also, remember to declare the ttIfDirective in app.module.ts

import { Directive, ViewContainerRef, TemplateRef, Input } from '@angular/core';
 
@Directive({ 
  selector: '[ttIf]' 
})
export class ttIfDirective  {
 
  _ttif: boolean;
 
  constructor(private _viewContainer: ViewContainerRef,
              private templateRef: TemplateRef<any>) {
  }
 
 
  @Input()
  set ttIf(condition) {
    this._ttif = condition
    this._updateView();
  }
 
  _updateView() {
    if (this._ttif) {
      this._viewContainer.createEmbeddedView(this.templateRef);
    }
    else {
      this._viewContainer.clear();
    }
  }
 
}

Open the app.component.html. You can use both <div *ttIf="selected"> and<ng-template [ttIf]="selected"> syntax.

Show/hide 
<input type="checkbox" [(ngModel)]="selected">
 
<div *ttIf="selected">
  Using the ttIf directive via *ttIf
</div>
 
 
<ng-template [ttIf]="selected">
  <div>
    <p>Using the ttIf directive via ng-template</p>
  </div>
</ng-template>

import { Component } from '@angular/core';
 
@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: [ './app.component.css' ]
})
export class AppComponent  {
  selected=false;
}

6.ngtemplateoutlet in angular
https://www.tektutorialshub.com/angular/ngtemplateoutlet-in-angular/

7.HostBinding & HostListener
https://www.tektutorialshub.com/angular/hostbinding-and-hostlistener-in-angular/

- HostListener listens to host events, while HostBinding allows us to bind to a property of the host element. The host is an element on which we attach our component or directive. This feature allows us to manipulate the host styles or take some action whenever the user performs some action on the host element.

- The host element is the element on which we attach our directive or component. Remember components are directives with a view (template).

- Consider the following ttToggle directive. We built this directive in our tutorial custom directive in Angular. We attach it to a button element. Here the button element is the host element.

<button ttToggle>Click To Toggle</button>

- HostBinding - Host Binding binds a Host element property to a variable in the directive or component

Ex -
The following appHighLight directive, uses the HostBinding on style.border property of the parent element to the border property. Whenever we change the value of the border, the angular will update the border property of the host element.

import { Directive, HostBinding, OnInit } from '@angular/core'
 
@Directive({
  selector: '[appHighLight]',
})
export class HighLightDirective implements OnInit {
 
  @HostBinding('style.border') border: string;
 
  ngOnInit() {
    this.border="5px solid blue"
  }
 
}
We apply appHighLight directive to a host element ( p in the example) as shown below.

<div>
  <h2>appHighLight Directive</h2>
  <p appHighLight>
    This Text has blue Border
  </p>
</div>

- HostListener - HostListener Decorator listens to the DOM event on the host element. It also provides a handler method to run when that event occurs.

For example, in the following code HostListener listens to the mouseover & mouseleave event. We use the HostListner decorator to decorate functions onMouseOver & onMouseLeave.

import { Directive, HostBinding, OnInit, HostListener } from '@angular/core'
 
@Directive({
  selector: '[appHighLight]',
})
export class HighLightDirective implements OnInit {
 
  @HostBinding('style.border') border: string;
 
  ngOnInit() {
  }
 
  @HostListener('mouseover') 
  onMouseOver() {
    this.border = '5px solid green';
    console.log("Mouse over")
  }
 
  @HostListener('mouseleave') 
  onMouseLeave() {
    this.border = '';
    console.log("Mouse Leave")
  }
 
}

- Whenever the mouse is moved over the p element, the mouseover event is captured by the HostListener. It runs the onMouseOver method which we have attached to it. This method adds a green border to the p element using the HostBinding.


8.ViewChild, ViewChildren & QueryList
https://www.tektutorialshub.com/angular/understanding-viewchild-viewchildren-querylist-in-angular/

- The ViewChild or ViewChildren decorators are used to Query and get the reference of the DOM element in the Component. ViewChild returns the first matching element and ViewChildren returns all the matching elements as a QueryList of items. We can use these references to manipulate element properties in the component.

- ViewChild returns Undefined
ViewChild Returning undefined is one of the common errors, we encounter when we use them. The error is due to the fact that we try to use the value, before the ViewChild initializes it.

For Example, the code below results in Cannot read property 'increment' of undefined. i.e. the component’s view is not yet initialized when the constructor is run. Hence, the Angular yet to update child variable with the reference to the ChildComponet.

export class AppComponent {
  title = 'Parent calls an @ViewChild()';
  
  @ViewChild(ChildComponent, {static:true}) child: ChildComponent;
 
  constructor() {
    this.child.increment()
  } 
 
}
 
//
Cannot read property 'increment' of undefined
 
 The solution is to wait until the Angular Initializes the View. Angular raises the AfterViewInit life cycle hook once it completes the View Initialization. So we can use the ngAfterViewInit to access the child variable.

ngAfterViewInit() {
    this.child.increment()
  }
  
 - The above code will also work with the ngOnInit Life cycle hook. But it is not guaranteed to work all the time as the Angular might not initialize all parts of the view, before raising the ngOnInit hook. Hence it is always better to use the ngAfterViewInit hook.

- Using Static Option in ViewChild
The static option determines the timing of the ViewChild query resolution.

i. static:true will resolves ViewChild before any change detection is run.
ii. static:false will resolves it after every change detection run.

The value of the static becomes important when the child is rendered dynamically. For Example inside a ngIf or ngSwitch etc.

For Example consider the following code, where we have moved the child-component inside the ngIf.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
 
//child.component.html
 
<h1>ViewChild Example</h1>
 
<input type="checkbox" id="showCounter" name="showCounter" [(ngModel)]="showCounter">
 
<ng-container  *ngIf="showCounter">
 
  <p> current count is {{child?.count}} </p>
 
  <button (click)="increment()">Increment</button>
  <button (click)="decrement()">decrement</button>
 
  <child-component></child-component>
 
</ng-container>
 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
 
//child.component.ts
 
import { Component, ViewChild, AfterViewInit, OnInit, ChangeDetectorRef } from '@angular/core';
import { ChildComponent } from './child.component';
 
@Component({
  selector: 'app-root',
  templateUrl: 'app.component.html' ,
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'ViewChild Example)';
 
  showCounter: boolean = true
 
  @ViewChild(ChildComponent, { static: true }) child: ChildComponent;
 
  increment() {
    this.child.increment();
  }
 
  decrement() {
    this.child.decrement();
  }
 
}
 
The above code results in a TypeError: Cannot read property 'increment' of undefined. The error occurs even if we assign true to showCounter

Because in the above case Angular does not render the child component immediately. But after the first change detection which detects the value of showCounter and renders the child component.

Since we used static: true, the angular will try to resolve the ViewChild before the first change detection is run. Hence the child variable always will be undefined.

Now, change the static: false. Now the code will work correctly. I.e because after every change detection the Angular updates the ViewChild.

- Using the Read Option in ViewChild

A Single element can be associated with multiple types.

For Example, consider the following code. #nameInput template variable is now associated with both input & ngModel

<input #nameInput [(ngModel)]="name">

The viewChild code below, returns the instance of the input element as elementRef.

 @ViewChild('nameInput',{static:false}) nameVar;

If we want to get the instance of the ngModel, then we use the Read token and ask for the type.

@ViewChild('nameInput',{static:false, read: NgModel}) inRef;
 
@ViewChild('nameInput',{static:false, read: ElementRef}) elRef;
@ViewChild('nameInput', {static:false, read: ViewContainerRef }) vcRef;

Every element in Angular is always has a ElementRef and ViewContainerRef associated with it. If the element is a component or directive then there is always a component or directive instance. You can also apply more than one directive to an element. The ViewChild without read token always returns the component instance if it is a component. If not it returns the elementRef.


- Injecting a Provider from the Child Component

You can also inject the services provided in the child component.

import { ViewChild, Component } from '@angular/core';
 
@Component({
  selector: 'app-child',
  template: `<h1>Child With Provider</h1>`,
  providers: [{ provide: 'Token', useValue: 'Value' }]
})
 
export class ChildComponent{
}

And in the Parent component, you can access the provider using the read property.

import { ViewChild, Component } from '@angular/core';
 
@Component({
  selector: 'app-root',
  template: `<app-child></app-child>`,
})
 
export class AppComponent{
    @ViewChild(ChildComponent , { read:'Token', static:false } ) childToken: string;
}

ViewChildren
ViewChildren decorator is used to getting the list of element references from the View.

ViewChildren is different from the ViewChild. ViewChild always returns the reference to a single element. If there are multiple elements the ViewChild returns the first matching element, ViewChildren always returns all the elements as a QueryList. You can iterate through the list and access each element.

The ViewChildren is always resolved after the change detection is run. i.e why it does not have static option. And also you cannot refer to it in the ngOnInit hook as it is yet to initialize.

- QueryList - The QueryList is the return type of ViewChildren and contentChildren . 
QueryList stores the items returned by the viewChildren or contentChildren in a list.

The Angular updates this list, whenever the state of the application change. It does it on each change detection.

The QueryList also Implements an iterable interface. Which means you can iterate over it using  for (var i of items) or use it with ngFor in template *ngFor="let i of items".

- Changes can be observed by subscribing to the changes Observable.

You can use the following methods & properties.

first: returns the first item in the list.
last: get the last item in the list.
length: get the length of the items.
changes: Is an observable. It emits a new value, whenever the Angular adds, removes or moves the child elements.
It also supports JavaScript array methods like map(), filter() , find(), reduce(), forEach(), some(). etc

Finally, we can use the this.modelRefList.forEach to loop through the QueryList and access each element.

import { ViewChild, Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';
import { NgModel } from '@angular/forms';
 
@Component({
  selector: 'app-viewchildren1',
  template: `
      <h1>ViewChildren Example</h1>
 
      <input name="firstName" [(ngModel)]="firstName">
      <input name="midlleName" [(ngModel)]="middleName">
      <input name="lastName" [(ngModel)]="lastName">
 
      <button (click)="show()">Show</button>
  
  `,
})
 
export class ViewChildrenExample1Component {
 
  firstName;
  middleName;
  lastName;
 
  @ViewChildren(NgModel) modelRefList: QueryList<NgModel>;
  
  show() {
 
    this.modelRefList.forEach(element => {
      console.log(element)
      //console.log(element.value)
    });
  }
}

- Listening for QueryList Changes
- We can subscribe to the changes observable to find if any new elements are added/removed or moved. In the example below, we have included ngIf directive to hide/show the input elements.

We subscribe to the changes observable in the component class. Every time we use the ngIf to hide or add the component, the changes observable emits the latest QueryList.

import { ViewChild, Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';
import { NgModel } from '@angular/forms';
 
@Component({
  selector: 'app-viewchildren2',
  template: `
      <h1>ViewChildren Example</h1>
 
      <input *ngIf="showFirstName" name="firstName" [(ngModel)]="firstName">
      <input *ngIf="showMiddleName" name="midlleName" [(ngModel)]="middleName">
      <input *ngIf="showlastName" name="lastName" [(ngModel)]="lastName">
 
 
      <input type="checkbox" id="showFirstName" name="showFirstName" [(ngModel)]="showFirstName">
      <input type="checkbox" id="showMiddleName" name="showMiddleName" [(ngModel)]="showMiddleName">
      <input type="checkbox" id="showlastName" name="showlastName" [(ngModel)]="showlastName">
 
      <button (click)="show()">Show</button>
  
  `,
 
})
 
export class ViewChildrenExample2Component implements AfterViewInit {
 
  firstName;
  middleName;
  lastName;
 
  showFirstName=true;
  showMiddleName=true;
  showlastName=true;
 
  @ViewChildren(NgModel) modelRefList: QueryList<NgModel>;
 
  ngAfterViewInit() {
 
    this,this.modelRefList.changes
      .subscribe(data => {
        console.log(data)
      }
    )
  }
  
 
  show() {
    this.modelRefList.forEach(element => {
      console.log(element)
      //console.log(element.value)
    });
 
  }
}


9.ElementRef
https://www.tektutorialshub.com/angular/elementref-in-angular/

ElementRef - The DOM objects are created and maintained by the Browser. They represent the structure and content of the Document. In a Vanilla JavaScript code, we access these DOM objects to manipulate the View. We can create and build documents, navigate their structure, and add, modify, or delete elements and content.

- Use with caution
[From the Angular Documents]

Use this API as the last resort when direct access to DOM is needed. Use templating and data-binding provided by Angular instead. Alternatively, you can take a look at Renderer2 which provides API that can safely be used even when direct access to native elements is not supported.

Relying on direct DOM access creates tight coupling between your application and rendering layers which will make it impossible to separate the two and deploy your application into a web worker.

- Improper use of ElementRef can result in an XSS Injection attack. For Example in the following code, we are injecting a script using the elementRef. When the component containing such code runs, the script is executed

constructor(private elementRef: ElementRef) {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.textContent = 'alert("Hello World")';
    this.elementRef.nativeElement.appendChild(s);
 }


10.Renderer2
https://www.tektutorialshub.com/angular/renderer2-angular/

- The Renderer2 allows us to manipulate the DOM elements, without accessing the DOM directly. It provides a layer of abstraction between the DOM element and the component code. Using Renderer2 we can create an element, add a text node to it, append child element using the appendchild method., etc. We can also add or remove styles, HTML attributes, CSS Classes & properties, etc. We can also attach and listen to events etc.

- Why not ElementRef?
We can use the nativeElement property of the ElelemtRef to manipulate the DOM. We learned this in our last tutorial on ElementRef. The nativeElement Property contains the reference to the underlying DOM object. This gives us direct access to the DOM, bypassing the Angular. There is nothing wrong with using it, but it is not advisable for the following reasons.

Angular keeps the Component & the view in Sync using Templates, data binding & change detection, etc. All of them are bypassed when we update the DOM Directly.
DOM Manipulation works only in Browser. You will not able to use the App in other platforms like in a web worker, in Server (Server-side rendering), or in a Desktop, or in the mobile app, etc where there is no browser.
The DOM APIs do not sanitize the data. Hence it is possible to inject a script, thereby, opening our app an easy target for the XSS injection attack.

- Using Renderer2

import {Component, Renderer2, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

constructor(private renderer:Renderer2) {
}

Use ElementRef & ViewChild to get the reference to the DOM element, which you want to manipulate.

@ViewChild('hello', { static: false }) divHello: ElementRef;

Use the methods like setProperty , setStyle etc to change the property, styles of the element as shown below.

this.renderer.setProperty(this.divHello.nativeElement,'innerHTML',"Hello Angular")
 
this.renderer.setStyle(this.divHello.nativeElement, 'color', 'red');


11.ContentChild & ContentChildren
https://www.tektutorialshub.com/angular/contentchild-and-contentchildren-in-angular/

- The ContentChild & ContentChildren are decorators, which we use to Query and get the reference to the Projected Content in the DOM. Projected content is the content that this component receives from a parent component.

- The ContentChild & ContentChildren is very similar to the ViewChild & ViewChildren. We use the ViewChild  or  ViewChildren to Query and get the reference of any DOM element in the Component. The DOM element can be an HTML element, Child Component or directive, etc. But, We cannot use the ViewChild  or  ViewChildren to get the reference to the template inserted using the Content projection.

- Content Projection recap
Content projection is a way to pass the HTML content from the parent component to the child component. The child component will display the template in a designated spot. We use the ng-content element to designate a spot for the template in the template of the child component. The ng-content also allows us to create multiple slots using the selector attribute. The parent can send different content to each of those slots.



12.AfterViewInit, AfterViewChecked, AfterContentInit & AfterContentChecked
https://www.tektutorialshub.com/angular/afterviewinit-afterviewchecked-aftercontentinit-aftercontentchecked-in-angular/

- Before diving into these hooks, we need to know the difference between Content & View. The hooks AfterConentInit & AfterContentChecked deals with the Content, While AfterViewInit, AfterViewChecked deals with the View.

- Content - Content refers to the external content injected into this component using the Content Projection.

Content projection is a way to pass the HTML content from the parent component to the child component. The child component will display the template in a designated spot. We use the ng-content element to create a spot in the template of the child component as shown below.

<h2>Child Component</h2>
<ng-content></ng-content>   <!-- place hodler for content from parent -->

Parent injects the content between the opening & closing element.  Angular passes this content to the child component.

<h1>Parent Component</h1>
<app-child> This <b>content</b> is injected from parent</app-child>

- View
View refer to the the template of the component.

- AfterContentChecked
AfterContentChecked is the life cycle hook, that angular calls during every change detection cycle after Angular completes the checking of the content for changes. Angular also updates the properties decorated with the ContentChild and ContentChildren before raising this hook. This hook fires after the ngDoCheck & AfterContentInit.

- AfterViewInit
A lifecycle hook that Angular calls during the change detection after it completes initialization of component’s view and its child views. Angular also updates the properties decorated with the ViewChild  & ViewChildren properties before raising this hook. Use this hook to handle any additional initialization tasks. Fires only once, during the first change detection cycle, immediately after the creation of the component.

- AfterViewChecked
A lifecycle hook that Angular calls after the change detector completes the checking of a component’s view and child views for changes.

Angular also updates the properties decorated with the ViewChild & ViewChildren properties before raising this hook.

- Init Hooks
Angular fires the AfterContentInit & AfterViewInit hooks, when the content or view is initialized for the first time. That happens during the first change detection cycle, which angular invokes immediately after the instantiation of the component.

- Checked Hooks
Angular fires the AfterContentChecked & AfterViewChecked hooks, where Angular checks if the the content or view has changed. i.e previously rendered content or view is same as the current content or view.

- AfterViewInit & AfterViewChecked fires after child components are ready
After content, angular initializes the components view. It also initializes the child views & runs thier change detection. Hence, by the time we receive the hooks AfterViewInit & AfterViewChecked, the current component & all its children are ready to render.

Init Hook fires only once
Init hooks fires only once, during the first change detection cycle, which angular fires immediately after the creation of the component. This makes it best place to run some custom initialization logic. Use the AfertContentInit for content related initialization & AfterViewInit for view related initializations.

- Avoid using Checked Hooks
Checked hooks runs on every change detection cycle. For example when you just click on the input element and move away.

Hence it is better to avoid using these hooks. If you choose to implement these hooks then ensure that your code is extremely lightweight otherwise it may slow down the application.

Do not modify bindings in Checked Hooks
Open the ngAfterViewChecked method of the app.component.ts. here, we assign value of the viewChild.message to the message variable of parent component. Code does not raise any errors.

  ngAfterViewChecked() {
    console.log('AppComponent==>AfterViewChecked');
    this.message=this.viewChild.message;
  }

Read above article carefully....

13. Angular Decorators
Angular Decorators
An Angular Decorator is a function, using which we attach metadata to a class, method, accessor, property, or parameter. We apply the decorator using the form @expression, where expression is the name of the decorator.

The Decorators are Typescript features and still not part of the Javascript. It is still in the Proposal stage.

To enable Angular Decorators, we need to add the experimentalDecorators to the tsconfig.json file. The ng new command automatically adds this for us.

{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true
  }
}

-List of All Angular Decorators
The following is a complete list of Decorators in Angular.

@NgModule
@Component
@Injectable
@Directive
@Pipe
@Input
@Output
@Host
@HostBinding
@HostListener
@ContentChild
@ContentChildren
@ViewChild
@ViewChildren
@Inject
@Self
@SkipSelf
@Optional

- We can classify them under four different categories

i. Class decorators.
We apply class decorators to classes. @NgModule, @Component, @Injectable, @Directive & @Pipe are Class Decorators in Angular

ii. Property decorators
iii. Method decorators
iv. Parameter decorators
 

* Observable in Angular

1.Angular Observable Tutorial
https://www.tektutorialshub.com/angular/angular-observable-tutorial-using-rxjs/
- Rx stands from Reactive programming. It is defined as programming with asynchronous data streams.

- A stream is a data, which arrives over a period of time. The stream of data can be anything. Like variables, user inputs, properties, caches, data structures, and even failures, etc

- As said earlier the stream of data can be anything. For Example

Mouse click or Mouse hover events with x & y positions
Keyboard events like keyup, keydown, keypress, etc
Form events like value changes etc
Data which arrives after an HTTP request
User Notifications
Measurements from any sensor

- The RxJS (Reactive Extensions Library for JavaScript) is a javascript library, that allows us to work with asynchronous data streams

- Observable is a function that converts the ordinary stream of data into an observable stream of data. You can think of Observable as a wrapper around the ordinary stream of data.

- Observable stream or simple Observable emits the value from the stream asynchronously. It emits the complete signals when the stream completes or an error signal if the stream errors out.

Observables are declarative. You define an observable function just like any other variable. The observable starts to emit values only when someone subscribes to it.

- The Observable on its own is useless unless someone consumes the value emitted by the observable. We call them observers or subscribers.

The observers communicate with the Observable using callbacks. The observer must subscribe with the observable to receive the value from the observer. While subscribing it optionally passes the three callbacks. next(), error() & complete()

- The observable invokes the next() callback whenever the value arrives in the stream. It passes the value as the argument to the next callback. If the error occurs, then the error() callback is invoked. It invokes the complete() callback when the stream completes.

- We need to unsubscribe to close the observable when we no longer require it. If not it may lead to memory leak & Performance degradation.

To Unsubscribe from an observable, we need to call the Unsubscribe() method on the subscription. It will clean up all listeners and frees up the memory.

- 

2.Create Observable from a string, array. object, collection
https://www.tektutorialshub.com/angular/rxjs-observable-using-create-of-from-in-angular/

- Observable creation functions
These operators help us to create observable from an array, string, promise, any iterable, etc. Here are some of the operators

create
defer
empty
from
fromEvent
interval
of
range
throw
timer

- Of Operator
The Of creates the observable from the arguments that you pass into it. You can pass any number of arguments to the Of. Each argument emitted separately and one after the other. It sends the Complete signal in the end.

Ex -
ngOnInit() {
  const array1=[1,2,3,4,5,6,7]
  const array2=['a','b','c','d','e','f','g']  
  const obsof2=of(array1,array2 );
  obsof2.subscribe(val => console.log(val),
           error=> console.log("error"),
          () => console.log("complete"))
 
}
 
**** Output ***
[1, 2, 3, 4, 5, 6, 7]
['a','b','c','d','e','f','g']
complete

- From Operator
From Operator takes only one argument that can be iterated and converts it into an observable.

You can use it to convert

an Array,
anything that behaves like an array
Promise
any iterable object
collections
any observable like object

Ex -
The from operator iterates over each character of the string and then emits it. The example is as shown below.

ngOnInit() { 
  const obsfrom2 = from('Hello World');
    obsfrom2.subscribe(val => console.log(val),
      error => console.log("error"),
      () => console.log("complete"))
}
 
 
*** Output ****
H
e
l
l
o
 
W
o
r
l
d
complete


ngOnInit() {
     const obsFrom4 = from(this.generateNos())
      obsFrom4.subscribe(val => console.log(val),
      error => console.log("error"),
      () => console.log("complete"))
}
 
*generateNos() {
   var i = 0;
   while (i < 5) {
     i = i + 1;
     yield i;
  }
 
 
*** Output ***
1
2
3
4
5

- Of Vs From
- Of
Accepts variable no of arguments	
emits each argument as it is without changing anything	

- From
Accepts only one argument
iterates over the argument and emits each value




3.Observable from events using fromEvent
https://www.tektutorialshub.com/angular/create-observable-from-event-using-fromevent-in-angular/

- Angular provides FromEvent method to create an observable from DOM events directly.

Ex -
To create an observable from any event, first, we need to get the reference to DOM element using the viewchild & ElementRef. For example the following code gets the reference to the button element with the id #btn

<button #btn>Button</button>
@ViewChild('btn', { static: true }) button: ElementRef;

  buttonClick() {
    this.buttonSubscription =  fromEvent(this.button.nativeElement, 'click')
        .subscribe(res => console.log(res));
  }

scroll() {
    const source = fromEvent(window, 'scroll');
    source.subscribe(val => console.log(val));
  }


4.Observable pipe
https://www.tektutorialshub.com/angular/angular-observable-pipe/

- The operators are very important components of the Rxjs library. They are functions that take an observable as input and transform it into a new observable and return it. We use them to manipulate the observable data stream.

- Filter operator filter items from the source observable based on some condition and returns the filtered value as a new observable

5.Map Operator
https://www.tektutorialshub.com/angular/angular-observable-map-operator/

- The Angular observable Map operator takes an observable source as input. It applies a project function to each of the values emitted by the source observable and transforms it into a new value. It then emits the new value to the subscribers. We use a Map with a Pipe, which allows us to chain multiple operators together.

Ex -
  multiplyBy2() {
    this.srcArray
    .pipe(map(val => { return val * 2}))
    .subscribe(val => { console.log(val)})
  }



6.Filter Operator
https://www.tektutorialshub.com/angular/filter-operator-in-angular-observable/

Syntax:
filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T>

- The Filter Operator in Angular filters the items emitted by the source Observable by using a condition (predicate). It emits only those values, which satisfies the condition and ignores the rest.

- The first argument is the predicate function. This function is evaluated against each value of the source observable. Filter emits only those values which satisfies the the predicate. The predicate function takes 2 parameters. The first one is the value emitted by the source. The second argument is zero based index. 
Ex -
values = [
    {
      name: "John",
      age: 30
    },
    {
      name: "alex",
      age: 40
    }
  ];
 
  ngOnInit() {
    fromArray(this.values)
      .pipe(
        filter(val => {
          return val.age > 30;
        })
      )
      .subscribe(val => console.log(val));
  }


7.Tap Operator
https://www.tektutorialshub.com/angular/tap-operator-in-angular-observable/
- The Angular Tap RxJs operator returns an observable that is identical to the source. It does not modify the stream in any way. Tap operator is useful for logging the value, debugging the stream for the correct values, or perform any other side effects.

- Ex - 
of(1, 2, 3, 4, 5)
      .pipe(
        tap(val => {
          console.log("Tap " + val);
        })
      )
      .subscribe(val => console.log("at Subscriber " + val));

O/p -
Tap 1
at Subscriber 1
Tap 2
at Subscriber 2
Tap 3
at Subscriber 3
Tap 4
at Subscriber 4
Tap 5
at Subscriber 5

- One of the use cases for the tap operator is using it to debug the Observable for the correct values.

    of(1, 2, 3, 4, 5)
      .pipe(
        tap(val => {
          console.log("before " +val);
        }),
        map(val => {
          return val + 5;
        }),
        tap(val => {
          console.log("after " +val);
        })
      )
      .subscribe(val => console.log(val));
 
 
**Console**
before 1
after 6
6
before 2
after 7
7
before 3
after 8
8

8.SwitchMap
https://www.tektutorialshub.com/angular/using-switchmap-in-angular/

- The Angular SwitchMap maps each value from the source observable into an inner observable, subscribes to it, and then starts emitting the values from it. It creates a new inner observable for every value it receives from the Source. Whenever it creates a new inner observable it unsubscribes from all the previously created inner observables. Basically it switches to the newest observable discarding all other.

- Syntax
switchMap(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>

Ex - 
let srcObservable= of(1,2,3,4)
let innerObservable= of('A','B','C','D')
 
srcObservable.pipe(
  switchMap( val => {
    console.log('Source value '+val)
    console.log('starting new observable')
    return innerObservable
  })
)
.subscribe(ret=> {
  console.log('Recd ' + ret);
})
 
 
//Output
Source value 1
starting new observable
Recd A
Recd B
Recd C
Recd D
Source value 2
starting new observable
Recd A
Recd B
Recd C
Recd D
Source value 3
starting new observable
Recd A
Recd B
Recd C
Recd D
Source value 4
starting new observable
Recd A
Recd B
Recd C
Recd D

SwitchMap Vs Map
The map operators emits value as observable. The SwitchMap creates a inner observable, subscribes to it and emits its value as observable.

The Following example shows the difference between them.

The map operator below maps the value coming from the source observable to a new value by multiplying it by 2. It then emits it into the observable stream. The subscribers will receive the values 2,4,6 & 8.
 
let obs= of(1,2,3,4)
 
//Using MAP
obs.pipe(
  map(val => {
    return val*2      //Returning Value
  })
)
.subscribe(ret=> {
  console.log('Recd from map : ' + ret);
})
 
//Output
Recd from map : 2
Recd from map : 4
Recd from map : 6
Recd from map : 8
 
We can write the above code using SwitchMap as follows. The only thing that changes is how we return the new value in the project function. The map example returns the value as val*2, while the SwitchMap returns new observable (of(val*2)) using the of function. It also subscribes to the newly created observable and emits its value to the stream.

let obs= of(1,2,3,4)
 
obs.pipe(
   switchMap( val => {
     return of(val*2)  //Returning observable
   })
)
.subscribe(ret=> {
  console.log('Recd from switchMap : ' + ret);
 })
 
//Output
Recd from switchMap : 2
Recd from switchMap : 4
Recd from switchMap : 6
Recd from switchMap : 8

- When we use the Angular Router to Pass parameter to route, we need to read it in our component class. We do that by subscribing to the paramMap to get the id. We then use the id to retrieve the product data.

Ex -
ngOnInit() {
    this._Activatedroute.paramMap.subscribe(params => { 
       this.service.getProduct(+params.get('id')) 
          .subscribe((product: Product) => this.product = product);
    });
  }

- Consider the example where the user navigates to the /product/1 route. The service will send the query to the database to get the Product with id 1. Now, the user decides to navigate to the route /product/2. This will also result in another query for the Product being sent to the database. It is possible that the result of the second query arrives before the first query. In such a scenario, we will be in the route /product/2 , while our component displays the data of the product 1.

We can easily solve the above issue using the switchMap. When SwitchMap creates the second observable it unsubscribes from all the previous observable. Hence even if the Product 1 data arrives late, it would be discarded as there are no subscribers

Ex -
ngOnInit() {
 
    this.activatedRoute.paramMap
      .pipe(
        switchMap((params: Params) => {
          return this.service.getProduct(params.get('id'))
        }
        ))
      .subscribe((product: Product) => this.product = product);
}

- Angular Forms ValueChanges event
The similar situations described above can also happen when we subscribe to the ValueChanges event and use that to get data from the back end.

this.mainForm.get("productCode").valueChanges
.pipe(
  debounceTime(700)
)
.subscribe(val=> {
  this.queryDepositData(val)
    .subscribe(data => {
      this.product=data;
  })
})

The switchMap ensures that only the result from the last observable populates the Product

this.mainForm.get("productCode").valueChanges
.pipe(
  debounceTime(700),
  switchMap(val => {
    return this.queryDepositData();
  })
)
.subscribe(data => {
  this.product=data;
})

- The example also uses the debounceTime operator, which emits a value from the source Observable only after a particular time span has passed without another source emission.

9.MergeMap
https://www.tektutorialshub.com/angular/using-mergemap-in-angular/



10.ConcatMap
11.ExhaustMap
12.take, takeUntil, takeWhile, takeLast
13.First, last & Single
14.Skip, SkipWhile, SkipUntil & SkipLast
15.Scan & Reduce
16.DebounceTime & Debounce
17.Delay & DelayWhen
18.ThrowError
19.CatchError
20.ReTry & ReTryWhen
21.Unsubscribe from an observable

* Styling the Application

- The Angular uses several different ways to style the Application. You can style the app globally and then override it locally in the component very easily. The component styles have local scope, which is achieved using the various View Encapsulation strategies. Learn all these in the section

1.Angular Global Styles
2.View Encapsulation
3.Style binding in Angular
4.Class Binding in Angular
5.Component Styles
6.How to Install & Use Angular FontAwesome
7.How to Add Bootstrap to Angular

* Others
1.Location Service

* Configuration
- The apps usually need some sort of Run-time configuration information like URL endpoint etc, which it needs to load at startup. Also, different environments like development, production & testing require different environments, etc.

1.How to use APP_INITIALIZER
2.Run time configuration
3.Environment Variables

*  Handling Errors
- We handle errors by setting up a Global Error handler or custom error handler. Also,.whenever the error occurs in an HTTP operation, the Angular wraps it in an httpErrorResponse Object. Learn how to handle the HTTP Errors also.

1.Error Handling in Angular
2.HTTP Error Handling

* Angular CLI

1.Angular CLI Tutorial
2.Upgrading Angular App to the latest version
3.Multiple App in One Project

* SEO & Angular

- You need to set up Title & Meta Tags for each page. Ensure that the search engines can crawl and read your page. Set the correct Canonical URL for each page etc.

1.Title Service Example
2.Dynamic Title based on Route
3.Meta Service
4.Dynamic Meta Tags
5.Canonical URL
6.Lazy Load Images in Angular

* Angular Universal

The following Angular Universal Tutorial explains how to achieve Server Side Rendering using Angular Universal. The rendering the App on the server side makes it load quickly and also ensures that the search engines can crawl the content

1. Server-Side Rendering Angular Universal Tutorial

* Building & Hosting

1. Requested URL Not found on this server

* Angular Resources

1.Angular Examples & Projects
2.The Angular Learning Resources

* Angular how-to guides

1.How to get the current Route
2.ExpressionChangedAfterItHasBeenCheckedError in Angular
3.Angular CLI Check Version

* Module Loaders

The Angular application can use either SystemJs or Webpack module loader. We will demonstrate how to make use of both the Loader by building a small application.

1.Create Angular Application using SystemJS
2.Create Angular Application using Webpack
