C# Notes from Kudvenkat

1. Part 1 - C# Tutorial - Introduction.avi

* Using System declaration
- A namespace is used to organise your code and is collection of classes, interfaces, structs, enums and delegates.

- Main method is the entry point into your application.

2. Part 2 - C# Tutorial - Reading and writing to a console.avi

- C# is case sensitive.
- Console.ReadLine return type is string.

- Two ways to write to console
a. Concatenation 
Ex- Console.WriteLine("Hello "+username);

b. Place Holder syntax
Ex- Console.WriteLine("Hello {0}",username);

3. Part 3 - C# Tutorial - Built - in types.avi

sbyte (signed 8 bit) - (-128 to 127) 
byte (Unsigned 8 bit integer) - (0 to 255) 

- To find range of any data type.
Console.WriteLine(int.MinValue+" to "+int.MaxValue);

To store decimal you cannot use int data type. Use below data types for better precision.
- float - Precision - 7 digits
- double - Precision - 15 to 16 digits.
- decimal - Precision - 28 to 29 significant digits

4. Part 4 - C# Tutorial - String type in c#.avi

* Escape Sequence - 
\" - double quote
\a - Bell (alert)
\b - Backspace
\n - New line
\\ - Backslash

Ex - 
string s = "\"VVS\"";	\\"VVS"

* Verbatim Literal - It makes escape sequence translate as normal printable characters to enhance readability. If want to treat escape sequence as normal string use @ before string. Mainly used for file path.

Ex - string s = @""VVS""; \\"VVS"

5. Part 5 - C# Tutorial - Common Operators in c#.avi

Assignment Operator =
Arithmetic Operators like +,-,*,/,% 
Conditional Operators like &&, ||
Ternary Operator ?:
Null Coalescing Operator ?? 

6. Part 6 - C# Tutorial - Nullable Types.avi

* Types in C#
a. Value Types - int, float, double, structs, enums etc.
b. Reference Types - interface, class, delegates, arrays etc.

- By default value types are non nullable. To make them nullable use "?" and by default  reference types are null.

- int i = 0 (i is non nullable, so I cannot be set to null, i = null will generate compile error)

- int? j = 0 (j is nullable int, so j=null is legal)

- Nullable types bridge the differences between C# types and Database types. Take one example like suppose in form field we have one input field which is not compulsory for user to enter details. At that time you to store null data in DB so for that purpose this Nullable types are used to differenciate between User not answering the question and saying No or Yes. Also in DB there is nothing concept like value and reference type. You can store null data in any datatype (int, nvarchar etc.).

* Null Coalescing Operator
Ex - 
int? TicketsOnSale = 100;
int AvailableTickets = TicketsOnSale ?? 0;

If TicketsOnSale is null then use 0 else use TicketsOnSale value.

7. Part 7 C# Tutorial Datatypes conversion

* Implicit & Explicit conversion
- Implicit conversion is done by the compiler:
a. When there is no loss of information if the conversion is done.
b. If there is not possibility of throwing exceptons during the conversion.

Example - Converting an int to a float will not loose any data and no exception will be thrown, hence an implicit conversion can be done.

Where as when converting a float to an in, we loose the fractional part and also a possibility of overflowing exception. Hence, in this case an explicit conversion is required. For explicit conversion we can use cast operator or the convert class in c#.

- With using type cast operator we don't get exception if value is overflowing but with using Convert we get exception.
Ex - 
float f = 123456789.45F;
int i = (int)f; //int.MinValue -23....
int j = Convert.ToInt32(f); //System.Overflow exception


* Difference between Parse and TryParse
- If the number is in a string format you have 2 options - Parse() and TryParse().
- Parse() method throws an exception if it cannot parse the value, whereas TryParse returns a bool indicating whether it succeeded or failed.
- Use Parse() if you are sure the value will be valid, otherwise use TryParse().

8. Part 8 - C# Tutorial - Arrays in C#.avi

- An array is a collection of similar data types.

Advatages: Arrays are strongly typed.

DisAdvantages: Arrays cannot grow in size once initialized. Have to rely on integral indices to store or retrive items from the array. At runtime you get IndexOutOfRangeException if array size using more than declared.

10. Part 10 - C# Tutorial - If statement in C#

Difference between && and &, || and |
- && or || checks only first condition if it is true it will not go to second condition whereas & or | will check even if first one is true. So && and || are performance benefit.

11. Part 11 - C# Tutorial - switch statement in C#

Important interview question
Ex - 
switch(Number)
{
	case 10:
	case 20:
	case 30:
			Console.WriteLine("Number is {0}", Number);
			break;
	default:
			Console.WriteLine("No");
			break;
}

O/P - 
20
Number is 20

Because, Case statements, with no code in between, creates a single case for multiple values. A case without any code will automatically fall through to the next case. In this example, case 10 and case 20 will fall through and execute code for case 30.

- break statement: If break statement is used inside a switch statement, the control will leave the switch statement.

- goto statement: You can either jump to another case statement, or to a specific label.
Warning: Using goto is bad programming style. We should avoid goto all means.

14. Part 14 - C# Tutorial - do while loop in c#

- A do loop checks its condition at the end of the loop.
- This means that the do loop is guarantted to execute at least one time.
- Do loops are used to present a menu to the user.

15. Part 15 - C# Tutorial - for and foreach loops in c#.avi

- A foreach loop is used to iterate throgh the items in a collection. For example, foreach loop can be used with arrays or collections such as ArrayList, HashTable and Generics.

16. Part 16 - C# Tutorial - Methods in c#.avi

- Methods are extremely useful because they allow you to define your logic once, and use it, at many pieces.

- Methods make the maintenance of your application easier.

* Static vs Instance methods

- When a method declaration includes a static modifier, that method is said to be a static method. When no static modifier is present, the method is said to be an instance method.

- Static method is involved using the class name, where as an instance method is involved using an instance of the class.

- The difference between instance methods and static methods is that multiple instances of a class can be created (or instantiated) and each instance has its own seperate method. However when a method is static, there are no isntance of that method, and you can involve only that one defination of the static method. 

17. Part 17 - C# Tutorial - Method parameters.avi

* Method parameter types

a. Value Parameters: Creayes a copy of the parameter passed, so modification does not affect each other.

b. Reference Parameters: The ref method parameter keyword on a method parameter causes a method to refer to the same variable that was passed into the method. Any changes made to the parameter in the method will be relected in that variable when control passes back to the calling method.

c. Out Parameters: Use when you want a method to return more than one value.

d. Parameter Arrays: The params keyword lets you specify a method parameter that takes a variable number of arguments. You can send a comma-separated list of arguments, or an array, or no arguments. Params keyword should be the last one in a method declaration, and only one params keyword is permitted in an method declaration.

- The parameters which are passed in method declaration are know as Method parameters and the one passed while invoking are known as arguments.

18. Part 18 - C# Tutorial - Namespaces.avi

- Namespaces are used to oraganize your programs. They also provide assistance in avoiding name clashes.

- Namespaces don't correspond to file, directory or assembly names. They could be written in separate files and/or separate assemblies and still belong to the same namespace.

- Namespaces can be nested in 2 ways. Namespace alias directives. Sometimes you may encounter a long namespace and wish to have it shorter. This could improve readability and still avoid name clashes with similarly named methods.

- To avoid ambiguity between namespace names can use alias
using PTA = ProjectA.TeamA;

19. Part 19 - C# Tutorial - Introduction to classes.avi

* What is a class ?
- If you want to create complex custom types, then we can make use of classes. A class consists of data and behavior. Class data is represented by its field and behavior is represented by its methods.

* Purpose of a class constructor
- The purpose of a class constructor is to initialize class fields. A class constructor is automatically called when an instance of a class is created.

- Constructors do not have return values and always have the same name as the class.

- Constructors are not mandatory. If we do not provide a constructor, a default parameter less constructor is automatically provided.

- Constructors can be overloaded by the number and type of parameters.

* Destructors

- Destructors have the same name as the class with ~ symbol in front of them.

- They don't take any parameters and do not return a value.

- Destructors are places where you could put code to release any resources your class was holding during its lifetime. They are normally called when the c# garbage collector decides to clean your object from memory.


20. Part 20 - C# Tutorial - Static and instance class members.avi

* Static and Instance class members

- When a class member includes a static modifier, the member is called as static member. When no static modifier is present the member is called as non static member or instance member.

- Static members are invoked using class name, where as instance members are invoked using instances (objects) of the class.

- An instance member belongs to specific instance(object) of a class. If I create 3 objects of a class, I will have 3 sets of instance members in the memory, where as there will ever be only one copy of a static member, no matter how many instances of a class are created.

Note: Class members = fields, methods, properties, events indexers, constructors.

* Static constructor

- Static constructors are used to initialize static fields in a class.

- You declare a static constructor by using the keyword static in front of the constructor name. Because, it just need to initialize static field once it will be shared by all the objects you create. Where as instance constructor is called every time you create instance of class. 

- Static constructor is called only once, no matter how many instances you create. Static construuctors are called before instance constructors.


21. Part 21 - C# Tutorial - Inheritance in c#.avi

* Why Inheritance

Pillars of Object Oriented Programming
1. Inheritance
2. Encapsulation
3. Abstraction
4. Polymorphism

- Inheritance is one of the primary pillars of object oriented programming.
- It allows code reuse.
- Code reuse can reduce time and errors.

* Note: You will specify the common fields, properties, methods in the base class, which allows reusability. In the derived class you will only have fields, properties and methods, that are specific to them.

- Syntax:
public class ParentClass 
{
	// Parent Class implementation
}

public class DerivedClass : ParentClass
{
	// Child Class implementation
}

- In above example derived class inherits from ParentClass.
- C# supports only single class inheritance so multiple class inheritance is not supported but multi - level inheritance is supported.
- C# supports multiple interface inheritance.
- Child class is a specialization of base class.
- Base classe are automatically instantiated before derived classes.
- Parent Class constructor executes before Child Class constructor.

22. Part 22 - C# Tutorial - Method hiding in c#.avi

- Use the new keyword to hide a base class member. You will get a compiler warning. If you miss the new keyword.

- Different ways to invoke a hidden base (Parent) class member from derived class 
1. Use base keyword
2. Cast child type to parent type and invoke the hidden member
3.  A parent class reference varibale can point to child class Object. But vice versa not possible.

ParentClass PC = new ChildClass();
   PC.HiddenMethod();

1) Use new keyword when hiding base class's method in child class.
2) Can call base class's method in child class using base keyword. (base.ParentClassMethod)
Or
Cast it to Parent type:
((BaseClass) ChildClassObject). BaseClassMethod
Or
BaseClass baseClassObj = New ChildClass childclassobj
baseClassObj.baseClassMethodname

Note: ChildClass childclassObj =New BaseClass Obj (WRONG!!!)

23. Part 23 - C# Tutorial - Polymorphism in c#.avi

- Polymorphism basically enables you to invoke derived class methods through base class reference variable at runtime thats nothing but polymorphism by using override keyword in Child/Derived class and virtual in Parent/Base class. In base class the method is declared virtual and in the derived class we override the same method.

- The virtual keyword indicates the method can be overridden in any derived class. If you don't override in derived class it will invoke base class method.

- I think this is simplier way to explain polymorphism:

Employee FTE = new FullTimeEmployee();
FTE.PrintFullName();

Employee E = new Employee();
E.PrintFullName();

BaseClass bObj = New ChildClass()
bObj.commonMethodName

1> If Base method 'virtual'(Or 'override' in case on multi level inheritance) and child method 'override' -> child method executes
2> If Base method is not 'virtual'(Or 'override' in case on multi level inheritance) and child method 'new'(optional, vs prompt) -> base method executes (Also called method hiding)

- As in run time if you choose the reference of base class and the object with new keyword is of child .... and the method u declared in the base class is virtual or abstract , and u have derived it in child class... now the instance u are generating is of type child but the reference is of parent ... so compiler is gonna look parent for the method u defined and then in child the particular method u have defined... it' not easy for compiler for to do so ...so what happens is that at run time which function is to be chosen is decided when the object is passed... this is run time polymorphism

24. Part 24 - C# Tutorial - Difference between method overriding and method hiding.avi

* Method Overriding

public class BaseClass
{
	public virtual void Print()
	{
		Console.WriteLine("Base Class Print Method");
	}
}

public class DerivedClass : BaseClass
{
	public override void Print()
	{
		Console.WriteLine("Child Class Print Method");
	}
}

public class Program
{
	public static void Main()
	{
		BaseClass B = new DerivedClass();
		B.Print();
	}
}

O/P - 
Child Class Print Method

- In method overriding a base class reference variable pointing to a child class object, will invoke the overridden method in the Child class.

* Method Hiding
public class BaseClass
{
	public virtual void Print()
	{
		Console.WriteLine("Base Class Print Method");
	}
}

public class DerivedClass : BaseClass
{
	public new void Print()
	{
		Console.WriteLine("Child Class Print Method");
	}
}

public class Program
{
	public static void Main()
	{
		BaseClass B = new DerivedClass();
		B.Print();
	}
}

O/P - 
Base Class Print Method

- In method hiding a base class reference variable pointing to a child class object, will invoke the hidden method in the Base class.

25. Part 25 - C# Tutorial - Method overloading in c#.avi

- Function overloading and Method overloading terms are used interchangeably.

- Method overloading allows a class to have multiple methods with the same name but, with a different signature. So, in C# functions can be overloaded based on the number, type (int, float etc.) and kind (Value, Ref or Out) of parmaeters.

- The signature of a method consists of the name of the method and the type, kind (Value, Ref or Out) and number of its formal parameters. The signature of a method does not include return type and the params modifier. So, it is not possible to overload a function, just based on the return type or params modifier.

26. Part 26 - C# Tutorial - Why Properties.avi

- Marking the class fields public and exposing to the external world is bad, as you will not have control over what gets assigned and returned. Suppose if you want id to be non-negative and if you kept id as public it is bad so by using properties getter setter methods we can handle that.

- Programming languages that does not have properties use getter and setter methods to encapsulate and protect fields.
