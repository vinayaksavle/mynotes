C# Notes from Kudvenkat

1. Part 1 - C# Tutorial - Introduction.avi

* Using System declaration
- A namespace is used to organise your code and is collection of classes, interfaces, structs, enums and delegates.

- Main method is the entry point into your application.

2. Part 2 - C# Tutorial - Reading and writing to a console.avi

- C# is case sensitive.
- Console.ReadLine return type is string.

- Two ways to write to console
a. Concatenation 
Ex- Console.WriteLine("Hello "+username);

b. Place Holder syntax
Ex- Console.WriteLine("Hello {0}",username);

3. Part 3 - C# Tutorial - Built - in types.avi

sbyte (signed 8 bit) - (-128 to 127) 
byte (Unsigned 8 bit integer) - (0 to 255) 

- To find range of any data type.
Console.WriteLine(int.MinValue+" to "+int.MaxValue);

To store decimal you cannot use int data type. Use below data types for better precision.
- float - Precision - 7 digits
- double - Precision - 15 to 16 digits.
- decimal - Precision - 28 to 29 significant digits

4. Part 4 - C# Tutorial - String type in c#.avi

* Escape Sequence - 
\" - double quote
\a - Bell (alert)
\b - Backspace
\n - New line
\\ - Backslash

Ex - 
string s = "\"VVS\"";	\\"VVS"

* Verbatim Literal - It makes escape sequence translate as normal printable characters to enhance readability. If want to treat escape sequence as normal string use @ before string. Mainly used for file path.

Ex - string s = @""VVS""; \\"VVS"

5. Part 5 - C# Tutorial - Common Operators in c#.avi

Assignment Operator =
Arithmetic Operators like +,-,*,/,% 
Conditional Operators like &&, ||
Ternary Operator ?:
Null Coalescing Operator ?? 

6. Part 6 - C# Tutorial - Nullable Types.avi

* Types in C#
a. Value Types - int, float, double, structs, enums etc.
b. Reference Types - interface, class, delegates, arrays etc.

- By default value types are non nullable. To make them nullable use "?" and by default  reference types are null.

- int i = 0 (i is non nullable, so I cannot be set to null, i = null will generate compile error)

- int? j = 0 (j is nullable int, so j=null is legal)

- Nullable types bridge the differences between C# types and Database types. Take one example like suppose in form field we have one input field which is not compulsory for user to enter details. At that time you to store null data in DB so for that purpose this Nullable types are used to differenciate between User not answering the question and saying No or Yes. Also in DB there is nothing concept like value and reference type. You can store null data in any datatype (int, nvarchar etc.).

* Null Coalescing Operator
Ex - 
int? TicketsOnSale = 100;
int AvailableTickets = TicketsOnSale ?? 0;

If TicketsOnSale is null then use 0 else use TicketsOnSale value.

7. Part 7 C# Tutorial Datatypes conversion

* Implicit & Explicit conversion
- Implicit conversion is done by the compiler:
a. When there is no loss of information if the conversion is done.
b. If there is not possibility of throwing exceptons during the conversion.

Example - Converting an int to a float will not loose any data and no exception will be thrown, hence an implicit conversion can be done.

Where as when converting a float to an in, we loose the fractional part and also a possibility of overflowing exception. Hence, in this case an explicit conversion is required. For explicit conversion we can use cast operator or the convert class in c#.

- With using type cast operator we don't get exception if value is overflowing but with using Convert we get exception.
Ex - 
float f = 123456789.45F;
int i = (int)f; //int.MinValue -23....
int j = Convert.ToInt32(f); //System.Overflow exception


* Difference between Parse and TryParse
- If the number is in a string format you have 2 options - Parse() and TryParse().
- Parse() method throws an exception if it cannot parse the value, whereas TryParse returns a bool indicating whether it succeeded or failed.
- Use Parse() if you are sure the value will be valid, otherwise use TryParse().

8. Part 8 - C# Tutorial - Arrays in C#.avi

- An array is a collection of similar data types.

Advatages: Arrays are strongly typed.

DisAdvantages: Arrays cannot grow in size once initialized. Have to rely on integral indices to store or retrive items from the array. At runtime you get IndexOutOfRangeException if array size using more than declared.

10. Part 10 - C# Tutorial - If statement in C#

Difference between && and &, || and |
- && or || checks only first condition if it is true it will not go to second condition whereas & or | will check even if first one is true. So && and || are performance benefit.

11. Part 11 - C# Tutorial - switch statement in C#

Important interview question
Ex - 
switch(Number)
{
	case 10:
	case 20:
	case 30:
			Console.WriteLine("Number is {0}", Number);
			break;
	default:
			Console.WriteLine("No");
			break;
}

O/P - 
20
Number is 20

Because, Case statements, with no code in between, creates a single case for multiple values. A case without any code will automatically fall through to the next case. In this example, case 10 and case 20 will fall through and execute code for case 30.

- break statement: If break statement is used inside a switch statement, the control will leave the switch statement.

- goto statement: You can either jump to another case statement, or to a specific label.
Warning: Using goto is bad programming style. We should avoid goto all means.

14. Part 14 - C# Tutorial - do while loop in c#

- A do loop checks its condition at the end of the loop.
- This means that the do loop is guarantted to execute at least one time.
- Do loops are used to present a menu to the user.

15. Part 15 - C# Tutorial - for and foreach loops in c#.avi

- A foreach loop is used to iterate throgh the items in a collection. For example, foreach loop can be used with arrays or collections such as ArrayList, HashTable and Generics.

16. Part 16 - C# Tutorial - Methods in c#.avi

- Methods are extremely useful because they allow you to define your logic once, and use it, at many pieces.

- Methods make the maintenance of your application easier.

* Static vs Instance methods

- When a method declaration includes a static modifier, that method is said to be a static method. When no static modifier is present, the method is said to be an instance method.

- Static method is involved using the class name, where as an instance method is involved using an instance of the class.

- The difference between instance methods and static methods is that multiple instances of a class can be created (or instantiated) and each instance has its own seperate method. However when a method is static, there are no isntance of that method, and you can involve only that one defination of the static method. 

17. Part 17 - C# Tutorial - Method parameters.avi

* Method parameter types

a. Value Parameters: Creayes a copy of the parameter passed, so modification does not affect each other.

b. Reference Parameters: The ref method parameter keyword on a method parameter causes a method to refer to the same variable that was passed into the method. Any changes made to the parameter in the method will be relected in that variable when control passes back to the calling method.

c. Out Parameters: Use when you want a method to return more than one value.

d. Parameter Arrays: The params keyword lets you specify a method parameter that takes a variable number of arguments. You can send a comma-separated list of arguments, or an array, or no arguments. Params keyword should be the last one in a method declaration, and only one params keyword is permitted in an method declaration.

- The parameters which are passed in method declaration are know as Method parameters and the one passed while invoking are known as arguments.

18. Part 18 - C# Tutorial - Namespaces.avi

- Namespaces are used to oraganize your programs. They also provide assistance in avoiding name clashes.

- Namespaces don't correspond to file, directory or assembly names. They could be written in separate files and/or separate assemblies and still belong to the same namespace.

- Namespaces can be nested in 2 ways. Namespace alias directives. Sometimes you may encounter a long namespace and wish to have it shorter. This could improve readability and still avoid name clashes with similarly named methods.

- To avoid ambiguity between namespace names can use alias
using PTA = ProjectA.TeamA;

19. Part 19 - C# Tutorial - Introduction to classes.avi

* What is a class ?
- If you want to create complex custom types, then we can make use of classes. A class consists of data and behavior. Class data is represented by its field and behavior is represented by its methods.

* Purpose of a class constructor
- The purpose of a class constructor is to initialize class fields. A class constructor is automatically called when an instance of a class is created.

- Constructors do not have return values and always have the same name as the class.

- Constructors are not mandatory. If we do not provide a constructor, a default parameter less constructor is automatically provided.

- Constructors can be overloaded by the number and type of parameters.

* Destructors

- Destructors have the same name as the class with ~ symbol in front of them.

- They don't take any parameters and do not return a value.

- Destructors are places where you could put code to release any resources your class was holding during its lifetime. They are normally called when the c# garbage collector decides to clean your object from memory.


20. Part 20 - C# Tutorial - Static and instance class members.avi

* Static and Instance class members

- When a class member includes a static modifier, the member is called as static member. When no static modifier is present the member is called as non static member or instance member.

- Static members are invoked using class name, where as instance members are invoked using instances (objects) of the class.

- An instance member belongs to specific instance(object) of a class. If I create 3 objects of a class, I will have 3 sets of instance members in the memory, where as there will ever be only one copy of a static member, no matter how many instances of a class are created.

Note: Class members = fields, methods, properties, events indexers, constructors.

* Static constructor

- Static constructors are used to initialize static fields in a class.

- You declare a static constructor by using the keyword static in front of the constructor name. Because, it just need to initialize static field once it will be shared by all the objects you create. Where as instance constructor is called every time you create instance of class. 

- Static constructor is called only once, no matter how many instances you create. Static construuctors are called before instance constructors.


21. Part 21 - C# Tutorial - Inheritance in c#.avi

* Why Inheritance

Pillars of Object Oriented Programming
1. Inheritance
2. Encapsulation
3. Abstraction
4. Polymorphism

- Inheritance is one of the primary pillars of object oriented programming.
- It allows code reuse.
- Code reuse can reduce time and errors.

* Note: You will specify the common fields, properties, methods in the base class, which allows reusability. In the derived class you will only have fields, properties and methods, that are specific to them.

- Syntax:
public class ParentClass 
{
	// Parent Class implementation
}

public class DerivedClass : ParentClass
{
	// Child Class implementation
}

- In above example derived class inherits from ParentClass.
- C# supports only single class inheritance so multiple class inheritance is not supported but multi - level inheritance is supported.
- C# supports multiple interface inheritance.
- Child class is a specialization of base class.
- Base classe are automatically instantiated before derived classes.
- Parent Class constructor executes before Child Class constructor.

22. Part 22 - C# Tutorial - Method hiding in c#.avi

- Use the new keyword to hide a base class member. You will get a compiler warning. If you miss the new keyword.

- Different ways to invoke a hidden base (Parent) class member from derived class 
1. Use base keyword
2. Cast child type to parent type and invoke the hidden member
3.  A parent class reference varibale can point to child class Object. But vice versa not possible.

ParentClass PC = new ChildClass();
   PC.HiddenMethod();

1) Use new keyword when hiding base class's method in child class.
2) Can call base class's method in child class using base keyword. (base.ParentClassMethod)
Or
Cast it to Parent type:
((BaseClass) ChildClassObject). BaseClassMethod
Or
BaseClass baseClassObj = New ChildClass childclassobj
baseClassObj.baseClassMethodname

Note: ChildClass childclassObj =New BaseClass Obj (WRONG!!!)

23. Part 23 - C# Tutorial - Polymorphism in c#.avi

- Polymorphism basically enables you to invoke derived class methods through base class reference variable at runtime thats nothing but polymorphism by using override keyword in Child/Derived class and virtual in Parent/Base class. In base class the method is declared virtual and in the derived class we override the same method.

- The virtual keyword indicates the method can be overridden in any derived class. If you don't override in derived class it will invoke base class method.

- I think this is simplier way to explain polymorphism:

Employee FTE = new FullTimeEmployee();
FTE.PrintFullName();

Employee E = new Employee();
E.PrintFullName();

BaseClass bObj = New ChildClass()
bObj.commonMethodName

1> If Base method 'virtual'(Or 'override' in case on multi level inheritance) and child method 'override' -> child method executes
2> If Base method is not 'virtual'(Or 'override' in case on multi level inheritance) and child method 'new'(optional, vs prompt) -> base method executes (Also called method hiding)

- As in run time if you choose the reference of base class and the object with new keyword is of child .... and the method u declared in the base class is virtual or abstract , and u have derived it in child class... now the instance u are generating is of type child but the reference is of parent ... so compiler is gonna look parent for the method u defined and then in child the particular method u have defined... it' not easy for compiler for to do so ...so what happens is that at run time which function is to be chosen is decided when the object is passed... this is run time polymorphism

24. Part 24 - C# Tutorial - Difference between method overriding and method hiding.avi

* Method Overriding

public class BaseClass
{
	public virtual void Print()
	{
		Console.WriteLine("Base Class Print Method");
	}
}

public class DerivedClass : BaseClass
{
	public override void Print()
	{
		Console.WriteLine("Child Class Print Method");
	}
}

public class Program
{
	public static void Main()
	{
		BaseClass B = new DerivedClass();
		B.Print();
	}
}

O/P - 
Child Class Print Method

- In method overriding a base class reference variable pointing to a child class object, will invoke the overridden method in the Child class.

* Method Hiding
public class BaseClass
{
	public virtual void Print()
	{
		Console.WriteLine("Base Class Print Method");
	}
}

public class DerivedClass : BaseClass
{
	public new void Print()
	{
		Console.WriteLine("Child Class Print Method");
	}
}

public class Program
{
	public static void Main()
	{
		BaseClass B = new DerivedClass();
		B.Print();
	}
}

O/P - 
Base Class Print Method

- In method hiding a base class reference variable pointing to a child class object, will invoke the hidden method in the Base class.

25. Part 25 - C# Tutorial - Method overloading in c#.avi

- Function overloading and Method overloading terms are used interchangeably.

- Method overloading allows a class to have multiple methods with the same name but, with a different signature. So, in C# functions can be overloaded based on the number, type (int, float etc.) and kind (Value, Ref or Out) of parmaeters.

- The signature of a method consists of the name of the method and the type, kind (Value, Ref or Out) and number of its formal parameters. The signature of a method does not include return type and the params modifier. So, it is not possible to overload a function, just based on the return type or params modifier.

26. Part 26 - C# Tutorial - Why Properties.avi

- Marking the class fields public and exposing to the external world is bad, as you will not have control over what gets assigned and returned. Suppose if you want id to be non-negative and if you kept id as public it is bad so by using properties getter setter methods we can handle that.

- Programming languages that does not have properties use getter and setter methods to encapsulate and protect fields.

27. Part 27 - C# Tutorial - Properties in C#.avi

- In C# to encapsulate and protect fields we use properties.
- We use get and set accessors to implement properties.
- A property with both get and set accessor is a Read/write property.
- A property with only get accessor is a Read only property.
- A property with only set accessor is a Write only property.

Note: The advantage of properties over traditional Get() and Set() methods is that, you can access them as if they were public fields.

- Example:

public class Student 
{
	private int _id;
	public int Id
	{
		set
		{
			if(value <= 0)
			{
				throw new Exception("Student Id cannot be negative");
			}
			this._id = value
		}
		get
		{
			return this._id;
		}
	}
}

Student s = new Student();
s.Id = 101; //set
Console.WriteLine(s.Id); //get

* Auto Implemented Properties

- If there is no additional logic in the property accessors, then we can make use of auto implemented properties introduced in C# 3.0

- Auto implemented properties reduce the amount of code that we have to write.

- When you use auto-implemented properties, the compiler creates a private, anonymous field that can only be accessed through the properties get and set accessors.

Example:

private string _email;
public string Email
{
	get
	{
		return this._email;
	}
	set
	{
		this._email = value;
	}
}

In auto implementation Will be written as,

public string Email { get; set; }

- Compiler will create a backing private fields.

28. Part 28 - C# Tutorial - Structs in C#.avi

- Just like classes structs can have
1. Private Fields
2. Public Properties
3. Constructors
4. Methods

- Object initializer syntax, introduced in C# 3.0 can be used to initialize either a struct or a class.

Example:
Previously,
Customer c1 = new Customer();
c1.Id = 101;
c1.Print();

Object initializer syntax,
Customer c2 = new Customer
{
	Id = 102,
	Name = "VVS"
};
c2.Print();

29. Part 29 - C# Tutorial - Difference between classes and structs in c#.avi

* Classes Vs Structs
- A struct is a value type where as a class is a reference type.
- All the differences that are applicable to value types and reference types are also applicable to class and structs.
- Structs are stored on stack, where as classes are stores on the heap.
- Value types hold their value in memory where they are declared, but reference types hold a reference to an object in memory.
- Value types are destroyed immediately after the scope is lost, where as for reference types only the reference variable is destroyed after the scope is lost. The object is later destroyed by garbage collector. 
- When you copy a struct into another struct, a new copy of that struct gets created and modifications on one struct will not affect the values contained by the other struct.
- When you copy a class into another class we only get a copy of the reference variable. Both the reference variables point to the same object on the heap. So operations on one variable will affect the values conatined by the other reference variables.
- Structs can't have destructors, but classes can have destructors.
- Structs cannot have explicit parameter less constructor where as class can.
- Struct can't inherit from another class where as a class can. Both structs and classes can inherit from an interface.
-  A class or struct cannot inherit from another struct. Struct are sealed types.
If class is sealed it cannot act as a base/parent class.

Ex - 
1. int is a struct which is alias of struct System.Int32 also double System.Double etc.
2. Customer c1 = new Customer();
c1.Id = 101;
c1.Name = "VVS";

Here, c1 is object reference variable which is stored on Stack. and Id, Name are actual customer object which is stored on Heap.


30. Part 30 - C# Tutorial - Interfaces in c#.avi

- We create interfaces using interface keyword. Just like classes, interfaces also contains properties, methods, delegates or events but only declaration and no implementations.

- It is a compile time error to provide implementation for any interface member.

- Interface members are public by default, and they don't allow explicit access modifiers.

- Interfaces cannot contain fields.
- If a class or a struct inherits from an interface, it must provide implementation for all interface members. Otherwise we get a compiler error.

- A class or a struct can inherit from more than one interface at the same time, but where as, a class cannot inherit from more than one class at the same time.

- Interfaces can inherit from other interfaces. A class that inherits this interface must provide implementation for all interface members in the entire interface inheritance chain.

- We cannot create an instance of an interface, but an interface reference variable can point to a derived class object.

Ex - 
public class Customer : ICustomer 
{
	public void Print() {}
}

ICustomer c1 = new Customer();
c1.Print();

31. Part 31 - C# Tutorial - Explicit interfaces implementation.avi

* Q. A class inherits from 2 interfaces and both the interfaces have the same method name. How sould the class implement the method for both the interfaces ?

Ex-
interface I1
{
	void IMethod();
}
interface I2
{
	void IMethod();
}

class Program : I1,I2
{
	static void Main()
	{
		Program p = new Program();
		((I1)P).IMethod();
		((I2)P).IMethod();
		
		or 
		I1 i1 = new Program();
		I1 i2 = new Program();
		i1.IMethod();
		i2.IMethod();
	}
	void I1.IMethod()
	{
		Console.WriteLine("I1");
	}
	void I2.IMethod()
	{
		Console.WriteLine("I2");
	}
}

We are using Explicit interface implementation techinique to solve this problem.

Note: WHen a class explicitly implements and interface member,  the interface member can no longer be accessed through class reference variable, but only through the interface reference variable.

Access modifiers are not allowed on explicit implemented interface members.

- If you want to make one of the interface method, the default, then implement that method normally and the other interface method explicitly. This makes the default method to be accessible through class instance.

32. Part 32 - C# Tutorial - Abstract classes in c#.avi

- The abstract keyword is used to create abstract classes.
- An abstract class is incomplete and hence cannot be instantiated.
- An abstract class can only be used as base class.
- An abstract class cannot be sealed.
- An abstract class may contain abstract members (methods, properties, indexers and events) but not mandatory.
- A non-abstarct class derived from an abstract class must provide implementations for all inherited abstract members.

- If a class inherits an abstract class, there are 2 options available for that class.
Option 1: Provide implementation for all the abstract members inherited from the base abstract class.
Option 2: If the class does not wish to provide implementation for all the abstract members inherited from the abstract class, then class has to be marked as abstract.

33. Part 33 - C# Tutorial - Difference between abstract classes and interfaces.avi

- Abstract classes can have implementation for some of its members (Methods), but the interface can't have implementation for any of its members.

- Interfaces cannot have fields where as an abstract class can have fields.

- An interface can inherit from another interface only and cannot inherit from an abstarct class, where as an abstract class can inherit from another abstract class or another interface.

- A class can inherit from multiple interfaces at the same time, where as a class cannot inherit from multiple classes at the same time.

- Abstract class members can have access modifiers where as interface members cannot have access modifiers.

34. Part 34 - C# Tutorial - Problems of multiple class inheritance.avi

* Diamond Problem

Example:
class A
{
	public virtual void Print()
	{
		Console.WriteLine("Class A");
	}
}

class B : A
{
	public override void Print()
	{
		Console.WriteLine("Class B");
	}
}

class C : A
{
	public override void Print()
	{
		Console.WriteLine("Class C");
	}
}
class D : B, C
{

}

class Program
{
	public static void Main()
	{
		D d = new D();
		d.Print();
	}
}

- Class B and Class C inherit from Class A.
- Class D inherits from both B and C.
- If a method in D calls a method defined in A (and does not override the method), and B and C have overridden that method differently, then from which class does it inherit B or C ?

This ambiguity is called as Diamond Problem.

35. Part 35 - C# Tutorial - Multiple class inheritance using interfaces.avi


36. Part 36 - C# Tutorial - Delegates in c#.avi

- A delegate is a type safe function pointer. That is, it holds a reference (Pointer) to a function. type safe meaning signature of delegate should match signature of the method which we are using in delegate.

- The signature of the delegate must match the signature of the function, the delegate points to, otherwise you get a compiler error. This is the reason delegates are called as type safe function pointers.

- A Delegate is similar to a class. You can create an instance of it and when you do so, you pass in the function name as a parameter to the delegate constructor and it is to this function the delegate will point to.

Example:

public delegate void HelloFunct(string msg);

class Program
{
	public static void Main()
	{
		HellowFunct del = new HelloFunct(Hello);
		del("Hi")
	}
	
	public static void Hello(string msg)
	{
		Console.WriteLine(msg);
	}
}

37. Part 37 - C# Tutorial - Delegates usage in c#.avi


39. Part 39 C# Tutorial Multicast Delegates in C#

* Multicast Delegates
- A Multicast delegate is a delegate that has references to more than one function. When you invoke a multicast delegate, all the functions the delegate is poniting to are invoked.

- There are 2 approaches to create a multicast delegate. Depending on the approach you use 

+ or += to register a method with the delegate

- or -= to unregister a method with the delegate

Note: A multicast delegate, invokes the methods in the invocation list, in the same order in which they are added.

- If the delegate has return type other than void and if the delegate is a multicast delegate, only the value of the last invoked method will be returned. Along the same lines, if the delegate has an out parameter, the value of the output parameter will be the value assigned by the last method.

- where do you use multicast delegates ?
Multicast delegate makes implementation of observer design pattern very simple. Observer pattern is also called as publish/subscribe pattern.

40. Part 40 C# Tutorial Exception Handling in C#

- An exception is an unforeseen error that occurs when a program is running.

- Example:
Trying to read from a file that does not exist, throws FileNotFountException.
Trying to read from a database table that does not exist, throws a SqlException.

- Showing actual unhandled exceptions to the end user is bad for two reasons.
1. Users will be annoyed as they are cryptic and does not make much sense to the end users.
2. Exceptions contain information, that can be used for hacking into your application.

- An exception is actually a class that derives from System.Exception class. The System.Exception class has several useful properties, that provide valuable information about the exception.
- Message: Gets a message that describes the current exception
Stack Trace: Provides the call stack to the line number in the method where the exception occured.

* Releasing System Resources:
- We use try, catch and finally blocks for exception handling.
try - The code that can possible cause an exception will be in the try block.
catch - Handles the exception.
finally - Clean and free resources that the class was holding onto during the program execution. Finally block is optional.

Note: It is a good practice to always release resources in the finally block, because finally block is guaranteed to execute, irrespective of whether there is an exception or not.

- Specific exceptions will be caught before the base general exception, so specific exception blocks should always be on top of the base exception block. Otherwise, you will encounter a compiler error.

41. Part 41 C# Tutorial Inner Exceptions in C#

- The InnerException property returns the Exception instance that caused the current exception.
- To retain the original exception pass it as a parameter to the constructor, of the current exception.
- Always check if inner exception is not null before accessing any property of the inner exception object, else you may get Null Reference Exception
- To get the type of InnerException use GetType() method.

42. Part 42 C# Tutorial Custom Exceptions in C#

* When do you usually go for creating your own custom exceptions ?
- If none of the already dotnet exceptions adequately describes the problem.

Example: If application should allow the user to have only one logged in session and if user already logged in then application should throw exception as he already logged in. Here you can create custom exception.

* Custom Exception - Steps
- Create a class that derives from System.Exception class. As a convention, end the class name with Exception suffix. All .NET exceptions end with exception suffix.

- Provide a public constructor, that takes in a string parameter. This constructor simple passes the string parameter, to the base exception class constructor.

- Using InnerExceptions you can also track back the original exception. If you want to provide the capability for your custome exception class, then overload the constructor accordingly.

- If you want your Exception class object to work across application domains. then the object must be serializable. To make your exception class serializable mark it with serializable attribute and provide a constructor that invokes the base exception class constructor that takes in SerializationInfo and StreamingContext object as parameters.

43. Part 43 C# Tutorial Exception handling abuse

- Exceptions are unforeseen errors that occur when a program is runnning. For example, when an application is executing a query, the database connection is lost. Exception handling is generally used to handle these scenarios.

- Using exception handling to implement program logical flow is bad and is termed as exception handling abuse.

44. Part 44 C# Tutorial Preventing exception handling abuse

45. Part 45 C# Tutorial Why Enums

- Enums are strongly typed constants.
- If a program uses a set of integral numbers, consider replacing them with enums. Otherwise the program becomes less Readable, Maintainable

46. Part 46 C# Tutorial Enums Example

47. Part 47 C# Tutorial Enums in c#

- If a program uses set of integral numbers, consider replacing them with enums which makes the program more readable.

- Enums are enumerations.
- Enums are strongly typed constants. Hence, an explicit cast is needed to convert from enum type to an integral type and vice versa. Also, an enum of one type cannot be implicitly assigned to an enum of another type over through the underlying value of their members are the same.
- The default underlying type of an enum is int.
- The default value for first element is ZERO and gets incremented by 1.
- It is possible to customize the underlying type and values.
- Enums are value types.
- enum keyword (all small letters) is used to create enumeration, where as Enum class, contains static GetValues() and GetNames() methods which can be used to list Enum underlying type values and Names.

48. Part 48 C# Tutorial Difference between Types and Type Members

- In general classes, structs, enums, interfaces, delegates are called as types and fields, properties, constructors, methods etc. that normally reside in a type are called as type members.

- In C# there are 5 different access modifiers:
1. Private
2. Protected
3. Internal
4. Protected Internal
5. Public

- Type members can have all the access modifiers where as types can have only 2 (internal, public) of the 5 access modifiers.

- Note: Using regions you can expand and collapse sections of your code either manually, or using visual studio Edit -> Outlining -> Toggle All Outlining.

49. Part 49 C# Tutorial Access Modifiers in C#

- In C# there are 5 different access modifiers:
1. Private (Only with in the containing class)
2. Protected (With in the containing type and to the types that derive from conataining type)
3. Internal
4. Protected Internal
5. Public (Anywhere no restrictions)

- Private members are available only with in the containing type, where as public members are available anywhere. There is not restriction

- Protected Members are available, with in the containing type and to the types that derive from conataining type.

50. Part 50 C# Tutorial Internal and Protected Internal Access Modifiers in C#

- A member with internal access modifiers is available any where with in the containing assembly. It's a compile time error to access, an internal members from outside the containing assembly.

- Protected Internal members can be accessed by any code in the assembly in which it is declared or from within a derived class in another assembly. It is a combination of protected and internal. If you have understood protected and internal, this should be very easy to follow.

51. Part 51 C# Tutorial Access Modifiers for types

- types by default have internal access modifiers where as type members have private access modifiers.

52. Part 52 C# Tutorial Attributes in C#

- Attributes allow you to add declaration information to your programs. This information can then be queried at runtime using reflection.

- There are several Predefined Attributes provided by .NET. It is also possible to create your own Custom Attributes.

- A few predefined attributes withing the .NET framework:

Obsolete - Marks types and type members outdated
WebMethod - To expose a method as an XML Web service method.
Serializable - Indicates that a class can be serialized.

- It is possible to customize the attribute using parameters.

- An attribute is a class that inherits from System.Attribute base class.

53. Part 53 C# Tutorial Reflection in C#

- Reflection is the ability of inspecting an assemblies metadata at runtime. It is used to find all types in an assembly and/or dynamically invoke methods in an assembly.

- Uses of reflection:
1. When you drag and drop a button on an win forms or asp.net application. The properties window uses reflection to show all the properties of the Button class. So, reflection is extensively used by IDE or a UI designers.

2. Late binding can be achieved by using reflection. You can use reflection to dynamically create an instance of a type, about which we don't have any information at compile time. So, reflection enables you to use code that is not available at compile time.

3. Consider an example wehre we have two alternate implementations of an interface. You want to allow the user to pick one or the other using a config file. With reflection, you can simply read the name of the class whose implementation you want to use from the config file and instantiate an instance of that class. This is another example for late binding using reflection.

54. Part 54 C# Tutorial Reflection Example

55. Part 55 C# Tutorial Late binding using reflection

* Difference between early and late binding :
- Early binding can flag errors at compile time. With late binding there is a risk of run time exceptions.
- Early binding is much better for performance and should always be preferred over late binding. Use late binding oly when working with an objects that are not available at compile time.

Example of early binding :
Customer c1 = new Customer();
string fullName = c1.GetFullName("Pragim","Tech");
Console.WriteLine(fullName);

Example of late binding:
Assembly executingAssembly = Assembly.GetExecutingAssembly();
Type customerType = executingAssembly.GetType("Pragim.Customer");
object customerInstance = Activator.CreateInstance(customerType);
MethodInfo getFullName = customerType.GetMethod("GetFullName");
string[] methodParameters = new string[2];
methodParameters[0] = "Pragim";
methodParameters[1] = "Tech";
string fullName = (string)getFullName.Invoke(customerInstance, methodParameters);
Console.WriteLine(fullName);

56. Part 56 C# Tutorial Generics in C#

- Generics are introduced in C# 2.0. Generics allows us to design classes and methods decoupled from the data types. Generics makes your code type independent and that way you can reuse your code with any type.

- Generic classed are extensively used by collection classes available in System.Collection.Generic namespace.

Example: public static bool AreEqual(object v1, object v2){
return v1 == v2;
}

- Converting value type to reference type is called boxing.

- One way of making AreEqual() method reusable, is to used object type parameters. Since, every type in .NET directly or indirectly inherit from System.Object type, AreEqual() method works with any data type, but the problem is performance degradation due to boxing and unboxing happening.

- Also, AreEqual() method is no longer type safe. It is now possible to pass integer for the first parameter, and a string for the second parameters. It doesn't really make sense to compare strings with integers.

- So, the problem with using System.Object type is that
1. Are Equal() method is not type safe
2. Performance degradation due to boxing and unboxing.

Solution:
- To make AreEqual() method generic, we specify a type parameter using angular brackets as shown below.
E.g, public static bool AreEqual<T>(T v1,T v2)

- At the point, When the client code wants to invoke this method, they need to specify the type, they want the method to operate on. If the user wants the AreEqual() method to work with integers, they can invoke the method specifying int as the datatype using angular brackets as shown below.
E.g, bool Equal = Calculator.AreEqual<int>(2,1);

- To operate with string data type
bool Equal = Calculator.AreEqual<string>("A","B");

- In this example, we made the method generic. ALong the same lines, it is also possible to make classes, interfaces and delegates generic.

57. Part 57 C# Tutorial Why should you override ToString Method

- If we convert class instance to string what it will print.
Customer C1 = new Customer();
Console.WriteLine(C1.ToString());

O/P - Pragim.Customer (namespaceName.className)

To solve this, To give your complex types string representation remaining rather than using the default base class implementation which will give you the type full name (namespaceName.className).

Solution - 
public override string ToString();
{
	return this.LasName + ", " + this.FirstName;
} 

Customer c1 = new Customer();
c1.FirstName = "VVS";
c1.LastName = "TVS";

Console.WriteLine(c1.ToString());

O/P - TVS, VVS

Part 58 C# Tutorial Why should you override Equals Method

- If two reference variables pointing to the same object we have reference equality there and the same time values equality as well.

E.g. 
Customer c1 = new Customer()
Customer c2 = c1;

c1 == c2 //true
c1.Equal(c2) //true
c1.FirstName == c2.FirstName //true
c1.FirstName.Equals(c2.FirstName);

But,
Customer c1 = new Customer();
Customer c2 = new Customer();

c1 == c2 //false
c1.Equals(c2) //false

Solution:
Override Equals method.

Customer c1 = new Customer();
c1.FirstName = "A";
c1.LastName = "B";
Customer c2 = new Customer();
c2.FirstName = "A";
c2.LastName = "B";

Console.WriteLine(c1 == c2) //false
Console.WriteLine(c1.Equals(c2)) //true

public override bool Equals(object obj)
{
	if(obj == null)
	{
		return false;
	}
	
	if(!(obj is Customer))
	{
		return false;
	}
	
	return this.FirstName == ((Customer)obj).FirstName && this.LasName == ((Customer)obj).LasName;
}

public overridde int GetHashCode()
{
	return this.FirstName.GetHashCode() ^ this.LastName.GetHashCode();
}

// Also you will get warning saying override HashCode as well so we will do that as well

59. Part 59 C# Tutorial Difference between Convert ToString and ToString

- Convert.ToString() handles null, while ToString() doesn't and throws a NULL reference exception.

- Depending on the type of the application, architecture and what you are trying to achieve, you choose one over the other.

You cannot say one is better over the other on this depending on situation you can use one over the other.

60. Part 60 C# Tutorial Difference between String and StringBuilder

- System.String is immutable where as StringBuilder is Mutable.

- As StringBuilder objects are mutable, they offer better performance that string objects of type System.String, when heavy string manipulation is invoked.

Example:
string ex = "C# ";
ex += "video ";
Here it is creating separate object first "c#" then "c# video". where as stringbuilder are mutable it will discard previous object and keep it mutable.

So anytime when heavy string manipulation is there always use stringbuilder over string.

61. Part 61 Partial classes in c#

- Partial classed allow us to split a class into 2 or more files. All these parts are then combined into a single class, when the application is compiled. The partial keyword can also be used to split a struct or an interface over two or more files.

Advantages of partial classes
1. The main advantage is that, visual studio uses partial classes to separate, automatically generated system code from the developer's code. For ex, when you add a webform, two .cs files are generated.

a) WebForm1.aspx.cs - Contains the developer code
b) WebForm1.aspx.designer.cs - Contains the system generated code. For example, declarations for the controls that you drag and drop on the webform.

2. When working on large projects. spreading a class over separate files allows multiple programmers to work on it simultaneosly. Though, Microsoft claims this as an advantage, I haven't really seen anywhere, people using partial classes, just to work on them simultaneosly.


62. Part 62 Creating partial classes in c#
- All the parts spread across different files, must use the partial keyword.

- All the parts spread across different files must have the same access modifiers.

- If any of the parts are declared abstract, then the entire type is considered abstract.

- If any of the parts are declared sealed, then the entire type is considered sealed.

- If any of the parts inherit a class, then the entire type inherits that class.

- C# does not support multiple class inheritance. Different parts of the partial class, must not specify different base classes.

- Different parts of the partial class can specify different base interfaces, and the final type implements all of the interfaces listed by all of the partial declarations.

- Any members that declared in a partial defination are available to all of the other parts of the partial classes.


63. Part 63 Partial methods in c#

- A partial class or a struct can contain partial methods.
- A partial method is created using the partial keyword.
- A partial method declaration consists of two parts.
i)The defination (only the method signature)
ii)The implementation

These may be in separation parts of a partial class, or in the same part.

- The implementation for a partial method is optional. If we don't provide the implementation, the compiler removes the signature and all calls to the method.

- Partial methods are private by default, and it is a compile time error to include any access modifiers, including private.

- It is a compile time error, to include declaration and implementation at the same time for a partial method.

- A partial method return type must be void. Including any other return type is compile time error.

- Signature of the partial method declaration, must match with the signature of the implementation.

- A partial method must be declared within a partial class or partial struct. A non partial class or struct cannot include partial methods.

- A partial method can be implemented only once. Trying to implement a partial method more tahn once, raises a compile time error.

64. Part 64 - C# Tutorial - How and where are indexers used in .net

- To store or retrieve data from session state or application state variables, we use indexers.

- If you view the metadata of HttpSessionState class, you can see that there s an integral and string indexer defined. We use "this" keyword to create indexers in c#. We will discuss about creating indexers in our next video session.

- Indexers allow instances of a class to be indexed just like arrays.
E.g, Session["Login"] = "Username";

65. Part 65 - C# Tutorial - Indexers in c#

- Use "this" keyword to create an indexer.
- Just like properties indexers have get and set accessors.
- Indexers can also be overloaded.

Ex-
public string this[int id]
{
	get
	{
		return listEmployees.FirstOrDefault(x => x.Id == id).Name;
	}
	set
	{
		listEmployees.FirstOrDefault(x => x.Id == id).Name = value;
	}
}

Customer cust = new Customer();
Response.Write(cust[0]);

66. Part 66 - C# Tutorial - Overloading indexers in c#

- Indexers are overloaded based on the number and type of parameters.

67. Part 67 Optional parameters in c#

- There are 4 ways that can be used to make method parameters optional
1. Use parameter arrays (params)
2. Method overloading
3. Specify parameter defaults
4. Use OptionalAttribute that is present in System.Runtime.InteropServices namespace.

Note: A parameter array must be the last parameter in a formal parameter list.

Ex - 
public static void AddNumbers(int first, int second, params object[] rest){}

Here, rest is optional becasue we have used params keyword.

68. Part 68 Making method parameters optional using method overloading

Ex - 
public static void AddNumber(int first, int second) {}

public static void AddNumber(int first, int second, int[] rest) {}

69. Part 69 Making method parameters optional by specifying parameter defaults

Ex - 
public static void AddNumber(int first, int second, int[] rest = null) {}

- Optional parameters must appear after all required parameters.

* Named Parameters
- In the following method, parameters "b" & "c" are optional.

public static void Test(int a, int b = 10, int c = 20)
{}

- Test(1, 2);
When we invoke this method as shown below. "1" is passed as the argument for parameter "a" and "2" is passed as the argument for parameter "b" by default.

- Test(1, c: 2);
My intention is to pass "2" as the argument for parameter "c". To achieve this we can make use of named parameters, as shown below. Notice that, I have specified the name of the parameter for which value "2" is being passed.

70. Part 70 Making method parameters optional by using OptionalAttribute

Ex - 
using System.Runtime.InteropServices

public static void AddNumbers(int first, int second, [Optional] int[] rest)
{}

71. Part 71 Code snippets in visual studio

- Code snippets are ready-made snippets of code you can quickly insert into your code.
1. Keyboard shortcut: CTRL K + X
2. Right click and select "Insert Snippet.." from context menu
3. Click on Edit - Intellisense - Insert Snippet.
4. Use code snippets shortcut. For exampe to use "for loop" code snippet, type "for" and press TAB key twice.

- Once code snippet is inserted, the editable fields are highlighted in yello and the first editable field is selected automaticaly. Upon changing the first editable field, press TAB to move to the next editable field. To come to the previous editable field use SHIFT + TAB. Press ENTER or ESC keys to cancel field editing and return the Code Editor to normal.

Code Snippet Types:
Expansion: These snippets allows the code snippet to be inserted at the cursor.

SurrondsWith: These snippets allows the code snippet to be placed around a selected place of code.

Refactoring: These snippets are used during code refactoring.

- To access code snippet manager, click on "Tools" and then select "Code Snippet Manager". Code snippets are xml files and have .snippet extension.


72. Part 72 What is dictionary in c#

- A dictionary is a collection of (key, value) pairs.

- Dictionary class is present in System.Collection.Generic namespace.

- When creating a dictionary, we need to specify the types for key and value.

- Dictionary provides fast lookups for values using keys.

- Keys in the dictionary must be unique.

Ex - 
Dictionary<int, Customer> dcust = new Dictionary<int, Customer>();

Customer cust = new Customer() { ID = 101, Name = "Mark", Salary = 5000};

dcust.Add(cust.ID, cust);

Customer cust101 = dcust[101];
//cust101.Name

foreach(KeyValuePair<int, Customer> c1 in dcust)
{
	//c1.Key
	//Customer c = c1.Value;
}

73. Part 73 What is dictionary in c# continued

- TryGetValue()
If you are not sure if the dictionary contains a specific key that's when we use this function. It is going to return value that is associated with a key there.
Ex - 
Customer cust;
if(dCust.TryGetValue(101, out cust))
{
	//cust.Id, cust.Name
}

Main benefit of using TryGetValue is it will not give exception.

74. Part 74 List collection class in c#

- List is one of the generic collection classes present in System.Collections.Generic namespace. There are several generic collection classes in System.Collection.Generic namespace is listed below.
1. Dictionary
2. List
3. Stack
4. Queue etc.

- A List class can be used to create a collection of any type.
- For example, we can create a list of integers, Strings and even complex types.
- The object stored in the list can be accessed by index.
- Unlike arrays, lists can grow in size automatically.
- This class also provides methods to search, sort and manipulate lists.

75. Part 75 List collection class in c# continued

- Contains() function - Checks if an item exists in the list. This method returns true if the items exists, else false.

- Exists() - Checks if an item exists in the list based on a condition. This method returns true if the item exists, else false.

- Find() - Searches for an element that matches the conditions defined by the specified lambda expression and returns the first matching item from the list.

- FindLast() - Searches for an element that matches the conditions defined by the specified lambda expression and returns the Last matching item from the list.

- FindAll() - Returns all the items from the list that match the conditions specified by the lambda expression.

- FindIndex() - Returns the index of the first item, that matches the condition specified by the lambda expression. There are 2 other overloads of this method which allows us to specify the range of elements to search, within the list.

- FindLastIndex() - Returns the index of last item, that matches the conditon specified by the lambda expression. There are 2 other overloads of this method which allows us to specify the range of element to search, within the list.

76. Part 76 Working with generic list class and ranges in c#

- AddRange() - Add() method allows you to add one item at a time to the end of the list, where as AddRange() allows you to add another list of item, to the end of the list.

- GetRange() - Using an item index, we can retrieve only one item at a time from the list, if you want to et a list of items from the list, then use GetRange() function. This function expects 2 parameters, i.e, the start index in the list and the number of elements to return.

- InsertRange() - Insert() method allows you to insert a single item into the list at a specified index. where as InsertRange() allows you to insert another list of items to your list at the specified index.

- RemoveRange() - Remove() function removes only the first matching item from the list. RemoveAt() function, removes the item at the specified index in the list. RemoveAll() function removes all the items that matches the specified condition. RemoveRange() method removes a range of elements from the list. This function expects 2 parameters, i.e, the start index in the list and the number of elements to remove. If you want to remvoe all the elements from the list without specifying any conditions, then use Clear() function.

77. Part 77 Sort a list of simple types in c#

* How is the sort functionality working for simple types like int, string, char etc and not for complex type like Customer class ?
- That is because these types (int, string, decimal, char etc.) have implemented IComparable interface already.

78. Part 78 Sort a list of complex types in c#

- To sort a list of complex types without using LINQ, the complex type has to implement IComparable interface and provide implementation for CompareTo method. CompareTo() method returns an integer, and the meaning of the return value is shown below. RETURN VALUE is 

Greater than ZERO - The current instance is greater than the object being companred with.

Less than ZERO - The current instance is equal to the object being compared with.

Example - 
public class Customer : IComparable<Customer>
{
	public int ID {get; set;}
	
	public int CompareTo(Customer obj)
	{
		return this.Salary.CompareTo(obj.Salary);
	}
}

Alternatively you can also invoke CompareTo() method. Salary property of the Customer object is int. COmpareTo() method is already implemented on integer type, so we can invoke this method and return it's value.

- If you prefer not to use the Sort functionality provided by the class, then you can provide your own, by implementation IComparer interface. For ex. if I want the customers to sorted by name instead of salary.

Step 1: Implement IComparer interface
public class SortByName : IComparer<Customer>
{
	public int Compare(Customer x,Customer y)
	{
		return x.Name.CompareTo(y.Name);
	}
}

Step 2: Pass an instance of the class that implements IComparer interface, as an argument to the Sort() method.
SortByName sort = new SortByName();
cust.Sort(sort);

79. Part 79 Sort a list of complex types using Comparison delegate

- One of the overloads of the Sort() method in List class expects COmparison delegate to be passed as an argument.
public void Sort(Comparison<T> comparison);

80. Part 80 Some useful methods of List collection class

- TrueForAll() - Returns true or false depending on whether if every element in the list matches the condition defined by the specified predicate.

- AsReadOnly() - Returns a read only wrapper for the current collection. Use this method, if you don't want the client code to modify the collection i.e, add or reverse any elements from the collection. The ReadOnlyCollection will not have methods to add or remove items from the collection. You can only read items from this collection.

- TrimExcess() - sets the capacity to the actual number of elements in the List, if that number is less than a threshold value.

Acc to MSDN:
This method can be used to minimize a collections memory overhead if no new elements will be added to the collection. The cos t of reallocating and copying a large List<T>  can be considerable. So the TrimExcess method does nothing if the list is at more than 90 percent of capacity. This avoids incurring a large reallocation cost for a relatively small gain. The current threshold is 90 percent, but this could charge in the future.

81. Part 81 When to use a dictionary over list in c#

- Find() method of the List class loops through each object in the list until a match is found. So, if you want to lookup a value using a key dictionary is better for performance over list. So, use dictionary when you know the collection will be primarily used for lookups.

82. Part 82 Generic queue collection class

- Queue is a geenric FIFO (First in First Out) collection class that is present in System.Collections.Generic namespace. The Queue collection class is analogous to a queue at the ATM machine to withdraw money. The order in which people queue up, will be the order in which they will be able to get out of the queue and withdraw money from the ATM. The Queue collection class operates in a similar fashion. The first item to be added (enqueued) to the queue, will be the first time to be removed (dequeued) from the Queue.

- To add items to the end of the queue, use Enqueue() method.

- To remove an item that is present at the begining of the queue, use Dequeue() method.

- A foreach loop iterates through the time in the queue, but will not remove them from the queue.

- To check if an item, exists in the queue, use Contains() method.

- What is the difference between Deque and Peek methods ?
Dequeue() method removes and returns the item at the beginning of the queue, where as Peek() returns the item at the beginning of the queue, without removing it.

83. Part 83 Generic stack collection class

- Stack is generic LIFO (Last in First Out) collection class that is present in System.Collection.Generic namespace. The Stack collection class is analogous to a stack of plates. If you want to add a new plate to the stack of plates, you place it on top of all the already existing plates. If you want to remove a plate from the stack, you will first remove the one that you have last added. The stack collection class also operates in a similar fashion. The last item to be added (pushed) to the stack, will be the first item to be removed(popped) from the stack.

- To insert an item at the top of the stack, use Push() method.

- To remove and return the item that is present at the top of the stack, use Pop() method.

- A foreach loop iterates through the items in the stack, but will not remove them from the stack. The items from the stack are retrieved in LIFO (Last in First Out) order. The last element added to the stack is the first one to be returned.

- To check if an item exists in the stack, use Contains() method.

- What is difference between Pop() and Peek() methods ?
Pop() method removes and returns the item at the top of the stack, where as Peek() returns the item at the top of the stack without removing it.

84. Part 84 Real time example of queue collection class in c#

85. Part 85 Real time example of stack collection class in c#

86. Part 86 Multithreading in C#

* What is a Process:
Process is what the operating system uses to facilitate the execution of a program by providing the resources required. Each process has a unique process Id associated with it. You can view the process within which a program is being executed using windows task manager.

* What is Thread:
Thread is a light weight process. A process has at least one thread which is commonly called as main thread which actually executes the application code. A single process can have multiple threads.

Note: All the threading related classes are present in System.Threading namespace.

Ex - 
TimeConsumingMethod(){
}
Thread workerThread = new Thread(TimeConsumingMethod);
workerThread.Start();

87. Part 87 Advantages and disadvantages of multithreading

* Advantages of multithreading:
1. To maintain a responsive user interface
2. To make efficient use of processor time while waiting for I/O operations to complete.
3. To split large, CPU bound tasks to be processed simultaneosly on a machine that has multiple processors/cores.

* DisAdvantages of multithreading
1. On a single processor/core machine threading can affect performance negatively as there is overhead involved with context switching.
2. Have to write more lines of code to accomplish the same task.
3. Multithreaded applications are difficult to write, understand, debug and maintain.

Note: Only use multithreading when the advantages of doing so outweigh the disadvantages.

88. Part 88 ThreadStart delegate

- To create a THREAD, create an instance of Thread class and to it's constructor pass the name of the function that we want the thread to execute.

Ex - Thread T1 = new Thread(method);
T.Start();

We can rewrite the above line using ThreadStart delegate as shown below

Thread T1 = new Thread(new ThreadStart(method));
T1.Start();

* why a delegate need to be passed as parameter to the Thread class constructor ?
- The purpose of creating a Thread is to execute a function. A delegate is a type safe function pointer, meaning it points to a function that the thread has to execute. In short, all threads require an entry point to start execution. Any thread you create will need an explicitly defined entry point i.e, a pointer to the function where they should begin execution. So threads always require a delegate.

- In the code below, we are not explicitly creating the ThreadStart delegate, then how is it working here ?

Thread T1 = new Thread(method);
T.Start();

It's working in spite of not creating the ThreadStart delegate explicitly because the framework is doing it automatically for us.

- We can also rewrite the same line using delegate() keyword
Ex - 
Thread T1 = new Thread(delegate() { Number.PrintNumbers();});

- The same line rewritting using lambda expression.
Ex - 
Thread T1 = new Thread(() => Number.PrintNumbers());

- Thread function need not be a static function always. It can also be a non-static function. In case of non-static function we have to create an instance of the class.

89. Part 89 ParameterizedThreadStart delegate

- Use ParameterizedThreadStart delegate to pass data to thread function.

Ex - 
method(object target){
}

ParameterizedThreadStart p1 = new ParameterizedThreadStart(method);
Thread T1 = new Thread(p1);
T1.Start(object);

- The code in the Main() function can also be written as shown below.
Ex - 
object target = Console.ReadLine();
Thread T1 = new Thread(method);
T1.Start(target);

Here we are not explicitly creating an instance of ParameterizedThreadStart delegate. Then how is it working ?
It's working because, the compiler implicitly converts

new Thread(method);
To
new Thread(new ParameterizedThreadStart(method));

* When to use ParameterizedThreadStart over ThreadStart delegate ?
- Use ParameterizedThreadStart delegate if you have some data to pass to the Thread function, other wise jsut use ThreadStart delegate.

* Note: Using ParameterizedThreadStart delegate and Thread.Start(Object) method to pass data to the Thread function is not type safe as they operate on object datatype and any type of data can be passed.

If you try to change the data type of the target parameter of PrintNumbers() function from object to int, a compiler error will be raised as the signature of PrintNumber() function does not match with the signature of ParameterizedThreadStart delegate.

90. Part 90 Passing data to the Thread function in a type safe manner

- To pass data to the Thread function in a type safe manner, encapsulate the thread function and the data it needs in a helper class and use the ThreadStart delegate to execute the thread function.

Ex - 
class Number
{
	int _target;
	public Number(int target)
	{
		this._target = target;
	}
	
	public void Print()
	{
		//_target use
	}
}

int target = C.ToInt32(C.R());

Number n = new Number(target);
Thread t1 = new Thread(new ThreadStart(n.Print));
t1.Start();

91. Part 91 Retrieving data from Thread function using callback method

