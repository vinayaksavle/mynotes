C# Notes from Kudvenkat

1. Part 1 - C# Tutorial - Introduction.avi

* Using System declaration
- A namespace is used to organise your code and is collection of classes, interfaces, structs, enums and delegates.

- Main method is the entry point into your application.

2. Part 2 - C# Tutorial - Reading and writing to a console.avi

- C# is case sensitive.
- Console.ReadLine return type is string.

- Two ways to write to console
a. Concatenation 
Ex- Console.WriteLine("Hello "+username);

b. Place Holder syntax
Ex- Console.WriteLine("Hello {0}",username);

3. Part 3 - C# Tutorial - Built - in types.avi

sbyte (signed 8 bit) - (-128 to 127) 
byte (Unsigned 8 bit integer) - (0 to 255) 

- To find range of any data type.
Console.WriteLine(int.MinValue+" to "+int.MaxValue);

To store decimal you cannot use int data type. Use below data types for better precision.
- float - Precision - 7 digits
- double - Precision - 15 to 16 digits.
- decimal - Precision - 28 to 29 significant digits

4. Part 4 - C# Tutorial - String type in c#.avi

* Escape Sequence - 
\" - double quote
\a - Bell (alert)
\b - Backspace
\n - New line
\\ - Backslash

Ex - 
string s = "\"VVS\"";	\\"VVS"

* Verbatim Literal - It makes escape sequence translate as normal printable characters to enhance readability. If want to treat escape sequence as normal string use @ before string. Mainly used for file path.

Ex - string s = @""VVS""; \\"VVS"

5. Part 5 - C# Tutorial - Common Operators in c#.avi

Assignment Operator =
Arithmetic Operators like +,-,*,/,% 
Conditional Operators like &&, ||
Ternary Operator ?:
Null Coalescing Operator ?? 

6. Part 6 - C# Tutorial - Nullable Types.avi

* Types in C#
a. Value Types - int, float, double, structs, enums etc.
b. Reference Types - interface, class, delegates, arrays etc.

- By default value types are non nullable. To make them nullable use "?" and by default  reference types are null.

- int i = 0 (i is non nullable, so I cannot be set to null, i = null will generate compile error)

- int? j = 0 (j is nullable int, so j=null is legal)

- Nullable types bridge the differences between C# types and Database types. Take one example like suppose in form field we have one input field which is not compulsory for user to enter details. At that time you to store null data in DB so for that purpose this Nullable types are used to differenciate between User not answering the question and saying No or Yes. Also in DB there is nothing concept like value and reference type. You can store null data in any datatype (int, nvarchar etc.).

* Null Coalescing Operator
Ex - 
int? TicketsOnSale = 100;
int AvailableTickets = TicketsOnSale ?? 0;

If TicketsOnSale is null then use 0 else use TicketsOnSale value.

7. Part 7 C# Tutorial Datatypes conversion

* Implicit & Explicit conversion
- Implicit conversion is done by the compiler:
a. When there is no loss of information if the conversion is done.
b. If there is not possibility of throwing exceptons during the conversion.

Example - Converting an int to a float will not loose any data and no exception will be thrown, hence an implicit conversion can be done.

Where as when converting a float to an in, we loose the fractional part and also a possibility of overflowing exception. Hence, in this case an explicit conversion is required. For explicit conversion we can use cast operator or the convert class in c#.

- With using type cast operator we don't get exception if value is overflowing but with using Convert we get exception.
Ex - 
float f = 123456789.45F;
int i = (int)f; //int.MinValue -23....
int j = Convert.ToInt32(f); //System.Overflow exception


* Difference between Parse and TryParse
- If the number is in a string format you have 2 options - Parse() and TryParse().
- Parse() method throws an exception if it cannot parse the value, whereas TryParse returns a bool indicating whether it succeeded or failed.
- Use Parse() if you are sure the value will be valid, otherwise use TryParse().

8. Part 8 - C# Tutorial - Arrays in C#.avi

- An array is a collection of similar data types.

Advatages: Arrays are strongly typed.

DisAdvantages: Arrays cannot grow in size once initialized. Have to rely on integral indices to store or retrive items from the array. At runtime you get IndexOutOfRangeException if array size using more than declared.

10. Part 10 - C# Tutorial - If statement in C#

Difference between && and &, || and |
- && or || checks only first condition if it is true it will not go to second condition whereas & or | will check even if first one is true. So && and || are performance benefit.

11. Part 11 - C# Tutorial - switch statement in C#

Important interview question
Ex - 
switch(Number)
{
	case 10:
	case 20:
	case 30:
			Console.WriteLine("Number is {0}", Number);
			break;
	default:
			Console.WriteLine("No");
			break;
}

O/P - 
20
Number is 20

Because, Case statements, with no code in between, creates a single case for multiple values. A case without any code will automatically fall through to the next case. In this example, case 10 and case 20 will fall through and execute code for case 30.

- break statement: If break statement is used inside a switch statement, the control will leave the switch statement.

- goto statement: You can either jump to another case statement, or to a specific label.
Warning: Using goto is bad programming style. We should avoid goto all means.

14. Part 14 - C# Tutorial - do while loop in c#

- A do loop checks its condition at the end of the loop.
- This means that the do loop is guarantted to execute at least one time.
- Do loops are used to present a menu to the user.

15. Part 15 - C# Tutorial - for and foreach loops in c#.avi

- A foreach loop is used to iterate throgh the items in a collection. For example, foreach loop can be used with arrays or collections such as ArrayList, HashTable and Generics.

16. Part 16 - C# Tutorial - Methods in c#.avi

- Methods are extremely useful because they allow you to define your logic once, and use it, at many pieces.

- Methods make the maintenance of your application easier.

* Static vs Instance methods

- When a method declaration includes a static modifier, that method is said to be a static method. When no static modifier is present, the method is said to be an instance method.

- Static method is involved using the class name, where as an instance method is involved using an instance of the class.

- The difference between instance methods and static methods is that multiple instances of a class can be created (or instantiated) and each instance has its own seperate method. However when a method is static, there are no isntance of that method, and you can involve only that one defination of the static method. 

17. Part 17 - C# Tutorial - Method parameters.avi

* Method parameter types

a. Value Parameters: Creayes a copy of the parameter passed, so modification does not affect each other.

b. Reference Parameters: The ref method parameter keyword on a method parameter causes a method to refer to the same variable that was passed into the method. Any changes made to the parameter in the method will be relected in that variable when control passes back to the calling method.

c. Out Parameters: Use when you want a method to return more than one value.

d. Parameter Arrays: The params keyword lets you specify a method parameter that takes a variable number of arguments. You can send a comma-separated list of arguments, or an array, or no arguments. Params keyword should be the last one in a method declaration, and only one params keyword is permitted in an method declaration.

- The parameters which are passed in method declaration are know as Method parameters and the one passed while invoking are known as arguments.

18. Part 18 - C# Tutorial - Namespaces.avi

- Namespaces are used to oraganize your programs. They also provide assistance in avoiding name clashes.

- Namespaces don't correspond to file, directory or assembly names. They could be written in separate files and/or separate assemblies and still belong to the same namespace.

- Namespaces can be nested in 2 ways. Namespace alias directives. Sometimes you may encounter a long namespace and wish to have it shorter. This could improve readability and still avoid name clashes with similarly named methods.

- To avoid ambiguity between namespace names can use alias
using PTA = ProjectA.TeamA;

19. Part 19 - C# Tutorial - Introduction to classes.avi

* What is a class ?
- If you want to create complex custom types, then we can make use of classes. A class consists of data and behavior. Class data is represented by its field and behavior is represented by its methods.

* Purpose of a class constructor
- The purpose of a class constructor is to initialize class fields. A class constructor is automatically called when an instance of a class is created.

- Constructors do not have return values and always have the same name as the class.

- Constructors are not mandatory. If we do not provide a constructor, a default parameter less constructor is automatically provided.

- Constructors can be overloaded by the number and type of parameters.

* Destructors

- Destructors have the same name as the class with ~ symbol in front of them.

- They don't take any parameters and do not return a value.

- Destructors are places where you could put code to release any resources your class was holding during its lifetime. They are normally called when the c# garbage collector decides to clean your object from memory.


20. Part 20 - C# Tutorial - Static and instance class members.avi

* Static and Instance class members

- When a class member includes a static modifier, the member is called as static member. When no static modifier is present the member is called as non static member or instance member.

- Static members are invoked using class name, where as instance members are invoked using instances (objects) of the class.

- An instance member belongs to specific instance(object) of a class. If I create 3 objects of a class, I will have 3 sets of instance members in the memory, where as there will ever be only one copy of a static member, no matter how many instances of a class are created.

Note: Class members = fields, methods, properties, events indexers, constructors.

* Static constructor

- Static constructors are used to initialize static fields in a class.

- You declare a static constructor by using the keyword static in front of the constructor name. Because, it just need to initialize static field once it will be shared by all the objects you create. Where as instance constructor is called every time you create instance of class. 

- Static constructor is called only once, no matter how many instances you create. Static construuctors are called before instance constructors.


21. Part 21 - C# Tutorial - Inheritance in c#.avi

* Why Inheritance

Pillars of Object Oriented Programming
1. Inheritance
2. Encapsulation
3. Abstraction
4. Polymorphism

- Inheritance is one of the primary pillars of object oriented programming.
- It allows code reuse.
- Code reuse can reduce time and errors.

* Note: You will specify the common fields, properties, methods in the base class, which allows reusability. In the derived class you will only have fields, properties and methods, that are specific to them.

- Syntax:
public class ParentClass 
{
	// Parent Class implementation
}

public class DerivedClass : ParentClass
{
	// Child Class implementation
}

- In above example derived class inherits from ParentClass.
- C# supports only single class inheritance so multiple class inheritance is not supported but multi - level inheritance is supported.
- C# supports multiple interface inheritance.
- Child class is a specialization of base class.
- Base classe are automatically instantiated before derived classes.
- Parent Class constructor executes before Child Class constructor.

22. Part 22 - C# Tutorial - Method hiding in c#.avi

- Use the new keyword to hide a base class member. You will get a compiler warning. If you miss the new keyword.

- Different ways to invoke a hidden base (Parent) class member from derived class 
1. Use base keyword
2. Cast child type to parent type and invoke the hidden member
3.  A parent class reference varibale can point to child class Object. But vice versa not possible.

ParentClass PC = new ChildClass();
   PC.HiddenMethod();

1) Use new keyword when hiding base class's method in child class.
2) Can call base class's method in child class using base keyword. (base.ParentClassMethod)
Or
Cast it to Parent type:
((BaseClass) ChildClassObject). BaseClassMethod
Or
BaseClass baseClassObj = New ChildClass childclassobj
baseClassObj.baseClassMethodname

Note: ChildClass childclassObj =New BaseClass Obj (WRONG!!!)

23. Part 23 - C# Tutorial - Polymorphism in c#.avi

- Polymorphism basically enables you to invoke derived class methods through base class reference variable at runtime thats nothing but polymorphism by using override keyword in Child/Derived class and virtual in Parent/Base class. In base class the method is declared virtual and in the derived class we override the same method.

- The virtual keyword indicates the method can be overridden in any derived class. If you don't override in derived class it will invoke base class method.

- I think this is simplier way to explain polymorphism:

Employee FTE = new FullTimeEmployee();
FTE.PrintFullName();

Employee E = new Employee();
E.PrintFullName();

BaseClass bObj = New ChildClass()
bObj.commonMethodName

1> If Base method 'virtual'(Or 'override' in case on multi level inheritance) and child method 'override' -> child method executes
2> If Base method is not 'virtual'(Or 'override' in case on multi level inheritance) and child method 'new'(optional, vs prompt) -> base method executes (Also called method hiding)

- As in run time if you choose the reference of base class and the object with new keyword is of child .... and the method u declared in the base class is virtual or abstract , and u have derived it in child class... now the instance u are generating is of type child but the reference is of parent ... so compiler is gonna look parent for the method u defined and then in child the particular method u have defined... it' not easy for compiler for to do so ...so what happens is that at run time which function is to be chosen is decided when the object is passed... this is run time polymorphism

24. Part 24 - C# Tutorial - Difference between method overriding and method hiding.avi

* Method Overriding

public class BaseClass
{
	public virtual void Print()
	{
		Console.WriteLine("Base Class Print Method");
	}
}

public class DerivedClass : BaseClass
{
	public override void Print()
	{
		Console.WriteLine("Child Class Print Method");
	}
}

public class Program
{
	public static void Main()
	{
		BaseClass B = new DerivedClass();
		B.Print();
	}
}

O/P - 
Child Class Print Method

- In method overriding a base class reference variable pointing to a child class object, will invoke the overridden method in the Child class.

* Method Hiding
public class BaseClass
{
	public virtual void Print()
	{
		Console.WriteLine("Base Class Print Method");
	}
}

public class DerivedClass : BaseClass
{
	public new void Print()
	{
		Console.WriteLine("Child Class Print Method");
	}
}

public class Program
{
	public static void Main()
	{
		BaseClass B = new DerivedClass();
		B.Print();
	}
}

O/P - 
Base Class Print Method

- In method hiding a base class reference variable pointing to a child class object, will invoke the hidden method in the Base class.

25. Part 25 - C# Tutorial - Method overloading in c#.avi

- Function overloading and Method overloading terms are used interchangeably.

- Method overloading allows a class to have multiple methods with the same name but, with a different signature. So, in C# functions can be overloaded based on the number, type (int, float etc.) and kind (Value, Ref or Out) of parmaeters.

- The signature of a method consists of the name of the method and the type, kind (Value, Ref or Out) and number of its formal parameters. The signature of a method does not include return type and the params modifier. So, it is not possible to overload a function, just based on the return type or params modifier.

26. Part 26 - C# Tutorial - Why Properties.avi

- Marking the class fields public and exposing to the external world is bad, as you will not have control over what gets assigned and returned. Suppose if you want id to be non-negative and if you kept id as public it is bad so by using properties getter setter methods we can handle that.

- Programming languages that does not have properties use getter and setter methods to encapsulate and protect fields.

27. Part 27 - C# Tutorial - Properties in C#.avi

- In C# to encapsulate and protect fields we use properties.
- We use get and set accessors to implement properties.
- A property with both get and set accessor is a Read/write property.
- A property with only get accessor is a Read only property.
- A property with only set accessor is a Write only property.

Note: The advantage of properties over traditional Get() and Set() methods is that, you can access them as if they were public fields.

- Example:

public class Student 
{
	private int _id;
	public int Id
	{
		set
		{
			if(value <= 0)
			{
				throw new Exception("Student Id cannot be negative");
			}
			this._id = value
		}
		get
		{
			return this._id;
		}
	}
}

Student s = new Student();
s.Id = 101; //set
Console.WriteLine(s.Id); //get

* Auto Implemented Properties

- If there is no additional logic in the property accessors, then we can make use of auto implemented properties introduced in C# 3.0

- Auto implemented properties reduce the amount of code that we have to write.

- When you use auto-implemented properties, the compiler creates a private, anonymous field that can only be accessed through the properties get and set accessors.

Example:

private string _email;
public string Email
{
	get
	{
		return this._email;
	}
	set
	{
		this._email = value;
	}
}

In auto implementation Will be written as,

public string Email { get; set; }

- Compiler will create a backing private fields.

28. Part 28 - C# Tutorial - Structs in C#.avi

- Just like classes structs can have
1. Private Fields
2. Public Properties
3. Constructors
4. Methods

- Object initializer syntax, introduced in C# 3.0 can be used to initialize either a struct or a class.

Example:
Previously,
Customer c1 = new Customer();
c1.Id = 101;
c1.Print();

Object initializer syntax,
Customer c2 = new Customer
{
	Id = 102,
	Name = "VVS"
};
c2.Print();

29. Part 29 - C# Tutorial - Difference between classes and structs in c#.avi

* Classes Vs Structs
- A struct is a value type where as a class is a reference type.
- All the differences that are applicable to value types and reference types are also applicable to class and structs.
- Structs are stored on stack, where as classes are stores on the heap.
- Value types hold their value in memory where they are declared, but reference types hold a reference to an object in memory.
- Value types are destroyed immediately after the scope is lost, where as for reference types only the reference variable is destroyed after the scope is lost. The object is later destroyed by garbage collector. 
- When you copy a struct into another struct, a new copy of that struct gets created and modifications on one struct will not affect the values contained by the other struct.
- When you copy a class into another class we only get a copy of the reference variable. Both the reference variables point to the same object on the heap. So operations on one variable will affect the values conatined by the other reference variables.
- Structs can't have destructors, but classes can have destructors.
- Structs cannot have explicit parameter less constructor where as class can.
- Struct can't inherit from another class where as a class can. Both structs and classes can inherit from an interface.
-  A class or struct cannot inherit from another struct. Struct are sealed types.
If class is sealed it cannot act as a base/parent class.

Ex - 
1. int is a struct which is alias of struct System.Int32 also double System.Double etc.
2. Customer c1 = new Customer();
c1.Id = 101;
c1.Name = "VVS";

Here, c1 is object reference variable which is stored on Stack. and Id, Name are actual customer object which is stored on Heap.


30. Part 30 - C# Tutorial - Interfaces in c#.avi

- We create interfaces using interface keyword. Just like classes, interfaces also contains properties, methods, delegates or events but only declaration and no implementations.

- It is a compile time error to provide implementation for any interface member.

- Interface members are public by default, and they don't allow explicit access modifiers.

- Interfaces cannot contain fields.
- If a class or a struct inherits from an interface, it must provide implementation for all interface members. Otherwise we get a compiler error.

- A class or a struct can inherit from more than one interface at the same time, but where as, a class cannot inherit from more than one class at the same time.

- Interfaces can inherit from other interfaces. A class that inherits this interface must provide implementation for all interface members in the entire interface inheritance chain.

- We cannot create an instance of an interface, but an interface reference variable can point to a derived class object.

Ex - 
public class Customer : ICustomer 
{
	public void Print() {}
}

ICustomer c1 = new Customer();
c1.Print();

31. Part 31 - C# Tutorial - Explicit interfaces implementation.avi

* Q. A class inherits from 2 interfaces and both the interfaces have the same method name. How sould the class implement the method for both the interfaces ?

Ex-
interface I1
{
	void IMethod();
}
interface I2
{
	void IMethod();
}

class Program : I1,I2
{
	static void Main()
	{
		Program p = new Program();
		((I1)P).IMethod();
		((I2)P).IMethod();
		
		or 
		I1 i1 = new Program();
		I1 i2 = new Program();
		i1.IMethod();
		i2.IMethod();
	}
	void I1.IMethod()
	{
		Console.WriteLine("I1");
	}
	void I2.IMethod()
	{
		Console.WriteLine("I2");
	}
}

We are using Explicit interface implementation techinique to solve this problem.

Note: WHen a class explicitly implements and interface member,  the interface member can no longer be accessed through class reference variable, but only through the interface reference variable.

Access modifiers are not allowed on explicit implemented interface members.

- If you want to make one of the interface method, the default, then implement that method normally and the other interface method explicitly. This makes the default method to be accessible through class instance.

32. Part 32 - C# Tutorial - Abstract classes in c#.avi

- The abstract keyword is used to create abstract classes.
- An abstract class is incomplete and hence cannot be instantiated.
- An abstract class can only be used as base class.
- An abstract class cannot be sealed.
- An abstract class may contain abstract members (methods, properties, indexers and events) but not mandatory.
- A non-abstarct class derived from an abstract class must provide implementations for all inherited abstract members.

- If a class inherits an abstract class, there are 2 options available for that class.
Option 1: Provide implementation for all the abstract members inherited from the base abstract class.
Option 2: If the class does not wish to provide implementation for all the abstract members inherited from the abstract class, then class has to be marked as abstract.

33. Part 33 - C# Tutorial - Difference between abstract classes and interfaces.avi

- Abstract classes can have implementation for some of its members (Methods), but the interface can't have implementation for any of its members.

- Interfaces cannot have fields where as an abstract class can have fields.

- An interface can inherit from another interface only and cannot inherit from an abstarct class, where as an abstract class can inherit from another abstract class or another interface.

- A class can inherit from multiple interfaces at the same time, where as a class cannot inherit from multiple classes at the same time.

- Abstract class members can have access modifiers where as interface members cannot have access modifiers.

34. Part 34 - C# Tutorial - Problems of multiple class inheritance.avi

* Diamond Problem

Example:
class A
{
	public virtual void Print()
	{
		Console.WriteLine("Class A");
	}
}

class B : A
{
	public override void Print()
	{
		Console.WriteLine("Class B");
	}
}

class C : A
{
	public override void Print()
	{
		Console.WriteLine("Class C");
	}
}
class D : B, C
{

}

class Program
{
	public static void Main()
	{
		D d = new D();
		d.Print();
	}
}

- Class B and Class C inherit from Class A.
- Class D inherits from both B and C.
- If a method in D calls a method defined in A (and does not override the method), and B and C have overridden that method differently, then from which class does it inherit B or C ?

This ambiguity is called as Diamond Problem.

35. Part 35 - C# Tutorial - Multiple class inheritance using interfaces.avi

