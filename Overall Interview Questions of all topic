Interview questions to be revised:

* OOP'S C#

- Encapsulation : Encapsulation is a process of binding the data members and member functions into a single unit. In c#, the class is the real-time example for encapsulation because it will combine various types of data members and member functions into a single unit. If we define class fields with properties, then the encapsulated class won’t allow us to access the fields directly. Instead, we need to use getter and setter functions to read or write data based on our requirements. You can make a property read-only or write-only by making it's accessor private. You can't do that with a field. Properties can also be virtual, while fields cannot.

* Property is an extension of the class variable. It provides a mechanism to read, write, or change the class variable's value without affecting the external way of accessing it in our applications. Generally, in object-oriented programming languages like c# you need to define fields as private and then use properties to access their values in a public way with get and set accessors. In c#, properties will enable class variables to expose in a public way using get and set accessors by hiding implementation details. Generally, in c# the encapsulation is used to prevent alteration of code (data) accidentally from the outside functions. In c#, by defining the class fields with properties, we can protect the data from accidental corruption. If we define class fields with properties, then the encapsulated class won’t allow us to access the fields directly. Instead, we need to use getter and setter functions to read or write data based on our requirements.

Ex - 
class User
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}

- Abstraction : Abstraction is used to hide the implementation details and display only essential features of the object. In Abstraction, by using access modifiers, we can hide the required details of the object and expose only necessary methods and properties through an object's reference. A class is the perfect example of abstraction. In c#, we can create a class with required methods, properties and we can expose only necessary methods and properties using access modifiers based on our requirements.

* Access Modifiers:
public	It is used to specifies that access is not restricted.

private	It is used to specifies that access is limited to the containing type.

protected	It is used to specifies that access is limited to the containing type or types derived from the containing class.
Ex -
class User
    {
        protected string Name;
        protected void GetUserDetails()
        {
           Console.WriteLine("Name: {0}", Name);
        }
    }
    class Program: User
    {
        static void Main(string[] args)
        {
           User u = new User();
           Program p = new Program();
           // Complier Error
           // protected members can only accessible with derived classes
           //u.Name = "Suresh Dasari";
           p.Name = "Suresh Dasari";
           
           p.GetUserDetails();
           Console.WriteLine("\nPress Enter Key to Exit..");
           Console.ReadLine();
        }
    }
	
If you observe the above example, we are accessing base class (User) protected members using the reference of the derived class (Program). If we uncomment the commented code, we will get a compile-time error because we are trying to access protected members with base class (User) reference instead of the derived class (Program).

internal -	It is used to specifies that access is limited to the current assembly.

protected internal -	It specifies that access is limited to the current assembly or types derived from the containing class.

private protected -	It is used to specifies that access is limited to the containing class or types derived from the containing class within the current assembly.

sealed - Class can't be inherited by a derived class. structs are implicitly sealed; they cannot be inherited. the local variables cannot be sealed.
static - Class contains only static members.
unsafe - The class that has some unsafe construct likes pointers.
Abstract - The instance of the class is not created if the Class is abstract.

* Inheritance : Inheritance is used to inherit the properties from one class (base) to another (child) class. The class whose members are inherited is called a base (parent) class, and the class that inherits the members of the base (parent) class is called a derived (child) class. In c#, it’s not possible to inherit the base class constructors in the derived class. The accessibility of other base class members also depends on the access modifiers that we used to define those members in a base class. Generally, c# supports only single inheritance that means a class can only inherit from one base class. However, in c# the inheritance is transitive, and it allows you to define a hierarchical inheritance for a set of types, and it is called a multi-level inheritance.

Ex. of Multi-Level Inheritance - 
public class A
{
// Implementation
}
public class B: A
{
// Implementation
}
public class C: B
{
// Implementation
}

If you observe the above code snippet, class C is derived from class B, and class B is derived from class A, then class C inherits the members declared in both class B and class A. This is how we can implement multi-level inheritance in our applications. As discussed, multi-level inheritance is supported in c#, but multiple inheritance is not supported. If you want to implement multiple inheritance in c#, we can achieve this by using interfaces.

* Method Overloading : Method Overloading means defining multiple methods with the same name but with different parameters. Method Overloading is also called compile time polymorphism or early binding.
Ex -
using System;

namespace Tutlane
{
    public class Calculate
    {
        public void AddNumbers(int a, int b)
        {
           Console.WriteLine("a + b = {0}", a + b);
        }
        public void AddNumbers(int a, int b, int c)
        {
           Console.WriteLine("a + b + c = {0}", a + b + c);
        }
    }
    class Program
    {
       static void Main(string[] args)
       {
          Calculate c = new Calculate();
          c.AddNumbers(1, 2);
          c.AddNumbers(1, 2, 3);
          Console.WriteLine("\nPress Enter Key to Exit..");
          Console.ReadLine();
       }
    }
}

* Method Overriding : Method Overriding means override a base class method in the derived class by creating a method with the same name and signatures to perform a different task. The Method Overriding in c# can be achieved using override & virtual keywords and the inheritance principle. The base class method we want to override in the derived class needs to be defined with a virtual keyword. We need to use the override keyword in the derived class while defining the method with the same name and parameters then only we can override the base class method in a derived class. Method Overriding is also called run time polymorphism or late binding.

Ex. -
using System;

namespace Tutlane
{
    // Base Class
    public class BClass
    {
       public virtual void GetInfo()
       {
          Console.WriteLine("Learn C# Tutorial");
       }
    }
    // Derived Class
    public class DClass : BClass
    {
       public override void GetInfo()
       {
          Console.WriteLine("Welcome to Tutlane");
       }
    }
    class Program
    {
       static void Main(string[] args)
       {
          DClass d = new DClass();
          d.GetInfo();
          BClass b = new BClass();
          b.GetInfo();
          Console.WriteLine("\nPress Enter Key to Exit..");
          Console.ReadLine();
       }
    }
}

O/P - 
Welcome to Tutlane
Learn C# Tutorial

* Shadowing (method hiding)
A method or function of the base class is available to the child (derived) class without the use of the "overriding" keyword. The compiler hides the function or method of the base class. This concept is known as shadowing or method hiding. In the shadowing or method hiding, the child (derived) class has its own version of the function, the same function is also available in the base class.
Ex -
public class BaseClass  
{  
    public string GetMethodOwnerName()  
    {  
       return "Base Class";  
    }  
}  
public class ChildClass : BaseClass  
{  
    public new string GetMethodOwnerName()  
    {  
       return "ChildClass";  
    }  
} 

static void Main(string[] args)  
{  
    ChildClass c = new ChildClass();  
    Console.WriteLine(c.GetMethodOwnerName());  
} 

O/P -
ChildClass

If we do not use the new keyword the compiler generates the warning: Use the new keyword if hiding is intended.

Ex - If we use new and instantiate with BaseClass then it will give BaseClass O/P.
using System;

public class Program
{
	public static void Main()
	{
		BaseClass c = new ChildClass();
		Console.WriteLine(c.GetMethodOwnerName());
	}

	public class BaseClass
	{
		public virtual string GetMethodOwnerName()
		{
			return "Base Class";
		}
	}

	public class ChildClass : BaseClass
	{
		public new string GetMethodOwnerName()
		{
			return "ChildClass";
		}
	}
}
O/P - Base Class

Ex - If we use override keyword using BaseClass instance then ChildClass will get called.
using System;

public class Program
{
	public static void Main()
	{
		BaseClass c = new ChildClass();
		Console.WriteLine(c.GetMethodOwnerName());
	}

	public class BaseClass
	{
		public virtual string GetMethodOwnerName()
		{
			return "Base Class";
		}
	}

	public class ChildClass : BaseClass
	{
		public override string GetMethodOwnerName()
		{
			return "ChildClass";
		}
	}
}

O/P -ChildClass


- Virtual: In c#, the virtual keyword is useful to override base class members such as properties, methods, etc., in the derived class to modify it based on our requirements. Generally, whenever the virtual method is invoked, the run-time object will check for an overriding member in the derived class. If no derived class has overridden the member, then the virtual method will be treated as an original member. In c#, by default all the methods are non-virtual, and we cannot override non-virtual methods. If you want to override a method, you need to define it with the virtual keyword. The virtual keyword in c# cannot be used with static, abstract, private, or override modifiers. In c#, the virtual inherited properties can be overridden in a derived class by including a property declaration that uses the override modifier.

- Override: In c#, the override keyword is used to override a base class virtual members such as properties, methods, etc., in the derived class to modify it based on our requirements. 

- Base: In c#, the base keyword is useful to access base class members such as properties, methods, etc., in the derived class. We can call a base class constructor from the derived class using the base keyword. 
Ex -
using System;

namespace Tutlane
{
    // Base Class
    public class BClass
    {
       public BClass()
       {
          Console.WriteLine("Welcome to Tutlane");
       }
       public BClass(string a, string b)
       {
          Console.WriteLine("Name: {0}", a);
          Console.WriteLine("Location: {0}", b);
       }
    }
    // Derived Class
    public class DClass : BClass
    {
        // This constructor will call default constructor
        public DClass(): base()
        {
        }

       // This constructor will call parameterized constructor
       public DClass(string x, string y): base(x, y)
       {
       }
    }
    class Program
    {
        static void Main(string[] args)
        {
           DClass d = new DClass();
           DClass d1 = new DClass("Suresh Dasari", "Hyderabad");
           Console.WriteLine("\nPress Enter Key to Exit..");
           Console.ReadLine();
        }
    }
}

O/P -
Welcome to Tutlane
Name Suresh Dasari
Location Hyderabad

* Polymorphism : Polymorphism means providing an ability to take more than one form.
1. Compile Time Polymorphism
Compile Time Polymorphism means defining multiple methods with the same name but with different parameters. The compile-time polymorphism can be achieved by using method overloading, and it is also called early binding or static binding. It is also known as Compile Time Polymorphism because the decision of which method is to be called is made at compile time.


2. Run Time Polymorphism 
Run Time Polymorphism means overriding a base class method in the derived class by creating a similar function. This can be achieved by using override & virtual keywords and the inheritance principle. Using run-time polymorphism, we can override a base class method in the derived class by creating a method with the same name and parameters to perform a different task. The run time polymorphism can be achieved by using method overriding, and it is also called late binding or dynamic binding. The compiler would not be aware of the method available for overriding the functionality, so the compiler does not throw an error at compile time. The compiler will decide which method to call at runtime and if no method is found then it throws an error.

- Partial classes - Typically, a class will reside entirely in a single file. However, in situations where multiple developers need access to the same class, then having the class in multiple files can be beneficial. The partial keywords allow a class to span multiple source files. When compiled, the elements of the partial types are combined into a single assembly. If the partial type is sealed or abstract then the entire class will be sealed and abstract.
Ex -
using System;

namespace oops
{
    public partial class partialclassDemo
    {
        public void method1()
        {
            Console.WriteLine("method from part1 class");
        }
    }
}

using System;

namespace oops
{
    public partial class partialclassDemo
    {
        public void method2()
        {
            Console.WriteLine("method from part2 class");
        }
    }
}

using System;

namespace oops
{
    class Program
    {
        static void Main(string[] args)
        {
            //partial class instance
            partialclassDemo obj = new partialclassDemo();
            obj.method1();
            obj.method2();
        }
    }
}

- Static classes
A static class is declared using the "static" keyword. If the class is declared as static then the compiler never creates an instance of the class. All the member fields, properties and functions must be declared as static and they are accessed by the class name directly not by a class instance object.
Ex -
using System;

namespace oops
{
    static class staticDemo
    {
        //static fields
        static int x = 10, y;

        //static method
        static void calcute()
        {
            y = x * x;
            Console.WriteLine(y);
        }
        static void Main(string[] args)
        {
            //function calling directly
            staticDemo.calcute();
        }
    }
}

- Abstract -  In c#, abstract is a keyword, and it is useful to define classes and class members that are needed to be implemented or overridden in a derived class. The members we defined as abstract or included in an abstract class must be implemented by classes derived from an abstract class. The abstract class cannot instantiate, and it can contain both abstract and non-abstract members. The class that is derived from the abstract class must implement all the inherited abstract methods and accessors. The abstract classes can contain both abstract and non-abstract methods and accessors. Abstract classes cannot be instantiated. In c#, we should not use a sealed keyword with abstract class because the sealed keyword will make a class not inheritable, but abstract modifier requires a class to be inherited. A class that is derived from an abstract class must include all the implementations of inherited abstract methods and accessors.

Abstract Method: The abstract method is a method that is declared with a abstract modifier. If we define a method with abstract modifier, then that method doesn’t contain any implementation, and method declaration ends with a semicolon. The abstract methods in c# are permitted to declare only in abstract classes, and the class that is derived from an abstract class must provide an implementation for defined abstract methods. In c#, abstract methods are internally treated as virtual methods. Hence, those methods need to be overridden in the derived class, and we should not use static or virtual modifiers during abstract method declaration.

Ex -
using System;

namespace Tutlane
{
     abstract class Info
     {
         public void Welcome()
         {
             Console.WriteLine("Welcome to Tutlane");
         }
         public int age = 32;
         public abstract void GetDetails(string x, string y);
     }
     class User: Info
     {
         public override void GetDetails(string a, string b)
         {
            Welcome();
            Console.WriteLine("Name: {0}", a);
            Console.WriteLine("Location: {0}", b);
            Console.WriteLine("Age: {0}", age);
         }
     }
     class Program
     {
        static void Main(string[] args)
        {
            User u = new User();
            Console.WriteLine("****Abstract Class Example****");
            u.GetDetails("Suresh Dasari", "Hyderabad");
            Console.ReadLine();
        }
     }
}
O/P - 
Welcome to Tutlane
Name: Suresh Dasari
Location: Hyderabad
Age: 32

- Interface -  The interface is same as a class, but the only difference is class can contain both declarations and implementation of methods, properties, and events, but the interface will contain only the declarations of methods, properties, and events that a class or struct can implement. An interface in c# is more like a contract, The class or struct that implements an interface must provide an implementation for all the members specified in the interface definition. 
Generally, c# will not support multiple inheritance of classes, but that can achieve by using an interface. Also, a structure in c# cannot be inherited from another structure or class, but that can inherit by using interfaces. By default, the members of an interface are public, and we are not allowed to include any other access modifiers. In c#, an interface cannot be instantiated directly, but it can be instantiated by a class or struct that implements an interface.


Ex -
using System;

namespace Tutlane
{
    interface IUser
    {
       void GetDetails(string x);
    }
    class User: IUser
    {
        public void GetDetails(string a)
        {
           Console.WriteLine("Name: {0}", a);
        }
    }
    class User1: IUser
    {
       public void GetDetails(string a)
       {
          Console.WriteLine("Location: {0}", a);
       }
    }
    class Program
    {
       static void Main(string[] args)
       {
          IUser u = new User();
          u.GetDetails("Suresh Dasari");
          IUser u1 = new User1();
          u1.GetDetails("Hyderabad");
          Console.WriteLine("\nPress Enter Key to Exit..");
          Console.ReadLine();
       }
    }
}
O/P - 
Name : Suresh Dasari
Location: Hyderabad

* SOLID Principles

1. S – Single Responsibility Principle
“Each software module or class should have only one reason to change“. In other words, we can say that each module or class should have only one responsibility to do.
Ex - 
We are going to create an Invoice class with four functionalities as Adding and Deleting Invoices, Error Logging as well as Sending Emails. As we are putting all the above four functionalities into a single class or module, we are violating the Single Responsibility Principle in C#. This is because Sending Emails and Error Logging are not a part of the Invoice module. The following is the complete code and it is self-explained, so please go through the comments.

namespace SOLID_PRINCIPLES.SRP
{
    public class Invoice
    {
        public long InvAmount { get; set; }
        public DateTime InvDate { get; set; }

        public void AddInvoice()
        {
            try
            {
                // Here we need to write the Code for adding invoice
                // Once the Invoice has been added, then send the  mail
                MailMessage mailMessage = new MailMessage("EMailFrom", "EMailTo", "EMailSubject", "EMailBody");
                this.SendInvoiceEmail(mailMessage);
            }
            catch (Exception ex)
            {
                //Error Logging
                System.IO.File.WriteAllText(@"c:\ErrorLog.txt", ex.ToString());
            }
        }

        public void DeleteInvoice()
        {
            try
            {
                //Here we need to write the Code for Deleting the already generated invoice
            }
            catch (Exception ex)
            {
                //Error Logging
                System.IO.File.WriteAllText(@"c:\ErrorLog.txt", ex.ToString());
            }
        }

        public void SendInvoiceEmail(MailMessage mailMessage)
        {
            try
            {
                // Here we need to write the Code for Email setting and sending the invoice mail
            }
            catch (Exception ex)
            {
                //Error Logging
                System.IO.File.WriteAllText(@"c:\ErrorLog.txt", ex.ToString());
            }
        }
    }
}

Now let us discuss how to implement the above functionalities in such a way that, it should follow the Single Responsibility Principle.

Example: Implementing the SRP in C#
Now we are going to create three classes. In the invoice class, only the invoice-related functionalities are going to be implemented. The Logger class is going to be used only for logging purposes. Similarly, the Email class is going to handle Email activities. Now each class having only its own responsibilities, as a result, it follows the Single Responsibility Principle in C#.

Solution Ex.
Logger.cs
Add a class file with the name Logger.cs and then copy and paste the following code in it.

namespace SOLID_PRINCIPLES.SRP
{
    public interface ILogger
    {
        void Info(string info);
        void Debug(string info);
        void Error(string message, Exception ex);
    }
    public class Logger : ILogger
    {
        public Logger()
        {
            // here we need to write the Code for initialization 
            // that is Creating the Log file with necesssary details
        }
        public void Info(string info)
        {
            // here we need to write the Code for info information into the ErrorLog text file
        }
        public void Debug(string info)
        {
            // here we need to write the Code for Debug information into the ErrorLog text file
        }
        public void Error(string message, Exception ex)
        {
            // here we need to write the Code for Error information into the ErrorLog text file
        }
    }
}
As you can see in the above class file, we are defining all the logging activities i.e. info, debug and error. 

MailSender.cs
Now, we need to add another class file with the name MailSender.cs and then copy and paste the following code.

namespace SOLID_PRINCIPLES.SRP
{
    public class MailSender
    {
        public string EMailFrom { get; set; }
        public string EMailTo { get; set; }
        public string EMailSubject { get; set; }
        public string EMailBody { get; set; }
        public void SendEmail()
        {
            // Here we need to write the Code for sending the mail
        }
    }
}
In the above MailSender class, we are defining the send mail activities. 

Modifying the Invoice class:
Finally, modify the Invoice class as shown below.

using System.Net.Mail;
namespace SOLID_PRINCIPLES.SRP
{
    public class Invoice
    {
        public long InvAmount { get; set; }
        public DateTime InvDate { get; set; }
        private ILogger fileLogger;
        private MailSender emailSender;
        public Invoice()
        {
            fileLogger = new Logger();
            emailSender = new MailSender();
        }
        public void AddInvoice()
        {
            try
            {
                fileLogger.Info("Add method Start");
                // Here we need to write the Code for adding invoice
                // Once the Invoice has been added, then send the  mail
                emailSender.EMailFrom = "emailfrom@xyz.com";
                emailSender.EMailTo = "emailto@xyz.com";
                emailSender.EMailSubject = "Single Responsibility Princile";
                emailSender.EMailBody = "A class should have only one reason to change";
                emailSender.SendEmail();
            }
            catch (Exception ex)
            {
                fileLogger.Error("Error Occurred while Generating Invoice", ex.Message);
            }
        }
        public void DeleteInvoice()
        {
            try
            {
                //Here we need to write the Code for Deleting the already generated invoice
                fileLogger.Info("Delete Invoice Start at @" + DateTime.Now);
            }
            catch (Exception ex)
            {
                fileLogger.Error("Error Occurred while Deleting Invoice", ex);
            }
        }
    }
}
As you can see, the Invoice class delegating the logging activity to the “Logger” class. In the same way, delegate the Email Sending activity to the “MailSender” class. Now, the Invoice class now only concentrates on Invoice related activities.


2. O – Open Close Principle
The Open-Closed Principle states that “software entities such as modules, classes, functions, etc. should be open for extension, but closed for modification“. The Open for extension means we need to design the software modules/classes in such a way that the new responsibilities or functionalities should be added easily when new requirements come. On the other hand, Closed for modification means, we should not modify the class/module until we find some bugs.

within the Invoice class we have created the GetInvoiceDiscount() method. As part of that GetInvoiceDiscount() method, we are calculating the final amount based on the Invoice type. As of now, we have two Invoice Types as the Final Invoice and the Proposed Invoice. So we have implemented the logic using if-else. Tomorrow, if one more Invoice Type comes into the picture then we need to modify the GetInvoiceDiscount() method logic by adding another else if block to the source code. As we are changing the source code for the new requirement, we are violating the Open-Closed principle in C#. 

Example: Without using the Open-Closed Principle in C#
namespace SOLID_PRINCIPLES.OCP
{
    public class Invoice
    {        
        public double GetInvoiceDiscount(double amount, InvoiceType invoiceType)
        {
            double finalAmount = 0;
            if (invoiceType == InvoiceType.FinalInvoice)
            {
                finalAmount = amount - 100;
            }
            else if (invoiceType == InvoiceType.ProposedInvoice)
            {
                finalAmount = amount - 50;
            }
            return finalAmount;
        }
    }
    public enum InvoiceType
    {
        FinalInvoice,
        ProposedInvoice
    };
}
The problem with the above example is that if we want to add another new invoice type, then we need to add one more “else if” condition in the same “GetInvoiceDiscount” method, in other words, we need to modify the Invoice class. If we are changing the Invoice class again and again then we need to ensure that the previous functionalities along with the new functionalities are working properly by testing both the functionalities again. This is because we need to ensure that the existing clients, which are referencing this class are working properly as expected or not.

Open-Closed Principle in C#
As per the Open-Closed principle, Instead of MODIFYING, we should go for EXTENSION. If you want to follow the Open-Closed Principle in the above example, when a new invoice type needs to be added, then we need to add a new class. As a result, the current functionalities that are already implemented are going to be unchanged. The advantage is that we just only need to test and check the new classes.

Example: With Open-Closed Principle in C#
The following code example follows Open Closed Principle (OCP) in C#.

namespace SOLID_PRINCIPLES.OCP
{
    public class Invoice
    {
        public virtual double GetInvoiceDiscount(double amount)
        {
            return amount - 10;
        }
    }
    
    public class FinalInvoice : Invoice
    {
        public override double GetInvoiceDiscount(double amount)
        {
            return base.GetInvoiceDiscount(amount) - 50;
        }
    }
    public class ProposedInvoice : Invoice
    {
        public override double GetInvoiceDiscount(double amount)
        {
            return base.GetInvoiceDiscount(amount) - 40;
        }
    }
    public class RecurringInvoice : Invoice
    {
        public override double GetInvoiceDiscount(double amount)
        {
            return base.GetInvoiceDiscount(amount) - 30;
        }
    }
}
As you can see in the above code, we have created three classes FinalInvoice, ProposedInvoice, and RecurringInvoice. All these three classes are inherited from the base class Invoice and if they want then they can override the GetInvoiceDiscount() method. Tomorrow if another Invoice Type needs to be added then we just need to create a new class by inheriting it from the Invoice class. The point that you need to keep the focus on is we are not changing the code of the Invoice class.

Modify the Main method of the Program class as shown below to test the application.
using System;
namespace SOLID_PRINCIPLES.OCP
{
    class Program
    {
        static void Main(string[] args)
        {
            Invoice FInvoice = new FinalInvoice();
            Invoice PInvoice = new ProposedInvoice();
            Invoice RInvoice = new RecurringInvoice();
            double FInvoiceAmount = FInvoice.GetInvoiceDiscount(10000);
            double PInvoiceAmount = PInvoice.GetInvoiceDiscount(10000);
            double RInvoiceAmount = RInvoice.GetInvoiceDiscount(10000);
            Console.ReadKey();
        }
    }
}
Now, the Invoice class is closed for modification. But it is open for the extension as it allows creating new classes deriving from the Invoice class which clearly follows the Open-Closed Principle in C#. 


3. L – Liskov Substitution Principle
This principle states that, if S is a subtype of T, then objects of type T should be replaced with the objects of type S. In simple words we can say that, when we have a base class and child class relationships i.e. inheritance relationships, then, if we can successfully replace the object/instance of a parent class with an object/instance of the child class, without affecting the behavior of the base class instance, then it is said to be in Liskov Substitution Principle.

Example: Without using the Liskov Substitution Principle in C#:
Let us first understand one example without using the Liskov Substitution Principle in C#. In the following example, first, we create the Apple class with the method GetColor. Then we create the Orange class which inherits the Apple class as well as overrides the GetColor method of the Apple class. The point is that an Orange cannot be replaced by an Apple, which results in printing the color of the apple as Orange as shown in the below example.

namespace SOLID_PRINCIPLES.LSP
{
    class Program
    {
        static void Main(string[] args)
        {
            Apple apple = new Orange();
            Console.WriteLine(apple.GetColor());
        }
    }
    public class Apple
    {
        public virtual string GetColor()
        {
            return "Red";
        }
    }
    public class Orange : Apple
    {
        public override string GetColor()
        {
            return "Orange";
        }
    }
}
O/P - Orange

As you can see in the above example, Apple is the base class and Orange is the child class i.e. there is a Parent-Child relationship. So, we can store the child class object in the Parent Reference variable i.e. Apple apple = new Orange(); and when we call the GetColor i.e. apple.GetColor(), then we are getting the color of the Orange not the color of Apple. That means once the child object is replaced i.e. Apple storing the Orange object, the behavior is also changed. This is against the LSP Principle. The Liskov Substitution Principle in C# states that even the child object is replaced with the parent, the behavior should not be changed. So, in this case, if we are getting the color of Apple instead of Orange, then it follows the Liskov Substitution Principle. That means there is some issue with our software design. Let us see how to overcome the design issue and makes the application follow Liskov Substitution Principle.

Example Using the Liskov Substitution Principle in C#
Let’s modify the previous example to follow the Liskov Substitution Principle. Here, first, we need a generic base class such as Fruit which is going to be the base class for both Apple and Orange. Now you can replace the Fruit class object with its subtypes either Apple and Orage and it will behave correctly. Now, you can see in the below code, we created the super Fruit class as an abstract class with the GetColor abstract method and then the Apple and Orange class inherited from the Fruit class and implement the GetColor method.

namespace SOLID_PRINCIPLES.LSP
{
    class Program
    {
        static void Main(string[] args)
        {
            Fruit fruit = new Orange();
            Console.WriteLine(fruit.GetColor());
            fruit = new Apple();
            Console.WriteLine(fruit.GetColor());
        }
    }
    public abstract class Fruit
    {
        public abstract string GetColor();
    }
    public class Apple : Fruit
    {
        public override string GetColor()
        {
            return "Red";
        }
    }
    public class Orange : Fruit
    {
        public override string GetColor()
        {
            return "Orange";
        }
    }
}

Now, run the application and it should give the output as expected. Here we are following the LSP as we are now able to change the object with its subtype.

4. I –Interface Segregation Principle
The Interface Segregation Principle states that “Clients should not be forced to implement any methods they don’t use. Rather than one fat interface, numerous little interfaces are preferred based on groups of methods with each interface serving one submodule“. As per the Single Responsibility Principle of SOLID, like classes, interfaces also should have a single responsibility. That means we shouldn’t force any class to implement any method(s) which they don’t require.
We have an interface i.e. IPrinterTasks declared with four methods. Now if any class wants to implement this interface then that class should have to provide the implementation to all the four methods of the IPrinterTasks interface. As you can see in the above diagram, we have two classes HPLaserJetPrinter and LiquidInkjetPrinter who want the printer service. But the requirement is the HPLaserJetPrinter wants all the services provided by the IPrinterTasks while the LiquidInkjetPrinter wants only the Print and Scan service of the printer. As we have declared all the methods within the IPrinterTasks interface, then it is mandatory for the LiquidInkjetPrinter class to provide implementation to Scan and Print methods along with the Fax and PrinctDulex method which are not required by the class.

Example without using the Interface Segregation Principle in C#:
IPrinterTasks.cs

namespace SOLID_PRINCIPLES.ISP
{
    public interface IPrinterTasks
    {
        void Print(string PrintContent);
        void Scan(string ScanContent);
        void Fax(string FaxContent);
        void PrintDuplex(string PrintDuplexContent);
    }
}
HPLaserJetPrinter.cs
namespace SOLID_PRINCIPLES.ISP
{
    public class HPLaserJetPrinter : IPrinterTasks
    {
        public void Print(string PrintContent)
        {
            Console.WriteLine("Print Done");
        }
        public void Scan(string ScanContent)
        {
            Console.WriteLine("Scan content");
        }
        public void Fax(string FaxContent)
        {
            Console.WriteLine("Fax content");
        }
        public void PrintDuplex(string PrintDuplexContent)
        {
            Console.WriteLine("Print Duplex content");
        }
    }
}
LiquidInkjetPrinter.cs
namespace SOLID_PRINCIPLES.ISP
{
    class LiquidInkjetPrinter : IPrinterTasks
    {
        public void Print(string PrintContent)
        {
            Console.WriteLine("Print Done");
        }
        public void Scan(string ScanContent)
        {
            Console.WriteLine("Scan content");
        }
        public void Fax(string FaxContent)
        {
            throw new NotImplementedException();
        }
        public void PrintDuplex(string PrintDuplexContent)
        {
            throw new NotImplementedException();
        }
    }
}
As you can see in the above LiquidInkjetPrinter class the Fax and PrintDuplex methods are not required by the class but, still, it is implementing these two methods. This is violating the Interface Segregation Principle in C# as we are forcing the class to implement two methods that they don’t require.

Example using the Interface Segregation Principle:
namespace SOLID_PRINCIPLES.ISP
{
    public interface IPrinterTasks
    {
        void Print(string PrintContent);
        void Scan(string ScanContent);
    }
    interface IFaxTasks
    {
        void Fax(string content);
    }
    interface IPrintDuplexTasks
    {
        void PrintDuplex(string content);
    }
}

namespace SOLID_PRINCIPLES.ISP
{
    public class HPLaserJetPrinter : IPrinterTasks, IFaxTasks, 
                                     IPrintDuplexTasks
    {
        public void Print(string PrintContent)
        {
            Console.WriteLine("Print Done");
        }

        public void Scan(string ScanContent)
        {
            Console.WriteLine("Scan content");
        }

        public void Fax(string FaxContent)
        {
            Console.WriteLine("Fax content");
        }

        public void PrintDuplex(string PrintDuplexContent)
        {
            Console.WriteLine("Print Duplex content");
        }
    }
}
namespace SOLID_PRINCIPLES.ISP
{
    class LiquidInkjetPrinter : IPrinterTasks
    {
        public void Print(string PrintContent)
        {
            Console.WriteLine("Print Done");
        }

        public void Scan(string ScanContent)
        {
            Console.WriteLine("Scan content");
        }
    }
}

5. D – Dependency Inversion Principle 
The Dependency Inversion Principle (DIP) states that high-level modules/classes should not depend on low-level modules/classes. Both should depend upon abstractions. Secondly, abstractions should not depend upon details. Details should depend upon abstractions. When a class knows about the design and implementation of another class, it raises the risk that if we do any changes to one class will break the other class. So we must keep these high-level and low-level modules/classes loosely coupled as much as possible. To do that, we need to make both of them dependent on abstractions instead of knowing each other.

Let us understand the Dependency Inversion Principle in C# with one example
Let’s create one console application, Then create the following classes

Employee.cs
Create a class file with the name Employee.cs and then copy and paste the following code into it. The following is a simple class having 4 properties.

namespace SOLID_PRINCIPLES.DIP
{
    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public string Department { get; set; }
        public int Salary { get; set; }
    }
}
EmployeeBusinessLogic.cs
Create a class file with the name EmployeeBusinessLogic.cs and then copy and paste the following code into it. The following class has one constructor that is used to create an instance of EmployeeDataAccess. Here, within the constructor we call the static GetEmployeeDataAccessObj() method on the DataAccessFactory class which will return an instance of EmployeeDataAccess and we initialize the _EmployeeDataAccess property with the return instance. We have also one method i.e. GetEmployeeDetails which is used to call the GetEmployeeDetails method on the EmployeeDataAccess instance to get the employee detail by employee id.

namespace SOLID_PRINCIPLES.DIP
{
    public class EmployeeBusinessLogic
    {
        EmployeeDataAccess _EmployeeDataAccess;
        public EmployeeBusinessLogic()
        {
            _EmployeeDataAccess = DataAccessFactory.GetEmployeeDataAccessObj();
        }
        public Employee GetEmployeeDetails(int id)
        {
            return _EmployeeDataAccess.GetEmployeeDetails(id);
        }
    }
}
DataAccessFactory.cs
Create a class file with the name DataAccessFactory.cs and then copy and paste the following code into it. The following class contains one static method which is returning an instance of the EmployeeDataAccess class.

namespace SOLID_PRINCIPLES.DIP
{
    public class DataAccessFactory
    {
        public static EmployeeDataAccess GetEmployeeDataAccessObj()
        {
            return new EmployeeDataAccess();
        }
    }
}
EmployeeDataAccessLogic.cs
Create a class file with the name EmployeeDataAccess.cs and then copy and paste the following code into it. The following class contains one method which takes the employee id and returns that Employee information.

namespace SOLID_PRINCIPLES.DIP 
{
    public class EmployeeDataAccess
    {
        public Employee GetEmployeeDetails(int id)
        {
            // In real time get the employee details from db
            //but here we are hard coded the employee details
            Employee emp = new Employee()
            {
                ID = id,
                Name = "Pranaya",
                Department = "IT",
                Salary = 10000
            };
            return emp;
        }
    }
}
Let us compare the above example with the Dependency Inversion Principle in C#
As per the Dependency Inversion Principle definition, “a high-level module should not depend on low-level modules. Both should depend on the abstraction”.

So, first, we need to figure out which one is the high-level module (class) and which one is the low-level module (class) in our example. A high-level module is a module that always depends on other modules. So, in our example, the EmployeeBusinessLogic class depends on EmployeeDataAccess class, so here the EmployeeBusinessLogic class is the high-level module and the EmployeeDataAccess class is the low-level module.

So, as per the first rule of the Dependency Inversion Principle in C#, the EmployeeBusinessLogic class/module should not depend on the concrete EmployeeDataAccess class/module, instead, both the classes should depend on abstraction.

The second rule of the Dependency Inversion Principle state that “Abstractions should not depend on details. Details should depend on abstractions”.

Before understanding this let us first understand what is an abstraction.

What is Abstraction?
In simple words, we can say that Abstraction means something which is non-concrete. So, abstraction in programming means we need to create either an interface or abstract class which is non-concrete so that we can not create an instance of it. In our example, the EmployeeBusinessLogic and EmployeeDataAccess are concrete classes that mean we can create objects of it.

As per the Dependency Inversion Principle in C#, the EmployeeBusinessLogic (high-level module) should not depend on the concrete EmployeeDataAccess (low-level module) class. Both classes should depend on abstractions, meaning both classes should depend on either an interface or an abstract class.

What should be in the interface (or in the abstract class)?
As you can see in the above example, the EmployeeBusinessLogic uses the GetEmployeeDetails() method of EmployeeDataAccess class. In real-time, there will be many employee-related methods in the EmployeeDataAccess class. So, we need to declare the GetEmployeeDetails(int id) method within the interface. Add one interface with the name IDataAccess and then copy and paste the following codes.

IDataAccess.cs
Create a class file with the name IEmployeeDataAccess.cs and then copy and paste the following code into it. As you can see, here we created the interface with one abstract method i.e. GetEmployeeDetails.

namespace SOLID_PRINCIPLES.DIP
{
    public interface IEmployeeDataAccess
    {
        Employee GetEmployeeDetails(int id);
    }
}
Now, we need to implement the IEmployeeDataAccess in EmployeeDataAccess class. So, modify the EmployeeDataAccess class as shown below

EmployeeDataAccess.cs
namespace SOLID_PRINCIPLES.DIP
{
    public class EmployeeDataAccess : IEmployeeDataAccess
    {
        public Employee GetEmployeeDetails(int id)
        {
            // In real time get the employee details from db
            //but here we are hardcoded the employee details
            Employee emp = new Employee()
            {
                ID = id,
                Name = "Pranaya",
                Department = "IT",
                Salary = 10000
            };
            return emp;
        }
    }
}
Now, we need to change the factory class which will return the IEmployeeDataAccess instead of the concrete EmployeeDataAccess class as shown below.

DataAccessFactory.cs
Modify the DataAccessFactory class below. Please notice here we have changed the return type of the GetEmployeeDataAccessObj method from EmployeeDataAccess to IEmployeeDataAccess.

namespace SOLID_PRINCIPLES.DIP
{
    public class DataAccessFactory
    {
        public static IEmployeeDataAccess GetEmployeeDataAccessObj()
        {
            return new EmployeeDataAccess();
        }
    }
}
Now, we need to change the EmployeeBusinessLogic class which will use the IEmployeeDataAccess instead of the concrete EmployeeDataAccess class as shown below.

namespace SOLID_PRINCIPLES.DIP
{
    public class EmployeeBusinessLogic
    {
        IEmployeeDataAccess _EmployeeDataAccess;
        public EmployeeBusinessLogic()
        {
            _EmployeeDataAccess = DataAccessFactory.GetEmployeeDataAccessObj();
        }
        public Employee GetEmployeeDetails(int id)
        {
            return _EmployeeDataAccess.GetEmployeeDetails(id);
        }
    }
}
That’s it. We have implemented the Dependency Inversion Principle in our example where the high-level module (EmployeeBusinessLogic) and low-level module (EmployeeDataAccess) depend on abstraction (IEmployeeDataAccess). Also, abstraction (IEmployeeDataAccess) does not depend on details (EmployeeDataAccess) but details depend on abstraction.





1. Promise vs Observable
Promises are eager, Observables are lazy.Function passed to Observable constructor gets called only when someone actually subscribes to an Observable.
With a Promise you can only handle one event.
With an Observable you can handle multiple events.
.subscribe() is similar to .then(). 
An Observable can do everything that a Promise can do, plus more.
Use Angular’s HttpClient to handle API calls.
The Angular framework uses a lot of RxJS.


E.g.
* Promise
Promise is always resolved with the first value passed to the resolve function and ignores further calls to it.
const numberPromise = new Promise((resolve) => {
    resolve(5);
    resolve(10);
});

numberPromise.then(value => console.log(value));
// still prints only 5

*Observables
On the contrary, Observables allow you to resolve (or, as we say, “emit”) multiple values. Here is how it would look.
const numberObservable = new Observable((observer) => {
    observer.next(5);
    observer.next(10);
});

numberObservable.subscribe(value => console.log(value));
// prints 5 and 10


2. State Management in Angular v2+
https://medium.com/olricdigital/introduction-to-state-management-in-angular-v2-ef6f5144bade

- “State” term includes both the state of UI and the state of variables in your code. So any change in your application changes the state.
In Angular or other modern JS frameworks, each component has its own state and a component has no idea about the other components’ states unless we make enable the data flow between components. We use @Input and @Output decorators to pass information between parent and child components in Angular v2+.

- It is easy to pass information between components in simple apps. But it gets complicated and painful when you have complex app architecture. Let’s think about how to pass data between Component 2 and Component 6. If you use @Input/@Output it takes 4 hops to get Component 6 from Component 2 and the you should involve the other 3 components in this process.

- We should mention about Redux at this point. Redux is an elegant solution architecture which simplifies the state management.
There are three core principles in Redux architecture:

	*Single Store: state of the application should be stored in a single “store”. Store is the only responsible in providing data to components. Data flows between component and Store instead of component-to-component.

	*Read-only state: state should be read-only or immutable. To change the state, new action should be emitted.

	*Pure function reducers: Reducers take the current state and an action and return next state. Reducers should not take any other parameters outside the function.
	
- Another important point of Redux is that all data in the application flows only one-way, in other words data flow is unidirectional.
	*Component dispatches an action
	*Reducer in the store takes the action and produces a new state
	*New state pass to the component from Store.
	
- @ngrx/store
@ngrx/store is a state management extension for Angular applications inspired by Redux. It imports all core concepts from Redux. From now on, we will use @ngrx/store terms instead of Redux.

- Store
Store is the core structure where actions, reducers and state are located. The store receives actions as inputs, and transmit actions to reducers. Reducers produce a new state depending on the action and emit the new state. The store holds the new state until it changes via another action.

- Action
An action consists of two parts, type and payload. Type is required to make reducer enable to distinguish the actions. Therefore type must be unique for each action.

-Selector: Selector is a function used for obtaining a part of the state from the store.

- Reducer
The reducer is the core element in the tore and it is the responsible for changing the state. A reducer takes action and current state as input parameters and returns a new state according to the function inside it.
(The state is immutable in Redux architecture, so the reducer does not mutate the state but produces a new one.)
It gets more meaningful to implement @ngrx/store in your Angular app when the application goes complex.

3. Stored Procedure vs Select queries.
In SQL Profiler if you observe In select queries, it will first insert the cache (CacheInsert) and when you change parameter in where condition it will again and again creating CacheInsert. But stored procedure at first will create CacheInsert but later on it will use that cache data using CacheHit Event class. So thats why SP is faster than normal SQL query.


3. C# Abstract class constructor with Real Time Example
An abstract class can have a constructor, even though abstract class cannot be instantiated. 
when we create an object of a derived class then constructor of abstract base class is implicitly called, even though we cannot instantiate an abstract class. For example in program, if we create object of derived class then abstract base class constructor will also be called.

abstract class A
{
    protected A() {Console.WriteLine("Abstract class constructor"); }
}
//Derived class
class B : A
{
   public B() {Console.WriteLine("Derived class constructor"); }
}

class Program
{
    static void Main(string[] args)
    {
        B obj = new B();
    }
}

Output:
Abstract class constructor
Derived class constructor

4. Columnstore Indexes?
 Row store does exactly as the name suggests – stores rows of data on a page – and column store stores all the data in a column on the same page. Rowstores are better at random reads and random writes. Columnstores are better at sequential reads and sequential writes.
 
When to use NoLocks?
When update or insert operation happening on table but you want to select records from that table, use nolock to fetch records which are not commited
Issues with NOLOCK
We mentioned above how you can get dirty reads using the NOLOCK hint. These are also other terms you may encounter for this hint.

Dirty Reads - this occurs when updates are done, so the data you select could be different.
Nonrepeatable Reads - this occurs when you need to read the data more than once and the data changes during that process
Phantom Reads - occurs where data is inserted or deleted and the transaction is rolled back. So for the insert you will get more records and for the delete you will get less records.

Index Scan:
Since a scan touches every row in the table, whether or not it qualifies, the cost is proportional to the total number of rows in the table. Thus, a scan is an efficient strategy if the table is small or if most of the rows qualify for the predicate.

Index Seek:
Since a seek only touches rows that qualify and pages that contain these qualifying rows, the cost is proportional to the number of qualifying rows and pages rather than to the total number of rows in the table.
If there is no index, then you might see a Table Scan (Index Scan) in the execution plan.
Index seeks are generally preferred for the highly selective queries. What that means is that the query is just requesting a fewer number of rows or just retrieving the other 10 (some documents says 15 percent) of the rows of the table.
In general query optimizer tries to use an Index Seek which means that the optimizer has found a useful index to retrieve recordset. But if it is not able to do so either because there is no index or no useful indexes on the table, then SQL Server has to scan all the records that satisfy the query condition.

5. IEnumerable Vs IQueryable
IEnumerable
System.Collections Namespace
No base interface	
Lazy Loading Not Supported
While querying data from database, IEnumerable executes select query on server side, load data in-memory on client side and then filter data. Hence does more work and becomes slow.
Suitable for LINQ to Object and LINQ to XML queries
IEnumerable is suitable for querying data from in-memory collections like List, Array and so on.
 	

IQueryable
System.Linq Namespace
Derives from IEnumerable
Lazy Loading Supported
While querying data from database, IQueryable executes select query on server side with all filters. Hence does less work and becomes fast.
Suitable for LINQ to SQL queries
IQueryable is suitable for querying data from out-memory (like remote database, service) collections.


6. Where do we register DI and how to add Dependency Injection
Dependency injection is the design pattern that allow us to inject the dependency to the class from outer world rather than creating with in class. This will help us to create loosely coupled application so that it has provided greater maintainability, testability and also reusability. There is a built-in support of dependency injection in ASP.net Core. This supports is not limited to middleware, but also support in Controllers, views, and model as well. There are three easy step to use Dependency injection into ASP.net core MVC application.

-Create the service
-Register the service into ConfigureService method of the startup class, so that it available to use
-Inject the service where you want to use
-ASP.net core allow us to specify the lifetime for registered services based on our requirement to use the service. The service can either register as Singleton, Transient or Scoped.

7. Model vs ViewModel
Model: Strictly looks and feels like your data model. For all intents and purposes it is only a class representation of your data model. It has no knowledge of your View or any elements within your View. That said, it should not contain any attribute decorators (ie; Required, Length, etc.) that you would use for your View.

View Model: Serves as a data-binder between your View and your Model and in many cases, is also a wrapper for your Model. It would be rendered useless without the View, so it typically isn't reusable across multiple Views and Controllers like a standard Model is.

8. When to use HTTPGET, POST, PUT, DELETE
You can practically use a POST to do all the CRUD operations but you shouldn't. Because Each HTTP verb has its own responsibility. A GET is supposed to be idempotent and safe. A GET can be cached and in a browser, refreshed again and again. Ideally, firing a GET request shouldn't change the data. If HttpGet method can delete, can insert, can update and also can return value then why we use HttpPort, HttpPut and HttpDelete?

Imagine a scenario.
You have a Web API method which adds a new entry to the database using GET. If your GET request becomes a link and it gets crawled by a search engine. You will have your database full of duplicate data. So it makes sense to use POST in this case.

Selecting The Appropriate Method

GET - requests data from the resource and should not produce any side effect.
POST - method requests the server to create a resource in the database, mostly when a web form is submitted. Post is non-idempotent which means multiple requests will have different effects.
PUT - method requests the server to update a resource or create the resource, if it doesn’t exist. Put is idempotent which means multiple requests will have the same effects.
DELETE - method requests that the resources, or its instance, should be removed from the database.

POST vs PUT

POST and PUT are very similar in that they both send data to the server that the server will need to store somewhere. if you make the same request twice using PUT, with the same parameters both times, the second request will have no effect. This is why PUT is generally used for the Update scenario.

There are some more limitations for different Http verbs as well.

GET parameters are passed as part of the URL, which is of small and limited length of 256 chars by default, with some servers supporting 4000+ chars. If you want to insert a long record,you'll have to use POST. Post is considered limitless but there are limitations which vary according to browsers.
GET is re-executed if a user presses a Back button in a browser. Post doesn't.
GET is cached by browsers, nodes in the network, Internet Service Providers.
Unless the content changes, GET to the same URL must return same results to all the users or else you won't have any trust what so ever in the returned result. etc

9. How you manage connectionstring for dev, sit, uat, prod
In Startup file by using IHostingEnvironment we can set IsDevelopment, IsProduction, IsStaging

10. Why to use WebApi if we can return through MVC also
Web API Controllers can be created and hosted in any ASP.NET Application, not just MVC applications. Thus, an obvious reason to create a Web API is if you do not have an MVC front-end (e.g. classic, RESTful web-services hosted by your company/organization.)Almost all MVC Controllers are implemented with the View in mind.

11. What is component, What contains in Component
Components are like the basic building block in an Angular application. Components are defined using the @component decorator. A component has a selector, template, style and other properties, using which it specifies the metadata required to process the component. Compnent is custom tag like how html contains input, form tag. The specific type of directive that allows us to utilize web component functionality - encapsulated, reusable elements available throughout our application. Component is a directive with a view or template.

12. Directive and its type , how will you crate custom directive, have you created custom directive in your project 
Directives is used to add behavior to an existing DOM element. Directive is use to design re-usable components. Directives don’t have View. You can’t define Pipes in directive.

Component vs Directive
For register component we use @Component meta-data annotation.For register directives we use @Directive meta-data annotation.
Component is a directive which use shadow DOM to create encapsulate visual behavior called components.  Components are typically used to create UI widgets.Directives is used to add behavior to an existing DOM element.
Component is used to break up the application into smaller components.Directive is use to design re-usable components.
Only one component can be present per DOM element.Many directive can be used in a per DOM element
@View decorator or templateurl template are mandatory in the component.Directives don’t have View.
Component is used to define pipes. You can’t define Pipes in directive.

13. 
Single() - There is exactly 1 result, an exception is thrown if no result is returned or more than one result. 
SingleOrDefault() – Same as Single(), but it can handle the null value.

First() - There is at least one result, an exception is thrown if no result is returned.
FirstOrDefault() - Same as First(), but not thrown any exception or return null when there is no result.

Single() asserts that one and only one element exists in the sequence.
First() simply gives you the first one.

Use Single / SingleOrDefault() when you sure there is only one record present in database or you can say if you querying on database with help of primary key of table.
Developer may use First () / FirstOrDefault() anywhere,  when they required single value from collection or database.

Single() or SingleOrDefault() will generate a regular TSQL like "SELECT ...".
The First() or FirstOrDefault() method will generate the TSQL statment like "SELECT TOP 1..."

14. map, set 
Map is a new data structure introduced in ES6 which lets you map keys to values without the drawbacks of using Objects.
let map = new Map();
map.set("A",1);
map.set("B",2);
map.set("C",3);

Sets are a bit like maps but they only store keys not key–value pairs.
let set = new Set();
set.add('APPLE');
set.add('ORANGE');
set.add('MANGO');

15. 
Delegates - Delegate is a type that defines a method signature and it is useful to hold the reference of one or more methods which are having the same signatures.
By using delegates, you can invoke the methods and send methods as an argument to other methods.
E.g. <access_modifier> delegate <return_type> <delegate_name>(<parameters>)
    public delegate void SampleDelegate(int a, int b);
	SampleDelegate dlgt = m.Add;

Func - Func is a built-in generic delegate and it is useful to hold the reference of one or more methods which is having the same method signature without declaring any custom delegate object.
E.g. public delegate TResult Func<in T,out TResult>(T arg);
            Func<int, int, int> dlgt = Add;

Action - Action is a built-in generic delegate same as Func delegate to hold the reference of one or more methods but the only difference is the Action delegate will not return any value. 
E.g. public delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);

Predicate - Predicate is a built-in generic delegate and it is useful to validate whether the input parameter meets the specified condition or not and it’s same as Func and Action delegates to hold the reference of one or more methods.
E.g. public delegate bool Predicate<in T>(T arg);

16. 
What is an Observable
Observable converts the ordinary stream of data into an observable stream of data. It observes the stream of data and emits the value, complete or error signals to the consumers of the stream. You can think of Observable it as a wrapper around the stream of data. Observables are declarative. You define an observable function just like any other variable. The observable function executes only when someone subscribes to it.

Who are observers (subscribers)
The Observable on its own is useless unless someone consumes the value delivered by the observable. We call them observers or subscribers. The observable communicates with the observers using callbacks. The observer must subscribe with the observable to receive the value from the observer. While subscribing it optionally passes the three callbacks. next(), error() & complete().

The observable invokes the next() callback whenever the value arrives in the stream. It passes the value as the argument to the next callback. If the error occurs, then the error() callback is invoked. It invokes the complete() callback when the stream completes.

Observable creation functions
1. Create - The Create method is one of the easiest. The create method calls the observable constructor behind the scene. Create is a method of the observable object, Hence you do not have to import it. The Create method calls the constructor behind the scene.

2. Of Operator - The Of creates the observable from the arguments that you pass into it. You can pass any number of arguments to the Of. Each argument emitted separately and one after the other. It sends the Complete signal in the end. Accepts variable no of arguments. emits each argument as it is without changing anything		
E.g. ngOnInit() {
  const array=[1,2,3,4,5,6,7]
  const obsof1=of(array);
  obsof1.subscribe(val => console.log(val),
           error=> console.log("error"),
          () => console.log("complete"))
 
}
 
**** Output ***
[1, 2, 3, 4, 5, 6, 7]
complete

3. From Operator - From Operator takes only one argument that can be iterated and converts it into an observable.Accepts only one argument. iterates over the argument and emits each value.

17. Observable vs Promises
Promise emits a single value while Observable emits multiple values. So, while handling a HTTP request, Promise can manage a single response for the same request, but what if there are multiple responses to the same request, then we have to use Observable. Yes, Observable can handle multiple responses for the same request. But, promise returns the very first value and ignore the remaining values whereas Observable return all the value. Promise is not lazy while Observable is lazy. Observable is lazy in nature and do not return any value until we subscribe. Observable is cancellable in nature by invoking unsubscribe() method, but Promise is not cancellable in nature.

18. What is AOT vs JIT
JIT generates JavaScript however, AoT usually generates TypeScript.
* JIT - Compile TypeScript just in time for executing it.
Compiled in the browser.
Each file compiled separately.
No need to build after changing your code and before reloading the browser page.
Suitable for local development.

* AOT - Compile TypeScript during build phase.
Compiled by the machine itself, via the command line (Faster).
All code compiled together, inlining HTML/CSS in the scripts.
No need to deploy the compiler (Half of Angular size).
More secure, original source not disclosed.
Suitable for production builds.

19. constant vs static vs readonly
* Constant

Constant fields are defined at the time of declaration in the code snippet, because once they are defined they can't be modified. By default a constant is static, so you can't define them static from your side. It is also mandatory to assign a value to them at the time of declaration otherwise it will give an error during compilation of the program snippet. That's why it is also called a compile-time constant.
E.g.
void Sum(int j)  
{  
const int i = 9, k = 2;  
const int A = i + k;  
} 
Output: 11

Explanation
The preceding code snippet will produce a result of 11, without showing any error since we already declared it at the initial point of declaration.
What if, we make some changes in the code above, such as:

void Sum(int j)  
{  
   const int i = 9, k = 2;  
// const int A = i + k;  
   Const int B = i + j;  
} 
Explanation
This code snippet will take you toward a compile-time error, because there is no initialization, since it's evaluated at run time.

Points to Remember

Compile-time constant
Can't be declared static
Can't be modified or changed
Can be of any type of Access Modifier
Local scope
Needs to get initialized
Declared at the time of declaration

* Readonly
A Readonly field can be initialized either at the time of declaration or within the constructor of the same class. We can also change the value of a Readonly at runtime or assign a value to it at runtime (but in a non-static constructor only). For that reason a Readonly field is also called a run-time constant.

E.g.
class ReadOnly  
{  
   readonly int i;  
   public ReadOnly( )  
   {  
       i = 11;  
       Console.WriteLine(i);  
   }  
} 
Explanation
We can assign the value to an integer later in the snippet; this is possible when using the Readonly keyword. We can modify it too depending on the use.

Points to Remember

Run-time constant
It can be static
Global scope
Can be declared in the constructer class
Generally public

* Static

The static keyword is used to declare a static member. If we are declare a class as a static class then in this case all the class members must be static too. The static keyword can be used effectively with classes, fields, operators, events, methods and so on effectively.

Snippet

class ReadOnly  
{  
    static int i = 11;  
    public static void disp()  
    {  
        Console.WriteLine(i);  
    }  
} 
Output: 11

Explanation

This code will show no error and produce a result (11), since we declared its value to be static at the time of declaration. So we can access it depending on our use in the program.

Let's make some changes in the snippet and see what happens then.

class ReadOnly  
{  
    int i = 9;  
    public static void disp()  
    {  
        Console.WriteLine(i);  
    }  
} 
Explanation
This snippet will show an error, because we didn't declare a value for the static and we are trying to access it within a method. We can't do that.

Points to Remember

Can't be used with indexers
Works with constructors too
By default it is private
Can be parameterized or public too
If its applied to a class then all the class members need to be static


20. What is json
JSON stands for JavaScript Object Notation. JSON is a lightweight format for storing and transporting data. JSON is often used when data is sent from a server to a web page
JSON is "self-describing" and easy to understand.

21. Why static
Each object has its own set of member variables and all the member variables have a scope. If we want a variable to have the same value throughout all instances of the object then we can declare it as a static variable in our program. To manipulate and use the values of static variables we can also define a function as static. The keyword "static" means that only one instance of a given variable exists for a class. Static variables are used to define constants because their values can be retrieved by invoking the class without creating an instance of it. Static variables can be initialized outside the member function or class definition. Unlike other member variables, only one copy of the static variable exists in memory for all the objects of that class. Therefore, all objects share one copy of the static variable in memory.

22. What is AuthGuards
Auth-guard makes use of CanActivate interface and it checks for if the user is logged in or not. If it returns true, then the execution for the requested route will continue, and if it returns false, that the requested route will be kicked off and the default route will be shown.
https://www.c-sharpcorner.com/article/protecting-routes-with-auth-guard-in-angular-7/

23. 















Directive, Example of Attribute Directive
https://www.tektutorialshub.com/angular/angular-directives/
https://www.tektutorialshub.com/angular/angular-ngclass-directive/

What is Observable, normal method and observable method difference.



What is Resolver in AuthGuards, resolver in routing
Routing Flow with Resolver
User clicks the link.
Angular executes certain code and returns a value or observable.
You can collect the returned value or observable in constructor or in ngOnInit, in class of your component which is about to load.
Use the collected the data for your purpose.
Now you can load your component.
Steps 2,3 and 4 are done with a code called Resolver.
So basically resolver is that intermediate code, which can be executed when a link has been clicked and before a component is loaded.


Lazy Loading
what is Map
what is Filter
MergeMap and 
let vs const
uploading bulk data can we navigate to other component
Custom directive
ngModel we have used I have to check whether the value is entered or not, Reactive forms, How to validate model value, user clicks submit method you have to validate whether value is entered or not
How will you declare reactive forms
can we create multiple form form inside other form
what type of validation you are using
if I type something then what kind of validation you will use,  keypress event, how will you declare output

Why we use API
WebAPI is stateful or stateless
Attribute Routing
Verbs in WebAPI
What if we not declared HTTPVERBS can we access get, post
how will you restrict action method GET, POST
where do we register routes, RouteConfig
What are types response types from WebAPI, what webapi will return return types
exception occur in WebAPI what is status code of exception and exception
Entityframework version, mvc version


How to disable lazy loading
Check version difference in angular, C#
Queries of SQL, Top highest salaries
Web Security
Design patterns 
Stack Heap
Dependency Injection
Delegate func predicate action
CTE
Entityframework Queries join
How can you see plan seek and scan
OAuth
Debug vs release
covariance and contravarince
Why abstract and not concreate
WebAPI Middleware
Rownumber, PartitionBy, Rank, DenseRank
webAPI code using serializer
Question on finally block
Dispose
SQLDataAdapter
callback
class vs structure
Why value types in stack and reference types in heap














Role of model in your project
To display list of employees, create, update, implementation of that


Gateway

Authorization in .NetCore, Authorization in Angular
https://jasonwatmore.com/post/2019/10/16/aspnet-core-3-role-based-authorization-tutorial-with-example-api
https://jasonwatmore.com/post/2019/08/06/angular-8-role-based-authorization-tutorial-with-example








sealed class
extension methods
string interpolation
interface vs abstraction
method overriding

Difference between first and firstordefault
left join in linq query
can I have the method in derived class of same but different parameters can we override that method


Services in Angular
https://dzone.com/articles/what-is-a-service-in-angular-js-why-to-use-it


inner join vs left join
where we use char and nchar
primary key in SQL can it be null
foreign key can it be null
how to check whether value isnull in where condition

UST Global
Angular Lifecycle, which one will call at the end of lifecycle,  why to use ngOnDestroy
https://www.tektutorialshub.com/angular-tutorial/#component-life-cycle-hook
https://www.tektutorialshub.com/angular/angular-ngoninit-and-ngondestroy/

parent to child, child to parent, cross component
https://www.tektutorialshub.com/angular/angular-passing-data-child-component/

Custom library, or packages

Custom Pipes, What is Pipe
https://www.tektutorialshub.com/angular/angular-custom-pipes/




Http GET, POST
https://www.djamware.com/post/5b87894280aca74669894414/angular-6-httpclient-consume-restful-api-example
 



Cloudmoyo

-Abstraction and Encapsulation, Practical example of Abstraction
https://www.tutlane.com/tutorial/csharp/csharp-abstraction


-Pipe
https://www.tektutorialshub.com/angular/angular-custom-pipes/












